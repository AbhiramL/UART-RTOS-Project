
Basic_RTOS_Example.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004358  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000104  20000000  00004358  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00003ca4  20000104  0000445c  00020104  2**2
                  ALLOC
  3 .ARM.attributes 00000028  00000000  00000000  00020104  2**0
                  CONTENTS, READONLY
  4 .comment      00000059  00000000  00000000  0002012c  2**0
                  CONTENTS, READONLY
  5 .debug_info   0005f4c0  00000000  00000000  00020185  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000079a7  00000000  00000000  0007f645  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000bf3b  00000000  00000000  00086fec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000dc8  00000000  00000000  00092f27  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00001820  00000000  00000000  00093cef  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  00020232  00000000  00000000  0009550f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00012ff5  00000000  00000000  000b5741  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00088d6d  00000000  00000000  000c8736  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  0000255c  00000000  00000000  001514a4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new[](size_t size) {
       0:	00 80 00 20 6d 03 00 00 55 03 00 00 55 03 00 00     ... m...U...U...
	...
      2c:	55 03 00 00 00 00 00 00 00 00 00 00 55 33 00 00     U...........U3..
      3c:	c1 03 00 00 55 03 00 00 55 03 00 00 55 03 00 00     ....U...U...U...
      4c:	55 03 00 00 55 03 00 00 55 03 00 00 55 03 00 00     U...U...U...U...
      5c:	59 03 00 00 55 03 00 00 21 2b 00 00 55 03 00 00     Y...U...!+..U...
      6c:	55 03 00 00 55 03 00 00 55 03 00 00 31 2b 00 00     U...U...U...1+..
      7c:	55 03 00 00 55 03 00 00 55 03 00 00 55 03 00 00     U...U...U...U...
      8c:	55 03 00 00 00 00 00 00 55 03 00 00 55 03 00 00     U.......U...U...
      9c:	55 03 00 00 55 03 00 00 55 03 00 00 55 03 00 00     U...U...U...U...
      ac:	55 03 00 00 00 00 00 00                             U.......

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000104 	.word	0x20000104
      d4:	00000000 	.word	0x00000000
      d8:	00004354 	.word	0x00004354

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	20000108 	.word	0x20000108
     108:	00004354 	.word	0x00004354
     10c:	20000100 	.word	0x20000100
     110:	00000000 	.word	0x00000000

00000114 <_ZL7threadAPv>:
//*****************************************************************
// Create a thread that prints out A to the screen every two seconds
// this task will delete its self after printing out afew messages
//*****************************************************************
static void threadA( void *pvParameters ) 
{
     114:	b510      	push	{r4, lr}
  
  SERIAL.println("Thread A: Started");
     116:	4c06      	ldr	r4, [pc, #24]	; (130 <_ZL7threadAPv+0x1c>)
     118:	4906      	ldr	r1, [pc, #24]	; (134 <_ZL7threadAPv+0x20>)
     11a:	0020      	movs	r0, r4
     11c:	f000 f9cc 	bl	4b8 <_ZN5Print7printlnEPKc>
  while(1)
  {
    SERIAL.print("A");
     120:	4905      	ldr	r1, [pc, #20]	; (138 <_ZL7threadAPv+0x24>)
     122:	0020      	movs	r0, r4
     124:	f000 f9b6 	bl	494 <_ZN5Print5printEPKc>
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     128:	4804      	ldr	r0, [pc, #16]	; (13c <_ZL7threadAPv+0x28>)
     12a:	f002 f95d 	bl	23e8 <vTaskDelay>
     12e:	e7f7      	b.n	120 <_ZL7threadAPv+0xc>
     130:	20000abc 	.word	0x20000abc
     134:	00003db9 	.word	0x00003db9
     138:	00003e01 	.word	0x00003e01
     13c:	00001388 	.word	0x00001388

00000140 <_Z11taskMonitorPv>:
//*****************************************************************
// Task will periodicallt print out useful information about the tasks running
// Is a useful tool to help figure out stack sizes being used
//*****************************************************************
void taskMonitor(void *pvParameters)
{
     140:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int x;
    int measurement;
    
    SERIAL.println("Task Monitor: Started");
     142:	250a      	movs	r5, #10
     144:	4c27      	ldr	r4, [pc, #156]	; (1e4 <_Z11taskMonitorPv+0xa4>)
     146:	4928      	ldr	r1, [pc, #160]	; (1e8 <_Z11taskMonitorPv+0xa8>)
     148:	0020      	movs	r0, r4
     14a:	f000 f9b5 	bl	4b8 <_ZN5Print7printlnEPKc>
      SERIAL.println("******************************");
      SERIAL.println("[Stacks Free Bytes Remaining] ");

      measurement = uxTaskGetStackHighWaterMark( Handle_aTask );
      SERIAL.print("Thread A: ");
      SERIAL.println(measurement);
     14e:	002e      	movs	r6, r5
      SERIAL.println("");
     150:	4926      	ldr	r1, [pc, #152]	; (1ec <_Z11taskMonitorPv+0xac>)
     152:	0020      	movs	r0, r4
     154:	f000 f9b0 	bl	4b8 <_ZN5Print7printlnEPKc>
      SERIAL.println("******************************");
     158:	4f25      	ldr	r7, [pc, #148]	; (1f0 <_Z11taskMonitorPv+0xb0>)
     15a:	0020      	movs	r0, r4
     15c:	0039      	movs	r1, r7
     15e:	f000 f9ab 	bl	4b8 <_ZN5Print7printlnEPKc>
      SERIAL.println("[Stacks Free Bytes Remaining] ");
     162:	4924      	ldr	r1, [pc, #144]	; (1f4 <_Z11taskMonitorPv+0xb4>)
     164:	0020      	movs	r0, r4
     166:	f000 f9a7 	bl	4b8 <_ZN5Print7printlnEPKc>
      measurement = uxTaskGetStackHighWaterMark( Handle_aTask );
     16a:	4b23      	ldr	r3, [pc, #140]	; (1f8 <_Z11taskMonitorPv+0xb8>)
     16c:	3d01      	subs	r5, #1
     16e:	6818      	ldr	r0, [r3, #0]
     170:	f002 faa4 	bl	26bc <uxTaskGetStackHighWaterMark>
      SERIAL.print("Thread A: ");
     174:	4921      	ldr	r1, [pc, #132]	; (1fc <_Z11taskMonitorPv+0xbc>)
      measurement = uxTaskGetStackHighWaterMark( Handle_aTask );
     176:	9001      	str	r0, [sp, #4]
      SERIAL.print("Thread A: ");
     178:	0020      	movs	r0, r4
     17a:	f000 f98b 	bl	494 <_ZN5Print5printEPKc>
      SERIAL.println(measurement);
     17e:	0032      	movs	r2, r6
     180:	9901      	ldr	r1, [sp, #4]
     182:	0020      	movs	r0, r4
     184:	f000 f9ed 	bl	562 <_ZN5Print7printlnEii>
      
      measurement = uxTaskGetStackHighWaterMark( Handle_bTask );
     188:	4b1d      	ldr	r3, [pc, #116]	; (200 <_Z11taskMonitorPv+0xc0>)
     18a:	6818      	ldr	r0, [r3, #0]
     18c:	f002 fa96 	bl	26bc <uxTaskGetStackHighWaterMark>
      SERIAL.print("Thread B: ");
     190:	491c      	ldr	r1, [pc, #112]	; (204 <_Z11taskMonitorPv+0xc4>)
      measurement = uxTaskGetStackHighWaterMark( Handle_bTask );
     192:	9001      	str	r0, [sp, #4]
      SERIAL.print("Thread B: ");
     194:	0020      	movs	r0, r4
     196:	f000 f97d 	bl	494 <_ZN5Print5printEPKc>
      SERIAL.println(measurement);
     19a:	0032      	movs	r2, r6
     19c:	9901      	ldr	r1, [sp, #4]
     19e:	0020      	movs	r0, r4
     1a0:	f000 f9df 	bl	562 <_ZN5Print7printlnEii>
      
      measurement = uxTaskGetStackHighWaterMark( Handle_monitorTask );
     1a4:	4b18      	ldr	r3, [pc, #96]	; (208 <_Z11taskMonitorPv+0xc8>)
     1a6:	6818      	ldr	r0, [r3, #0]
     1a8:	f002 fa88 	bl	26bc <uxTaskGetStackHighWaterMark>
      SERIAL.print("Monitor Stack: ");
     1ac:	4917      	ldr	r1, [pc, #92]	; (20c <_Z11taskMonitorPv+0xcc>)
      measurement = uxTaskGetStackHighWaterMark( Handle_monitorTask );
     1ae:	9001      	str	r0, [sp, #4]
      SERIAL.print("Monitor Stack: ");
     1b0:	0020      	movs	r0, r4
     1b2:	f000 f96f 	bl	494 <_ZN5Print5printEPKc>
      SERIAL.println(measurement);
     1b6:	0032      	movs	r2, r6
     1b8:	9901      	ldr	r1, [sp, #4]
     1ba:	0020      	movs	r0, r4
     1bc:	f000 f9d1 	bl	562 <_ZN5Print7printlnEii>

      SERIAL.println("******************************");
     1c0:	0039      	movs	r1, r7
     1c2:	0020      	movs	r0, r4
     1c4:	f000 f978 	bl	4b8 <_ZN5Print7printlnEPKc>
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     1c8:	4811      	ldr	r0, [pc, #68]	; (210 <_Z11taskMonitorPv+0xd0>)
     1ca:	f002 f90d 	bl	23e8 <vTaskDelay>
    for(x=0; x<10; ++x)
     1ce:	2d00      	cmp	r5, #0
     1d0:	d1be      	bne.n	150 <_Z11taskMonitorPv+0x10>
      myDelayMs(10000); // print every 10 seconds
    }

    // delete ourselves.
    // Have to call this or the system crashes when you reach the end bracket and then get scheduled.
    SERIAL.println("Task Monitor: Deleting");
     1d2:	4910      	ldr	r1, [pc, #64]	; (214 <_Z11taskMonitorPv+0xd4>)
     1d4:	0020      	movs	r0, r4
     1d6:	f000 f96f 	bl	4b8 <_ZN5Print7printlnEPKc>
    vTaskDelete( NULL );
     1da:	0028      	movs	r0, r5
     1dc:	f001 ff8e 	bl	20fc <vTaskDelete>

}
     1e0:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
     1e2:	46c0      	nop			; (mov r8, r8)
     1e4:	20000abc 	.word	0x20000abc
     1e8:	00003d28 	.word	0x00003d28
     1ec:	00003e19 	.word	0x00003e19
     1f0:	00003d3e 	.word	0x00003d3e
     1f4:	00003d5d 	.word	0x00003d5d
     1f8:	20000120 	.word	0x20000120
     1fc:	00003d7c 	.word	0x00003d7c
     200:	20000124 	.word	0x20000124
     204:	00003d87 	.word	0x00003d87
     208:	20000128 	.word	0x20000128
     20c:	00003d92 	.word	0x00003d92
     210:	00002710 	.word	0x00002710
     214:	00003da2 	.word	0x00003da2

00000218 <_ZL7threadBPv>:
{
     218:	b570      	push	{r4, r5, r6, lr}
	SERIAL.println("Thread B: Started");
     21a:	4e0d      	ldr	r6, [pc, #52]	; (250 <_ZL7threadBPv+0x38>)
     21c:	490d      	ldr	r1, [pc, #52]	; (254 <_ZL7threadBPv+0x3c>)
     21e:	0030      	movs	r0, r6
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     220:	24fa      	movs	r4, #250	; 0xfa
	SERIAL.println("Thread B: Started");
     222:	f000 f949 	bl	4b8 <_ZN5Print7printlnEPKc>
		digitalWrite(LED_PIN, LOW);
     226:	250d      	movs	r5, #13
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     228:	00a4      	lsls	r4, r4, #2
		SERIAL.println("B");
     22a:	490b      	ldr	r1, [pc, #44]	; (258 <_ZL7threadBPv+0x40>)
     22c:	0030      	movs	r0, r6
     22e:	f000 f943 	bl	4b8 <_ZN5Print7printlnEPKc>
		digitalWrite(LED_PIN, LOW);
     232:	2100      	movs	r1, #0
     234:	0028      	movs	r0, r5
     236:	f001 fd7d 	bl	1d34 <digitalWrite>
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     23a:	0020      	movs	r0, r4
     23c:	f002 f8d4 	bl	23e8 <vTaskDelay>
		digitalWrite(LED_PIN, HIGH);
     240:	0028      	movs	r0, r5
     242:	2101      	movs	r1, #1
     244:	f001 fd76 	bl	1d34 <digitalWrite>
  vTaskDelay( (ms * 1000) / portTICK_PERIOD_US );  
     248:	0020      	movs	r0, r4
     24a:	f002 f8cd 	bl	23e8 <vTaskDelay>
     24e:	e7ec      	b.n	22a <_ZL7threadBPv+0x12>
     250:	20000abc 	.word	0x20000abc
     254:	00003dcb 	.word	0x00003dcb
     258:	00003e08 	.word	0x00003e08

0000025c <loop>:
//*****************************************************************
// This is now the rtos idle loop
// No rtos blocking functions allowed!
//*****************************************************************
void loop() 
{
     25c:	b510      	push	{r4, lr}
    // Optional commands, can comment/uncomment below
    //SERIAL.print("."); //print out dots in terminal, we only do this when the RTOS is in the idle state
    //vNopDelayMS(100);
	
	// Wait until the Data Register Empty flag is set
	while (!(SERCOM0->USART.INTFLAG.bit.DRE)) 
     25e:	4b05      	ldr	r3, [pc, #20]	; (274 <loop+0x18>)
     260:	7e1a      	ldrb	r2, [r3, #24]
     262:	07d2      	lsls	r2, r2, #31
     264:	d403      	bmi.n	26e <loop+0x12>
	{
		vNopDelayMS(100); 
     266:	2064      	movs	r0, #100	; 0x64
     268:	f001 fdf8 	bl	1e5c <vNopDelayMS>
	while (!(SERCOM0->USART.INTFLAG.bit.DRE)) 
     26c:	e7f7      	b.n	25e <loop+0x2>
	}
	
	// Write the data byte to the DATA register
	SERCOM0->USART.DATA.reg = '.';
     26e:	222e      	movs	r2, #46	; 0x2e
     270:	851a      	strh	r2, [r3, #40]	; 0x28
	
}
     272:	bd10      	pop	{r4, pc}
     274:	42000800 	.word	0x42000800

00000278 <setup>:
  SERIAL.begin(115200);
     278:	21e1      	movs	r1, #225	; 0xe1
{
     27a:	b530      	push	{r4, r5, lr}
  SERIAL.begin(115200);
     27c:	4c28      	ldr	r4, [pc, #160]	; (320 <setup+0xa8>)
{
     27e:	b085      	sub	sp, #20
  SERIAL.begin(115200);
     280:	0249      	lsls	r1, r1, #9
     282:	0020      	movs	r0, r4
     284:	f000 fa74 	bl	770 <_ZN4Uart5beginEm>
  vNopDelayMS(1000); // prevents usb driver crash on startup, do not omit this
     288:	20fa      	movs	r0, #250	; 0xfa
     28a:	0080      	lsls	r0, r0, #2
     28c:	f001 fde6 	bl	1e5c <vNopDelayMS>
  SERIAL.println("");
     290:	4924      	ldr	r1, [pc, #144]	; (324 <setup+0xac>)
     292:	0020      	movs	r0, r4
     294:	f000 f910 	bl	4b8 <_ZN5Print7printlnEPKc>
  SERIAL.println("******************************");
     298:	4d23      	ldr	r5, [pc, #140]	; (328 <setup+0xb0>)
     29a:	0020      	movs	r0, r4
     29c:	0029      	movs	r1, r5
     29e:	f000 f90b 	bl	4b8 <_ZN5Print7printlnEPKc>
  SERIAL.println("        Program start         ");
     2a2:	4922      	ldr	r1, [pc, #136]	; (32c <setup+0xb4>)
     2a4:	0020      	movs	r0, r4
     2a6:	f000 f907 	bl	4b8 <_ZN5Print7printlnEPKc>
  SERIAL.println("******************************");
     2aa:	0029      	movs	r1, r5
     2ac:	0020      	movs	r0, r4
     2ae:	f000 f903 	bl	4b8 <_ZN5Print7printlnEPKc>
  vSetErrorLed(LED_PIN, LED_LIGHTUP_STATE);
     2b2:	2101      	movs	r1, #1
     2b4:	200d      	movs	r0, #13
     2b6:	f001 fdc7 	bl	1e48 <vSetErrorLed>
  pinMode(LED_PIN, OUTPUT);
     2ba:	2101      	movs	r1, #1
     2bc:	200d      	movs	r0, #13
     2be:	f001 fced 	bl	1c9c <pinMode>
  digitalWrite(LED_PIN, LOW);
     2c2:	2100      	movs	r1, #0
     2c4:	200d      	movs	r0, #13
     2c6:	f001 fd35 	bl	1d34 <digitalWrite>
  xTaskCreate(threadA,     "Task A",       256, NULL, tskIDLE_PRIORITY + 3, &Handle_aTask);
     2ca:	4b19      	ldr	r3, [pc, #100]	; (330 <setup+0xb8>)
     2cc:	2580      	movs	r5, #128	; 0x80
     2ce:	2400      	movs	r4, #0
     2d0:	9301      	str	r3, [sp, #4]
     2d2:	2303      	movs	r3, #3
     2d4:	006d      	lsls	r5, r5, #1
     2d6:	9300      	str	r3, [sp, #0]
     2d8:	002a      	movs	r2, r5
     2da:	0023      	movs	r3, r4
     2dc:	9403      	str	r4, [sp, #12]
     2de:	9402      	str	r4, [sp, #8]
     2e0:	4914      	ldr	r1, [pc, #80]	; (334 <setup+0xbc>)
     2e2:	4815      	ldr	r0, [pc, #84]	; (338 <setup+0xc0>)
     2e4:	f001 fe2e 	bl	1f44 <xTaskGenericCreate>
  xTaskCreate(threadB,     "Task B",       256, NULL, tskIDLE_PRIORITY + 2, &Handle_bTask);
     2e8:	4b14      	ldr	r3, [pc, #80]	; (33c <setup+0xc4>)
     2ea:	002a      	movs	r2, r5
     2ec:	9301      	str	r3, [sp, #4]
     2ee:	2302      	movs	r3, #2
     2f0:	9403      	str	r4, [sp, #12]
     2f2:	9300      	str	r3, [sp, #0]
     2f4:	9402      	str	r4, [sp, #8]
     2f6:	0023      	movs	r3, r4
     2f8:	4911      	ldr	r1, [pc, #68]	; (340 <setup+0xc8>)
     2fa:	4812      	ldr	r0, [pc, #72]	; (344 <setup+0xcc>)
     2fc:	f001 fe22 	bl	1f44 <xTaskGenericCreate>
  xTaskCreate(taskMonitor, "Task Monitor", 256, NULL, tskIDLE_PRIORITY + 1, &Handle_monitorTask);
     300:	4b11      	ldr	r3, [pc, #68]	; (348 <setup+0xd0>)
     302:	002a      	movs	r2, r5
     304:	9301      	str	r3, [sp, #4]
     306:	2301      	movs	r3, #1
     308:	4910      	ldr	r1, [pc, #64]	; (34c <setup+0xd4>)
     30a:	9300      	str	r3, [sp, #0]
     30c:	9403      	str	r4, [sp, #12]
     30e:	0023      	movs	r3, r4
     310:	9402      	str	r4, [sp, #8]
     312:	480f      	ldr	r0, [pc, #60]	; (350 <setup+0xd8>)
     314:	f001 fe16 	bl	1f44 <xTaskGenericCreate>
	vTaskStartScheduler();
     318:	f001 ff36 	bl	2188 <vTaskStartScheduler>
}
     31c:	b005      	add	sp, #20
     31e:	bd30      	pop	{r4, r5, pc}
     320:	20000abc 	.word	0x20000abc
     324:	00003e19 	.word	0x00003e19
     328:	00003d3e 	.word	0x00003d3e
     32c:	00003ddd 	.word	0x00003ddd
     330:	20000120 	.word	0x20000120
     334:	00003dfc 	.word	0x00003dfc
     338:	00000115 	.word	0x00000115
     33c:	20000124 	.word	0x20000124
     340:	00003e03 	.word	0x00003e03
     344:	00000219 	.word	0x00000219
     348:	20000128 	.word	0x20000128
     34c:	00003e0a 	.word	0x00003e0a
     350:	00000141 	.word	0x00000141

00000354 <Dummy_Handler>:
extern void pendSVHook(void);
extern int sysTickHook(void);

/* Default empty handler */
void Dummy_Handler(void)
{
     354:	e7fe      	b.n	354 <Dummy_Handler>
	...

00000358 <USB_Handler>:

static void (*usb_isr)(void) = NULL;

void USB_Handler(void)
{
  if (usb_isr)
     358:	4b03      	ldr	r3, [pc, #12]	; (368 <USB_Handler+0x10>)
{
     35a:	b510      	push	{r4, lr}
  if (usb_isr)
     35c:	681b      	ldr	r3, [r3, #0]
     35e:	2b00      	cmp	r3, #0
     360:	d000      	beq.n	364 <USB_Handler+0xc>
    usb_isr();
     362:	4798      	blx	r3
}
     364:	bd10      	pop	{r4, pc}
     366:	46c0      	nop			; (mov r8, r8)
     368:	2000012c 	.word	0x2000012c

0000036c <Reset_Handler>:
{
     36c:	b570      	push	{r4, r5, r6, lr}
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
     36e:	490f      	ldr	r1, [pc, #60]	; (3ac <Reset_Handler+0x40>)
     370:	4c0f      	ldr	r4, [pc, #60]	; (3b0 <Reset_Handler+0x44>)
     372:	42a1      	cmp	r1, r4
     374:	d104      	bne.n	380 <Reset_Handler+0x14>
  SystemInit();
     376:	f000 f949 	bl	60c <SystemInit>
  main();
     37a:	f000 f849 	bl	410 <main>
     37e:	e7fe      	b.n	37e <Reset_Handler+0x12>
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
     380:	4d0c      	ldr	r5, [pc, #48]	; (3b4 <Reset_Handler+0x48>)
     382:	2300      	movs	r3, #0
     384:	428d      	cmp	r5, r1
     386:	d0f6      	beq.n	376 <Reset_Handler+0xa>
     388:	18ca      	adds	r2, r1, r3
     38a:	18e8      	adds	r0, r5, r3
    for (; pDest < &__data_end__; pDest++, pSrc++)
     38c:	42a2      	cmp	r2, r4
     38e:	d305      	bcc.n	39c <Reset_Handler+0x30>
  if ((&__data_start__ != &__data_end__) && (pSrc != pDest)) {
     390:	4290      	cmp	r0, r2
     392:	d0f0      	beq.n	376 <Reset_Handler+0xa>
     394:	4b08      	ldr	r3, [pc, #32]	; (3b8 <Reset_Handler+0x4c>)
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
     396:	4909      	ldr	r1, [pc, #36]	; (3bc <Reset_Handler+0x50>)
      *pDest = 0;
     398:	2200      	movs	r2, #0
     39a:	e004      	b.n	3a6 <Reset_Handler+0x3a>
      *pDest = *pSrc;
     39c:	6800      	ldr	r0, [r0, #0]
     39e:	3304      	adds	r3, #4
     3a0:	6010      	str	r0, [r2, #0]
     3a2:	e7f1      	b.n	388 <Reset_Handler+0x1c>
      *pDest = 0;
     3a4:	c304      	stmia	r3!, {r2}
    for (pDest = &__bss_start__; pDest < &__bss_end__; pDest++)
     3a6:	428b      	cmp	r3, r1
     3a8:	d3fc      	bcc.n	3a4 <Reset_Handler+0x38>
     3aa:	e7e4      	b.n	376 <Reset_Handler+0xa>
     3ac:	20000000 	.word	0x20000000
     3b0:	20000104 	.word	0x20000104
     3b4:	00004358 	.word	0x00004358
     3b8:	20000104 	.word	0x20000104
     3bc:	20003da8 	.word	0x20003da8

000003c0 <SysTick_Handler>:
{
     3c0:	b510      	push	{r4, lr}
  if (sysTickHook())
     3c2:	f002 ff79 	bl	32b8 <sysTickHook>
     3c6:	2800      	cmp	r0, #0
     3c8:	d101      	bne.n	3ce <SysTick_Handler+0xe>
  SysTick_DefaultHandler();
     3ca:	f000 f815 	bl	3f8 <SysTick_DefaultHandler>
}
     3ce:	bd10      	pop	{r4, pc}

000003d0 <USB_SetHandler>:

void USB_SetHandler(void (*new_usb_isr)(void))
{
  usb_isr = new_usb_isr;
     3d0:	4b01      	ldr	r3, [pc, #4]	; (3d8 <USB_SetHandler+0x8>)
     3d2:	6018      	str	r0, [r3, #0]
}
     3d4:	4770      	bx	lr
     3d6:	46c0      	nop			; (mov r8, r8)
     3d8:	2000012c 	.word	0x2000012c

000003dc <delay>:
  // this is an optimization to turn a runtime division into two compile-time divisions and
  // a runtime multiplication and shift, saving a few cycles
}

void delay( unsigned long ms )
{
     3dc:	b570      	push	{r4, r5, r6, lr}
     3de:	1e04      	subs	r4, r0, #0
  if ( ms == 0 )
     3e0:	d007      	beq.n	3f2 <delay+0x16>
  {
    return ;
  }

  uint32_t start = _ulTickCount ;
     3e2:	4d04      	ldr	r5, [pc, #16]	; (3f4 <delay+0x18>)
     3e4:	682e      	ldr	r6, [r5, #0]

  do
  {
    yield() ;
     3e6:	f000 f811 	bl	40c <yield>
  } while ( _ulTickCount - start < ms ) ;
     3ea:	682b      	ldr	r3, [r5, #0]
     3ec:	1b9b      	subs	r3, r3, r6
     3ee:	429c      	cmp	r4, r3
     3f0:	d8f9      	bhi.n	3e6 <delay+0xa>
}
     3f2:	bd70      	pop	{r4, r5, r6, pc}
     3f4:	20000130 	.word	0x20000130

000003f8 <SysTick_DefaultHandler>:

#include "Reset.h" // for tickReset()

void SysTick_DefaultHandler(void)
{
     3f8:	b510      	push	{r4, lr}
  // Increment tick count each ms
  _ulTickCount++;
     3fa:	4a03      	ldr	r2, [pc, #12]	; (408 <SysTick_DefaultHandler+0x10>)
     3fc:	6813      	ldr	r3, [r2, #0]
     3fe:	3301      	adds	r3, #1
     400:	6013      	str	r3, [r2, #0]
  tickReset();
     402:	f000 f8c7 	bl	594 <tickReset>
}
     406:	bd10      	pop	{r4, pc}
     408:	20000130 	.word	0x20000130

0000040c <yield>:
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
	// Empty
}
     40c:	4770      	bx	lr

0000040e <_Z11initVariantv>:
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
     40e:	4770      	bx	lr

00000410 <main>:

/*
 * \brief Main entry point of Arduino application
 */
int main( void )
{
     410:	b510      	push	{r4, lr}
  init();
     412:	f001 fb99 	bl	1b48 <init>

  __libc_init_array();
     416:	f003 fb5f 	bl	3ad8 <__libc_init_array>

  initVariant();
     41a:	f7ff fff8 	bl	40e <_Z11initVariantv>

  delay(1);
     41e:	2001      	movs	r0, #1
     420:	f7ff ffdc 	bl	3dc <delay>
#if defined(USBCON)
  USBDevice.init();
     424:	4c08      	ldr	r4, [pc, #32]	; (448 <main+0x38>)
     426:	0020      	movs	r0, r4
     428:	f000 fe1c 	bl	1064 <_ZN14USBDeviceClass4initEv>
  USBDevice.attach();
     42c:	0020      	movs	r0, r4
     42e:	f000 fe91 	bl	1154 <_ZN14USBDeviceClass6attachEv>
#endif

  setup();
     432:	f7ff ff21 	bl	278 <setup>

  for (;;)
  {
    loop();
     436:	f7ff ff11 	bl	25c <loop>
    if (serialEventRun) serialEventRun();
     43a:	4b04      	ldr	r3, [pc, #16]	; (44c <main+0x3c>)
     43c:	2b00      	cmp	r3, #0
     43e:	d0fa      	beq.n	436 <main+0x26>
     440:	e000      	b.n	444 <main+0x34>
     442:	bf00      	nop
     444:	e7f7      	b.n	436 <main+0x26>
     446:	46c0      	nop			; (mov r8, r8)
     448:	20000134 	.word	0x20000134
     44c:	00000000 	.word	0x00000000

00000450 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     450:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     452:	0006      	movs	r6, r0
     454:	000d      	movs	r5, r1
     456:	000c      	movs	r4, r1
     458:	188b      	adds	r3, r1, r2
     45a:	9301      	str	r3, [sp, #4]
  size_t n = 0;
  while (size--) {
     45c:	9b01      	ldr	r3, [sp, #4]
     45e:	1b67      	subs	r7, r4, r5
     460:	429c      	cmp	r4, r3
     462:	d007      	beq.n	474 <_ZN5Print5writeEPKhj+0x24>
    if (write(*buffer++)) n++;
     464:	6833      	ldr	r3, [r6, #0]
     466:	7821      	ldrb	r1, [r4, #0]
     468:	681b      	ldr	r3, [r3, #0]
     46a:	0030      	movs	r0, r6
     46c:	4798      	blx	r3
     46e:	3401      	adds	r4, #1
     470:	2800      	cmp	r0, #0
     472:	d1f3      	bne.n	45c <_ZN5Print5writeEPKhj+0xc>
    else break;
  }
  return n;
}
     474:	0038      	movs	r0, r7
     476:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

00000478 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
     478:	b570      	push	{r4, r5, r6, lr}
     47a:	0005      	movs	r5, r0
     47c:	000c      	movs	r4, r1
      if (str == NULL) return 0;
     47e:	1e08      	subs	r0, r1, #0
     480:	d007      	beq.n	492 <_ZN5Print5writeEPKc+0x1a>
      return write((const uint8_t *)str, strlen(str));
     482:	f003 fc2d 	bl	3ce0 <strlen>
     486:	682b      	ldr	r3, [r5, #0]
     488:	0002      	movs	r2, r0
     48a:	685b      	ldr	r3, [r3, #4]
     48c:	0021      	movs	r1, r4
     48e:	0028      	movs	r0, r5
     490:	4798      	blx	r3
    }
     492:	bd70      	pop	{r4, r5, r6, pc}

00000494 <_ZN5Print5printEPKc>:
{
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
     494:	b510      	push	{r4, lr}
  return write(str);
     496:	f7ff ffef 	bl	478 <_ZN5Print5writeEPKc>
}
     49a:	bd10      	pop	{r4, pc}

0000049c <_ZN5Print5printEc>:

size_t Print::print(char c)
{
     49c:	b510      	push	{r4, lr}
  return write(c);
     49e:	6803      	ldr	r3, [r0, #0]
     4a0:	681b      	ldr	r3, [r3, #0]
     4a2:	4798      	blx	r3
}
     4a4:	bd10      	pop	{r4, pc}
	...

000004a8 <_ZN5Print7printlnEv>:
{
  return x.printTo(*this);
}

size_t Print::println(void)
{
     4a8:	b510      	push	{r4, lr}
  return write("\r\n");
     4aa:	4902      	ldr	r1, [pc, #8]	; (4b4 <_ZN5Print7printlnEv+0xc>)
     4ac:	f7ff ffe4 	bl	478 <_ZN5Print5writeEPKc>
}
     4b0:	bd10      	pop	{r4, pc}
     4b2:	46c0      	nop			; (mov r8, r8)
     4b4:	00003e17 	.word	0x00003e17

000004b8 <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
     4b8:	b570      	push	{r4, r5, r6, lr}
     4ba:	0004      	movs	r4, r0
  return write(str);
     4bc:	f7ff ffdc 	bl	478 <_ZN5Print5writeEPKc>
     4c0:	0005      	movs	r5, r0
  size_t n = print(c);
  n += println();
     4c2:	0020      	movs	r0, r4
     4c4:	f7ff fff0 	bl	4a8 <_ZN5Print7printlnEv>
     4c8:	1940      	adds	r0, r0, r5
  return n;
}
     4ca:	bd70      	pop	{r4, r5, r6, pc}

000004cc <_ZN5Print11printNumberEmh>:
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
     4cc:	b5f0      	push	{r4, r5, r6, r7, lr}
     4ce:	0016      	movs	r6, r2
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     4d0:	2200      	movs	r2, #0
{
     4d2:	b08d      	sub	sp, #52	; 0x34
  *str = '\0';
     4d4:	ab02      	add	r3, sp, #8
     4d6:	3305      	adds	r3, #5
{
     4d8:	9001      	str	r0, [sp, #4]
     4da:	000d      	movs	r5, r1
  *str = '\0';
     4dc:	77da      	strb	r2, [r3, #31]

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     4de:	2e01      	cmp	r6, #1
     4e0:	dc00      	bgt.n	4e4 <_ZN5Print11printNumberEmh+0x18>
     4e2:	260a      	movs	r6, #10
     4e4:	ac0b      	add	r4, sp, #44	; 0x2c

  do {
    char c = n % base;
     4e6:	0028      	movs	r0, r5
     4e8:	0031      	movs	r1, r6
     4ea:	f003 faef 	bl	3acc <__aeabi_uidivmod>
     4ee:	000f      	movs	r7, r1
     4f0:	b2cb      	uxtb	r3, r1
    n /= base;
     4f2:	0028      	movs	r0, r5
     4f4:	0031      	movs	r1, r6
    char c = n % base;
     4f6:	9300      	str	r3, [sp, #0]
    n /= base;
     4f8:	f003 fa62 	bl	39c0 <__udivsi3>

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     4fc:	b2fb      	uxtb	r3, r7
     4fe:	3337      	adds	r3, #55	; 0x37
    n /= base;
     500:	0005      	movs	r5, r0
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     502:	3c01      	subs	r4, #1
     504:	b2db      	uxtb	r3, r3
     506:	2f09      	cmp	r7, #9
     508:	d802      	bhi.n	510 <_ZN5Print11printNumberEmh+0x44>
     50a:	9b00      	ldr	r3, [sp, #0]
     50c:	3330      	adds	r3, #48	; 0x30
     50e:	b2db      	uxtb	r3, r3
     510:	7023      	strb	r3, [r4, #0]
  } while(n);
     512:	2d00      	cmp	r5, #0
     514:	d1e7      	bne.n	4e6 <_ZN5Print11printNumberEmh+0x1a>

  return write(str);
     516:	0021      	movs	r1, r4
     518:	9801      	ldr	r0, [sp, #4]
     51a:	f7ff ffad 	bl	478 <_ZN5Print5writeEPKc>
}
     51e:	b00d      	add	sp, #52	; 0x34
     520:	bdf0      	pop	{r4, r5, r6, r7, pc}

00000522 <_ZN5Print5printEli>:
{
     522:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     524:	0006      	movs	r6, r0
     526:	000c      	movs	r4, r1
     528:	1e15      	subs	r5, r2, #0
  if (base == 0) {
     52a:	d104      	bne.n	536 <_ZN5Print5printEli+0x14>
    return write(n);
     52c:	6803      	ldr	r3, [r0, #0]
     52e:	b2c9      	uxtb	r1, r1
     530:	681b      	ldr	r3, [r3, #0]
     532:	4798      	blx	r3
}
     534:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return printNumber(n, base);
     536:	b2d2      	uxtb	r2, r2
  } else if (base == 10) {
     538:	2d0a      	cmp	r5, #10
     53a:	d10d      	bne.n	558 <_ZN5Print5printEli+0x36>
    return printNumber(n, 10);
     53c:	002a      	movs	r2, r5
    if (n < 0) {
     53e:	2900      	cmp	r1, #0
     540:	da0a      	bge.n	558 <_ZN5Print5printEli+0x36>
      int t = print('-');
     542:	212d      	movs	r1, #45	; 0x2d
     544:	f7ff ffaa 	bl	49c <_ZN5Print5printEc>
      n = -n;
     548:	4261      	negs	r1, r4
      int t = print('-');
     54a:	0007      	movs	r7, r0
      return printNumber(n, 10) + t;
     54c:	002a      	movs	r2, r5
     54e:	0030      	movs	r0, r6
     550:	f7ff ffbc 	bl	4cc <_ZN5Print11printNumberEmh>
     554:	1838      	adds	r0, r7, r0
     556:	e7ed      	b.n	534 <_ZN5Print5printEli+0x12>
    return printNumber(n, base);
     558:	0021      	movs	r1, r4
     55a:	0030      	movs	r0, r6
     55c:	f7ff ffb6 	bl	4cc <_ZN5Print11printNumberEmh>
     560:	e7e8      	b.n	534 <_ZN5Print5printEli+0x12>

00000562 <_ZN5Print7printlnEii>:
{
     562:	b570      	push	{r4, r5, r6, lr}
     564:	0004      	movs	r4, r0
  return print((long) n, base);
     566:	f7ff ffdc 	bl	522 <_ZN5Print5printEli>
     56a:	0005      	movs	r5, r0
  n += println();
     56c:	0020      	movs	r0, r4
     56e:	f7ff ff9b 	bl	4a8 <_ZN5Print7printlnEv>
     572:	1940      	adds	r0, r0, r5
}
     574:	bd70      	pop	{r4, r5, r6, pc}
	...

00000578 <initiateReset>:
}

static int ticks = -1;

void initiateReset(int _ticks) {
	ticks = _ticks;
     578:	4b01      	ldr	r3, [pc, #4]	; (580 <initiateReset+0x8>)
     57a:	6018      	str	r0, [r3, #0]
}
     57c:	4770      	bx	lr
     57e:	46c0      	nop			; (mov r8, r8)
     580:	20000000 	.word	0x20000000

00000584 <cancelReset>:

void cancelReset() {
	ticks = -1;
     584:	2201      	movs	r2, #1
     586:	4b02      	ldr	r3, [pc, #8]	; (590 <cancelReset+0xc>)
     588:	4252      	negs	r2, r2
     58a:	601a      	str	r2, [r3, #0]
}
     58c:	4770      	bx	lr
     58e:	46c0      	nop			; (mov r8, r8)
     590:	20000000 	.word	0x20000000

00000594 <tickReset>:

void tickReset() {
	if (ticks == -1)
     594:	4a16      	ldr	r2, [pc, #88]	; (5f0 <tickReset+0x5c>)
void tickReset() {
     596:	b510      	push	{r4, lr}
	if (ticks == -1)
     598:	6813      	ldr	r3, [r2, #0]
     59a:	1c59      	adds	r1, r3, #1
     59c:	d027      	beq.n	5ee <tickReset+0x5a>
		return;
	ticks--;
     59e:	3b01      	subs	r3, #1
     5a0:	6013      	str	r3, [r2, #0]
	if (ticks == 0)
     5a2:	2b00      	cmp	r3, #0
     5a4:	d123      	bne.n	5ee <tickReset+0x5a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
     5a6:	b672      	cpsid	i
	if (APP_START < (0x200 + 4)) {
     5a8:	4b12      	ldr	r3, [pc, #72]	; (5f4 <tickReset+0x60>)
     5aa:	4a13      	ldr	r2, [pc, #76]	; (5f8 <tickReset+0x64>)
     5ac:	3304      	adds	r3, #4
     5ae:	4293      	cmp	r3, r2
     5b0:	d808      	bhi.n	5c4 <tickReset+0x30>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     5b2:	f3bf 8f4f 	dsb	sy
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
     5b6:	4a11      	ldr	r2, [pc, #68]	; (5fc <tickReset+0x68>)
     5b8:	4b11      	ldr	r3, [pc, #68]	; (600 <tickReset+0x6c>)
     5ba:	60da      	str	r2, [r3, #12]
     5bc:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
     5c0:	46c0      	nop			; (mov r8, r8)
     5c2:	e7fd      	b.n	5c0 <tickReset+0x2c>
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
     5c4:	4a0f      	ldr	r2, [pc, #60]	; (604 <tickReset+0x70>)
	while (!nvmReady())
     5c6:	2101      	movs	r1, #1
     5c8:	0010      	movs	r0, r2
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
     5ca:	7d14      	ldrb	r4, [r2, #20]
	while (!nvmReady())
     5cc:	420c      	tst	r4, r1
     5ce:	d0fc      	beq.n	5ca <tickReset+0x36>
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
     5d0:	2120      	movs	r1, #32
     5d2:	8b14      	ldrh	r4, [r2, #24]
     5d4:	31ff      	adds	r1, #255	; 0xff
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
     5d6:	089b      	lsrs	r3, r3, #2
     5d8:	005b      	lsls	r3, r3, #1
	NVMCTRL->STATUS.reg |= NVMCTRL_STATUS_MASK;
     5da:	4321      	orrs	r1, r4
     5dc:	8311      	strh	r1, [r2, #24]
	NVMCTRL->ADDR.reg  = (uintptr_t)&NVM_MEMORY[APP_START / 4];
     5de:	61d3      	str	r3, [r2, #28]
	NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMD_ER | NVMCTRL_CTRLA_CMDEX_KEY;
     5e0:	4b09      	ldr	r3, [pc, #36]	; (608 <tickReset+0x74>)
     5e2:	8013      	strh	r3, [r2, #0]
	while (!nvmReady())
     5e4:	2301      	movs	r3, #1
        return NVMCTRL->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
     5e6:	7d02      	ldrb	r2, [r0, #20]
	while (!nvmReady())
     5e8:	421a      	tst	r2, r3
     5ea:	d0fc      	beq.n	5e6 <tickReset+0x52>
     5ec:	e7e1      	b.n	5b2 <tickReset+0x1e>
		banzai();
}
     5ee:	bd10      	pop	{r4, pc}
     5f0:	20000000 	.word	0x20000000
     5f4:	00000000 	.word	0x00000000
     5f8:	00000203 	.word	0x00000203
     5fc:	05fa0004 	.word	0x05fa0004
     600:	e000ed00 	.word	0xe000ed00
     604:	41004000 	.word	0x41004000
     608:	ffffa502 	.word	0xffffa502

0000060c <SystemInit>:
#define GENERIC_CLOCK_MULTIPLEXER_DFLL48M (0u)

void SystemInit( void )
{
  /* Set 1 Flash Wait State for 48MHz, cf tables 20.9 and 35.27 in SAMD21 Datasheet */
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
     60c:	221e      	movs	r2, #30
{
     60e:	b570      	push	{r4, r5, r6, lr}
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
     610:	4846      	ldr	r0, [pc, #280]	; (72c <SystemInit+0x120>)

  /* Turn on the digital interface clock */
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
     612:	4947      	ldr	r1, [pc, #284]	; (730 <SystemInit+0x124>)
  NVMCTRL->CTRLB.bit.RWS = NVMCTRL_CTRLB_RWS_HALF_Val ;
     614:	6843      	ldr	r3, [r0, #4]
     616:	4393      	bics	r3, r2
     618:	3a1c      	subs	r2, #28
     61a:	4313      	orrs	r3, r2
     61c:	6043      	str	r3, [r0, #4]
  PM->APBAMASK.reg |= PM_APBAMASK_GCLK ;
     61e:	2308      	movs	r3, #8
     620:	698c      	ldr	r4, [r1, #24]
     622:	4323      	orrs	r3, r4
     624:	618b      	str	r3, [r1, #24]
#else // has crystal

  /* ----------------------------------------------------------------------------------------------
   * 1) Enable XOSC32K clock (External on-board 32.768Hz oscillator)
   */
  SYSCTRL->XOSC32K.reg = SYSCTRL_XOSC32K_STARTUP( 0x6u ) | /* cf table 15.10 of product datasheet in chapter 15.8.6 */
     626:	4c43      	ldr	r4, [pc, #268]	; (734 <SystemInit+0x128>)
     628:	4b43      	ldr	r3, [pc, #268]	; (738 <SystemInit+0x12c>)
     62a:	829c      	strh	r4, [r3, #20]
                         SYSCTRL_XOSC32K_XTALEN | SYSCTRL_XOSC32K_EN32K ;
  SYSCTRL->XOSC32K.bit.ENABLE = 1 ; /* separate call, as described in chapter 15.6.3 */
     62c:	8a9c      	ldrh	r4, [r3, #20]
     62e:	4314      	orrs	r4, r2
     630:	829c      	strh	r4, [r3, #20]

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_XOSC32KRDY) == 0 )
     632:	68dc      	ldr	r4, [r3, #12]
     634:	4214      	tst	r4, r2
     636:	d0fc      	beq.n	632 <SystemInit+0x26>

  /* Software reset the module to ensure it is re-initialized correctly */
  /* Note: Due to synchronization, there is a delay from writing CTRL.SWRST until the reset is complete.
   * CTRL.SWRST and STATUS.SYNCBUSY will both be cleared when the reset is complete, as described in chapter 13.8.1
   */
  GCLK->CTRL.reg = GCLK_CTRL_SWRST ;
     638:	2401      	movs	r4, #1
     63a:	4a40      	ldr	r2, [pc, #256]	; (73c <SystemInit+0x130>)
     63c:	7014      	strb	r4, [r2, #0]

  while ( (GCLK->CTRL.reg & GCLK_CTRL_SWRST) && (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY) )
     63e:	7815      	ldrb	r5, [r2, #0]
     640:	4225      	tst	r5, r4
     642:	d003      	beq.n	64c <SystemInit+0x40>
     644:	7855      	ldrb	r5, [r2, #1]
     646:	b26d      	sxtb	r5, r5
     648:	2d00      	cmp	r5, #0
     64a:	dbf8      	blt.n	63e <SystemInit+0x32>
  }

  /* ----------------------------------------------------------------------------------------------
   * 2) Put XOSC32K as source of Generic Clock Generator 1
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_XOSC32K ) ; // Generic Clock Generator 1
     64c:	2401      	movs	r4, #1
     64e:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     650:	7854      	ldrb	r4, [r2, #1]
     652:	b264      	sxtb	r4, r4
     654:	2c00      	cmp	r4, #0
     656:	dbfb      	blt.n	650 <SystemInit+0x44>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 1 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC32K ) | // Generic Clock Generator 1
     658:	4c39      	ldr	r4, [pc, #228]	; (740 <SystemInit+0x134>)
     65a:	6054      	str	r4, [r2, #4]
                      GCLK_GENCTRL_SRC_XOSC32K | // Selected source is External 32KHz Oscillator
#endif
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     65c:	7854      	ldrb	r4, [r2, #1]
     65e:	b264      	sxtb	r4, r4
     660:	2c00      	cmp	r4, #0
     662:	dbfb      	blt.n	65c <SystemInit+0x50>
  }

  /* ----------------------------------------------------------------------------------------------
   * 3) Put Generic Clock Generator 1 as source for Generic Clock Multiplexer 0 (DFLL48M reference)
   */
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GENERIC_CLOCK_MULTIPLEXER_DFLL48M ) | // Generic Clock Multiplexer 0
     664:	2482      	movs	r4, #130	; 0x82
     666:	01e4      	lsls	r4, r4, #7
     668:	8054      	strh	r4, [r2, #2]
                      GCLK_CLKCTRL_GEN_GCLK1 | // Generic Clock Generator 1 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     66a:	7854      	ldrb	r4, [r2, #1]
     66c:	b264      	sxtb	r4, r4
     66e:	2c00      	cmp	r4, #0
     670:	dbfb      	blt.n	66a <SystemInit+0x5e>
   */

  /* DFLL Configuration in Closed Loop mode, cf product datasheet chapter 15.6.7.1 - Closed-Loop Operation */

  /* Remove the OnDemand mode, Bug http://avr32.icgroup.norway.atmel.com/bugzilla/show_bug.cgi?id=9905 */
  SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
     672:	2402      	movs	r4, #2
     674:	849c      	strh	r4, [r3, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
     676:	340e      	adds	r4, #14
     678:	68dd      	ldr	r5, [r3, #12]
     67a:	4225      	tst	r5, r4
     67c:	d0fc      	beq.n	678 <SystemInit+0x6c>
  {
    /* Wait for synchronization */
  }

  SYSCTRL->DFLLMUL.reg = SYSCTRL_DFLLMUL_CSTEP( 31 ) | // Coarse step is 31, half of the max value
     67e:	4c31      	ldr	r4, [pc, #196]	; (744 <SystemInit+0x138>)
     680:	62dc      	str	r4, [r3, #44]	; 0x2c
                         SYSCTRL_DFLLMUL_FSTEP( 511 ) | // Fine step is 511, half of the max value
                         SYSCTRL_DFLLMUL_MUL( (VARIANT_MCK + VARIANT_MAINOSC/2) / VARIANT_MAINOSC ) ; // External 32KHz is the reference

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
     682:	2410      	movs	r4, #16
     684:	68dd      	ldr	r5, [r3, #12]
     686:	4225      	tst	r5, r4
     688:	d0fc      	beq.n	684 <SystemInit+0x78>
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;

#else   // has crystal

  /* Write full configuration to DFLL control register */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_MODE | /* Enable the closed loop mode */
     68a:	8c9d      	ldrh	r5, [r3, #36]	; 0x24
     68c:	4c2e      	ldr	r4, [pc, #184]	; (748 <SystemInit+0x13c>)
     68e:	432c      	orrs	r4, r5
     690:	849c      	strh	r4, [r3, #36]	; 0x24
                           SYSCTRL_DFLLCTRL_WAITLOCK |
                           SYSCTRL_DFLLCTRL_QLDIS ; /* Disable Quick lock */

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
     692:	2410      	movs	r4, #16
     694:	68dd      	ldr	r5, [r3, #12]
     696:	4225      	tst	r5, r4
     698:	d0fc      	beq.n	694 <SystemInit+0x88>
  {
    /* Wait for synchronization */
  }

  /* Enable the DFLL */
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;
     69a:	2402      	movs	r4, #2
     69c:	8c9d      	ldrh	r5, [r3, #36]	; 0x24

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
     69e:	2680      	movs	r6, #128	; 0x80
  SYSCTRL->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ENABLE ;
     6a0:	432c      	orrs	r4, r5
     6a2:	849c      	strh	r4, [r3, #36]	; 0x24
          (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKF) == 0 )
     6a4:	2440      	movs	r4, #64	; 0x40
  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
     6a6:	68dd      	ldr	r5, [r3, #12]
     6a8:	4235      	tst	r5, r6
     6aa:	d0fc      	beq.n	6a6 <SystemInit+0x9a>
          (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKF) == 0 )
     6ac:	68dd      	ldr	r5, [r3, #12]
  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLLCKC) == 0 ||
     6ae:	4225      	tst	r5, r4
     6b0:	d0f9      	beq.n	6a6 <SystemInit+0x9a>
    /* Wait for locks flags */
  }

#endif

  while ( (SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) == 0 )
     6b2:	2410      	movs	r4, #16
     6b4:	68dd      	ldr	r5, [r3, #12]
     6b6:	4225      	tst	r5, r4
     6b8:	d0fc      	beq.n	6b4 <SystemInit+0xa8>
  }

  /* ----------------------------------------------------------------------------------------------
   * 5) Switch Generic Clock Generator 0 to DFLL48M. CPU will run at 48MHz.
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_MAIN ) ; // Generic Clock Generator 0
     6ba:	2400      	movs	r4, #0
     6bc:	6094      	str	r4, [r2, #8]

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     6be:	7854      	ldrb	r4, [r2, #1]
     6c0:	b264      	sxtb	r4, r4
     6c2:	2c00      	cmp	r4, #0
     6c4:	dbfb      	blt.n	6be <SystemInit+0xb2>
  {
    /* Wait for synchronization */
  }

  /* Write Generic Clock Generator 0 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_MAIN ) | // Generic Clock Generator 0
     6c6:	4c21      	ldr	r4, [pc, #132]	; (74c <SystemInit+0x140>)
     6c8:	6054      	str	r4, [r2, #4]
                      GCLK_GENCTRL_SRC_DFLL48M | // Selected source is DFLL 48MHz
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_IDC | // Set 50/50 duty cycle
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     6ca:	7854      	ldrb	r4, [r2, #1]
     6cc:	b264      	sxtb	r4, r4
     6ce:	2c00      	cmp	r4, #0
     6d0:	dbfb      	blt.n	6ca <SystemInit+0xbe>
  }

  /* ----------------------------------------------------------------------------------------------
   * 6) Modify PRESCaler value of OSC8M to have 8MHz
   */
  SYSCTRL->OSC8M.bit.PRESC = SYSCTRL_OSC8M_PRESC_0_Val ;  //CMSIS 4.5 changed the prescaler defines
     6d2:	6a1c      	ldr	r4, [r3, #32]
     6d4:	4d1e      	ldr	r5, [pc, #120]	; (750 <SystemInit+0x144>)
     6d6:	402c      	ands	r4, r5
  SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;
     6d8:	2580      	movs	r5, #128	; 0x80
  SYSCTRL->OSC8M.bit.PRESC = SYSCTRL_OSC8M_PRESC_0_Val ;  //CMSIS 4.5 changed the prescaler defines
     6da:	621c      	str	r4, [r3, #32]
  SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;
     6dc:	6a1c      	ldr	r4, [r3, #32]
     6de:	43ac      	bics	r4, r5
     6e0:	621c      	str	r4, [r3, #32]

  /* ----------------------------------------------------------------------------------------------
   * 7) Put OSC8M as source for Generic Clock Generator 3
   */
  GCLK->GENDIV.reg = GCLK_GENDIV_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) ; // Generic Clock Generator 3
     6e2:	2303      	movs	r3, #3
     6e4:	6093      	str	r3, [r2, #8]

  /* Write Generic Clock Generator 3 configuration */
  GCLK->GENCTRL.reg = GCLK_GENCTRL_ID( GENERIC_CLOCK_GENERATOR_OSC8M ) | // Generic Clock Generator 3
     6e6:	4b1b      	ldr	r3, [pc, #108]	; (754 <SystemInit+0x148>)
     6e8:	6053      	str	r3, [r2, #4]
                      GCLK_GENCTRL_SRC_OSC8M | // Selected source is RC OSC 8MHz (already enabled at reset)
//                      GCLK_GENCTRL_OE | // Output clock to a pin for tests
                      GCLK_GENCTRL_GENEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
     6ea:	7853      	ldrb	r3, [r2, #1]
     6ec:	b25b      	sxtb	r3, r3
     6ee:	2b00      	cmp	r3, #0
     6f0:	dbfb      	blt.n	6ea <SystemInit+0xde>

  /*
   * Now that all system clocks are configured, we can set CPU and APBx BUS clocks.
   * There values are normally the one present after Reset.
   */
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
     6f2:	2300      	movs	r3, #0

  // ADC Linearity bits 4:0
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;

  // ADC Linearity bits 7:5
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
     6f4:	24ff      	movs	r4, #255	; 0xff
  PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
     6f6:	720b      	strb	r3, [r1, #8]
  SystemCoreClock=VARIANT_MCK ;
     6f8:	4a17      	ldr	r2, [pc, #92]	; (758 <SystemInit+0x14c>)
  PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
     6fa:	724b      	strb	r3, [r1, #9]
  PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
     6fc:	728b      	strb	r3, [r1, #10]
  PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
     6fe:	72cb      	strb	r3, [r1, #11]
  SystemCoreClock=VARIANT_MCK ;
     700:	4b16      	ldr	r3, [pc, #88]	; (75c <SystemInit+0x150>)
     702:	601a      	str	r2, [r3, #0]
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
     704:	4b16      	ldr	r3, [pc, #88]	; (760 <SystemInit+0x154>)
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
     706:	4a17      	ldr	r2, [pc, #92]	; (764 <SystemInit+0x158>)
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
     708:	681b      	ldr	r3, [r3, #0]
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
     70a:	6811      	ldr	r1, [r2, #0]
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
     70c:	069a      	lsls	r2, r3, #26
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
     70e:	015b      	lsls	r3, r3, #5
  uint32_t linearity = (*((uint32_t *) ADC_FUSES_LINEARITY_0_ADDR) & ADC_FUSES_LINEARITY_0_Msk) >> ADC_FUSES_LINEARITY_0_Pos;
     710:	0ec9      	lsrs	r1, r1, #27
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
     712:	4023      	ands	r3, r4
  uint32_t bias = (*((uint32_t *) ADC_FUSES_BIASCAL_ADDR) & ADC_FUSES_BIASCAL_Msk) >> ADC_FUSES_BIASCAL_Pos;
     714:	0f52      	lsrs	r2, r2, #29

  ADC->CALIB.reg = ADC_CALIB_BIAS_CAL(bias) | ADC_CALIB_LINEARITY_CAL(linearity);
     716:	0212      	lsls	r2, r2, #8
  linearity |= ((*((uint32_t *) ADC_FUSES_LINEARITY_1_ADDR) & ADC_FUSES_LINEARITY_1_Msk) >> ADC_FUSES_LINEARITY_1_Pos) << 5;
     718:	430b      	orrs	r3, r1
  ADC->CALIB.reg = ADC_CALIB_BIAS_CAL(bias) | ADC_CALIB_LINEARITY_CAL(linearity);
     71a:	4313      	orrs	r3, r2
     71c:	4a12      	ldr	r2, [pc, #72]	; (768 <SystemInit+0x15c>)
     71e:	8513      	strh	r3, [r2, #40]	; 0x28

  /*
   * 9) Disable automatic NVM write operations
   */
  NVMCTRL->CTRLB.bit.MANW = 1;
     720:	2380      	movs	r3, #128	; 0x80
     722:	6842      	ldr	r2, [r0, #4]
     724:	4313      	orrs	r3, r2
     726:	6043      	str	r3, [r0, #4]
}
     728:	bd70      	pop	{r4, r5, r6, pc}
     72a:	46c0      	nop			; (mov r8, r8)
     72c:	41004000 	.word	0x41004000
     730:	40000400 	.word	0x40000400
     734:	0000060c 	.word	0x0000060c
     738:	40000800 	.word	0x40000800
     73c:	40000c00 	.word	0x40000c00
     740:	00010501 	.word	0x00010501
     744:	7dff05b9 	.word	0x7dff05b9
     748:	00000a04 	.word	0x00000a04
     74c:	00030700 	.word	0x00030700
     750:	fffffcff 	.word	0xfffffcff
     754:	00010603 	.word	0x00010603
     758:	02dc6c00 	.word	0x02dc6c00
     75c:	2000002c 	.word	0x2000002c
     760:	00806024 	.word	0x00806024
     764:	00806020 	.word	0x00806020
     768:	42004000 	.word	0x42004000

0000076c <_ZN4UartcvbEv>:
    size_t write(const uint8_t data);
    using Print::write; // pull in write(str) and write(buf, size) from Print

    void IrqHandler();

    operator bool() { return true; }
     76c:	2001      	movs	r0, #1
     76e:	4770      	bx	lr

00000770 <_ZN4Uart5beginEm>:
  uc_pinRTS = _pinRTS;
  uc_pinCTS = _pinCTS;
}

void Uart::begin(unsigned long baudrate)
{
     770:	b510      	push	{r4, lr}
  begin(baudrate, SERIAL_8N1);
     772:	6803      	ldr	r3, [r0, #0]
     774:	4a01      	ldr	r2, [pc, #4]	; (77c <_ZN4Uart5beginEm+0xc>)
     776:	6a1b      	ldr	r3, [r3, #32]
     778:	4798      	blx	r3
}
     77a:	bd10      	pop	{r4, pc}
     77c:	00000413 	.word	0x00000413

00000780 <_ZN4Uart4peekEv>:
}

template <int N>
int RingBufferN<N>::peek()
{
  if(_iTail == _iHead)
     780:	0003      	movs	r3, r0
     782:	33fc      	adds	r3, #252	; 0xfc
     784:	69d9      	ldr	r1, [r3, #28]
     786:	699a      	ldr	r2, [r3, #24]
     788:	4291      	cmp	r1, r2
     78a:	d003      	beq.n	794 <_ZN4Uart4peekEv+0x14>
    return -1;

  return _aucBuffer[_iTail];
     78c:	69db      	ldr	r3, [r3, #28]
     78e:	18c0      	adds	r0, r0, r3
     790:	7d00      	ldrb	r0, [r0, #20]
}

int Uart::peek()
{
  return rxBuffer.peek();
}
     792:	4770      	bx	lr
    return -1;
     794:	2001      	movs	r0, #1
     796:	4240      	negs	r0, r0
  return rxBuffer.peek();
     798:	e7fb      	b.n	792 <_ZN4Uart4peekEv+0x12>

0000079a <_ZN4Uart3endEv>:
{
     79a:	b510      	push	{r4, lr}
     79c:	0004      	movs	r4, r0
  sercom->resetUART();
     79e:	6900      	ldr	r0, [r0, #16]
     7a0:	f002 fa4e 	bl	2c40 <_ZN6SERCOM9resetUARTEv>
  _iHead = 0;
     7a4:	0022      	movs	r2, r4
     7a6:	2300      	movs	r3, #0
     7a8:	32fc      	adds	r2, #252	; 0xfc
     7aa:	6193      	str	r3, [r2, #24]
  _iTail = 0;
     7ac:	61d3      	str	r3, [r2, #28]
  _iHead = 0;
     7ae:	2286      	movs	r2, #134	; 0x86
     7b0:	0092      	lsls	r2, r2, #2
     7b2:	18a4      	adds	r4, r4, r2
     7b4:	6063      	str	r3, [r4, #4]
  _iTail = 0;
     7b6:	60a3      	str	r3, [r4, #8]
}
     7b8:	bd10      	pop	{r4, pc}

000007ba <_ZN4Uart16extractNbStopBitEt>:
  return 1;
}

SercomNumberStopBit Uart::extractNbStopBit(uint16_t config)
{
  switch(config & HARDSER_STOP_BIT_MASK)
     7ba:	20f0      	movs	r0, #240	; 0xf0
     7bc:	4001      	ands	r1, r0
  {
    case HARDSER_STOP_BIT_1:
    default:
      return SERCOM_STOP_BIT_1;
     7be:	3930      	subs	r1, #48	; 0x30
     7c0:	4248      	negs	r0, r1
     7c2:	4148      	adcs	r0, r1

    case HARDSER_STOP_BIT_2:
      return SERCOM_STOP_BITS_2;
  }
}
     7c4:	4770      	bx	lr

000007c6 <_ZN4Uart15extractCharSizeEt>:

SercomUartCharSize Uart::extractCharSize(uint16_t config)
{
  switch(config & HARDSER_DATA_MASK)
     7c6:	23f0      	movs	r3, #240	; 0xf0
     7c8:	011b      	lsls	r3, r3, #4
     7ca:	4019      	ands	r1, r3
     7cc:	2380      	movs	r3, #128	; 0x80
  {
    case HARDSER_DATA_5:
      return UART_CHAR_SIZE_5_BITS;

    case HARDSER_DATA_6:
      return UART_CHAR_SIZE_6_BITS;
     7ce:	2006      	movs	r0, #6
  switch(config & HARDSER_DATA_MASK)
     7d0:	009b      	lsls	r3, r3, #2
     7d2:	4299      	cmp	r1, r3
     7d4:	d00a      	beq.n	7ec <_ZN4Uart15extractCharSizeEt+0x26>
     7d6:	3301      	adds	r3, #1
     7d8:	33ff      	adds	r3, #255	; 0xff

    case HARDSER_DATA_7:
      return UART_CHAR_SIZE_7_BITS;
     7da:	3001      	adds	r0, #1
  switch(config & HARDSER_DATA_MASK)
     7dc:	4299      	cmp	r1, r3
     7de:	d005      	beq.n	7ec <_ZN4Uart15extractCharSizeEt+0x26>
     7e0:	2380      	movs	r3, #128	; 0x80
      return UART_CHAR_SIZE_5_BITS;
     7e2:	3802      	subs	r0, #2
  switch(config & HARDSER_DATA_MASK)
     7e4:	005b      	lsls	r3, r3, #1
     7e6:	4299      	cmp	r1, r3
     7e8:	d000      	beq.n	7ec <_ZN4Uart15extractCharSizeEt+0x26>

    case HARDSER_DATA_8:
    default:
      return UART_CHAR_SIZE_8_BITS;
     7ea:	2000      	movs	r0, #0

  }
}
     7ec:	4770      	bx	lr

000007ee <_ZN4Uart13extractParityEt>:

SercomParityMode Uart::extractParity(uint16_t config)
{
  switch(config & HARDSER_PARITY_MASK)
     7ee:	200f      	movs	r0, #15
     7f0:	4001      	ands	r1, r0
    case HARDSER_PARITY_NONE:
    default:
      return SERCOM_NO_PARITY;

    case HARDSER_PARITY_EVEN:
      return SERCOM_EVEN_PARITY;
     7f2:	2000      	movs	r0, #0
  switch(config & HARDSER_PARITY_MASK)
     7f4:	2901      	cmp	r1, #1
     7f6:	d003      	beq.n	800 <_ZN4Uart13extractParityEt+0x12>
      return SERCOM_NO_PARITY;
     7f8:	3902      	subs	r1, #2
     7fa:	1e48      	subs	r0, r1, #1
     7fc:	4181      	sbcs	r1, r0
     7fe:	1c48      	adds	r0, r1, #1

    case HARDSER_PARITY_ODD:
      return SERCOM_ODD_PARITY;
  }
}
     800:	4770      	bx	lr
	...

00000804 <_ZN4Uart5beginEmt>:
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
     804:	2389      	movs	r3, #137	; 0x89
{
     806:	b5f0      	push	{r4, r5, r6, r7, lr}
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
     808:	2618      	movs	r6, #24
{
     80a:	b085      	sub	sp, #20
     80c:	9102      	str	r1, [sp, #8]
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
     80e:	009b      	lsls	r3, r3, #2
{
     810:	0004      	movs	r4, r0
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
     812:	5cc0      	ldrb	r0, [r0, r3]
     814:	0033      	movs	r3, r6
     816:	2108      	movs	r1, #8
     818:	4343      	muls	r3, r0
     81a:	4d32      	ldr	r5, [pc, #200]	; (8e4 <_ZN4Uart5beginEmt+0xe0>)
{
     81c:	0017      	movs	r7, r2
  pinPeripheral(uc_pinRX, g_APinDescription[uc_pinRX].ulPinType);
     81e:	18eb      	adds	r3, r5, r3
     820:	5659      	ldrsb	r1, [r3, r1]
     822:	f001 fab3 	bl	1d8c <pinPeripheral>
  pinPeripheral(uc_pinTX, g_APinDescription[uc_pinTX].ulPinType);
     826:	4b30      	ldr	r3, [pc, #192]	; (8e8 <_ZN4Uart5beginEmt+0xe4>)
     828:	2108      	movs	r1, #8
     82a:	5ce0      	ldrb	r0, [r4, r3]
     82c:	0033      	movs	r3, r6
     82e:	4343      	muls	r3, r0
     830:	18eb      	adds	r3, r5, r3
     832:	5659      	ldrsb	r1, [r3, r1]
     834:	f001 faaa 	bl	1d8c <pinPeripheral>
  if (uc_padTX == UART_TX_RTS_CTS_PAD_0_2_3) { 
     838:	4b2c      	ldr	r3, [pc, #176]	; (8ec <_ZN4Uart5beginEmt+0xe8>)
     83a:	5ce2      	ldrb	r2, [r4, r3]
     83c:	9303      	str	r3, [sp, #12]
     83e:	2a02      	cmp	r2, #2
     840:	d109      	bne.n	856 <_ZN4Uart5beginEmt+0x52>
    if (uc_pinCTS != NO_CTS_PIN) {
     842:	3311      	adds	r3, #17
     844:	5ce0      	ldrb	r0, [r4, r3]
     846:	28ff      	cmp	r0, #255	; 0xff
     848:	d005      	beq.n	856 <_ZN4Uart5beginEmt+0x52>
      pinPeripheral(uc_pinCTS, g_APinDescription[uc_pinCTS].ulPinType);
     84a:	2108      	movs	r1, #8
     84c:	4346      	muls	r6, r0
     84e:	19ae      	adds	r6, r5, r6
     850:	5671      	ldrsb	r1, [r6, r1]
     852:	f001 fa9b 	bl	1d8c <pinPeripheral>
  if (uc_pinRTS != NO_RTS_PIN) {
     856:	268a      	movs	r6, #138	; 0x8a
     858:	00b6      	lsls	r6, r6, #2
     85a:	5da0      	ldrb	r0, [r4, r6]
     85c:	28ff      	cmp	r0, #255	; 0xff
     85e:	d019      	beq.n	894 <_ZN4Uart5beginEmt+0x90>
    pinMode(uc_pinRTS, OUTPUT);
     860:	2101      	movs	r1, #1
     862:	f001 fa1b 	bl	1c9c <pinMode>
    EPortType rtsPort = g_APinDescription[uc_pinRTS].ulPort;
     866:	2218      	movs	r2, #24
     868:	5da3      	ldrb	r3, [r4, r6]
    pul_outsetRTS = &PORT->Group[rtsPort].OUTSET.reg;
     86a:	4921      	ldr	r1, [pc, #132]	; (8f0 <_ZN4Uart5beginEmt+0xec>)
    EPortType rtsPort = g_APinDescription[uc_pinRTS].ulPort;
     86c:	435a      	muls	r2, r3
    pul_outsetRTS = &PORT->Group[rtsPort].OUTSET.reg;
     86e:	56ab      	ldrsb	r3, [r5, r2]
    ul_pinMaskRTS = (1ul << g_APinDescription[uc_pinRTS].ulPin);
     870:	18ad      	adds	r5, r5, r2
    pul_outsetRTS = &PORT->Group[rtsPort].OUTSET.reg;
     872:	01db      	lsls	r3, r3, #7
     874:	1858      	adds	r0, r3, r1
     876:	218b      	movs	r1, #139	; 0x8b
     878:	0089      	lsls	r1, r1, #2
     87a:	5060      	str	r0, [r4, r1]
    pul_outclrRTS = &PORT->Group[rtsPort].OUTCLR.reg;
     87c:	491d      	ldr	r1, [pc, #116]	; (8f4 <_ZN4Uart5beginEmt+0xf0>)
    ul_pinMaskRTS = (1ul << g_APinDescription[uc_pinRTS].ulPin);
     87e:	2201      	movs	r2, #1
    pul_outclrRTS = &PORT->Group[rtsPort].OUTCLR.reg;
     880:	185b      	adds	r3, r3, r1
     882:	218c      	movs	r1, #140	; 0x8c
     884:	0089      	lsls	r1, r1, #2
     886:	5063      	str	r3, [r4, r1]
    ul_pinMaskRTS = (1ul << g_APinDescription[uc_pinRTS].ulPin);
     888:	6869      	ldr	r1, [r5, #4]
     88a:	408a      	lsls	r2, r1
     88c:	218d      	movs	r1, #141	; 0x8d
     88e:	0089      	lsls	r1, r1, #2
     890:	5062      	str	r2, [r4, r1]
    *pul_outclrRTS = ul_pinMaskRTS;
     892:	601a      	str	r2, [r3, #0]
  sercom->initUART(UART_INT_CLOCK, SAMPLE_RATE_x16, baudrate);
     894:	2201      	movs	r2, #1
     896:	9b02      	ldr	r3, [sp, #8]
     898:	0011      	movs	r1, r2
     89a:	6920      	ldr	r0, [r4, #16]
     89c:	f002 fa7a 	bl	2d94 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>
  sercom->initFrame(extractCharSize(config), LSB_FIRST, extractParity(config), extractNbStopBit(config));
     8a0:	0039      	movs	r1, r7
     8a2:	0020      	movs	r0, r4
     8a4:	f7ff ff8f 	bl	7c6 <_ZN4Uart15extractCharSizeEt>
     8a8:	0039      	movs	r1, r7
     8aa:	0005      	movs	r5, r0
     8ac:	0020      	movs	r0, r4
     8ae:	f7ff ff9e 	bl	7ee <_ZN4Uart13extractParityEt>
     8b2:	0039      	movs	r1, r7
     8b4:	0006      	movs	r6, r0
     8b6:	0020      	movs	r0, r4
     8b8:	f7ff ff7f 	bl	7ba <_ZN4Uart16extractNbStopBitEt>
     8bc:	0033      	movs	r3, r6
     8be:	9000      	str	r0, [sp, #0]
     8c0:	0029      	movs	r1, r5
     8c2:	6920      	ldr	r0, [r4, #16]
     8c4:	2201      	movs	r2, #1
     8c6:	f002 f98f 	bl	2be8 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>
  sercom->initPads(uc_padTX, uc_padRX);
     8ca:	4b0b      	ldr	r3, [pc, #44]	; (8f8 <_ZN4Uart5beginEmt+0xf4>)
     8cc:	6920      	ldr	r0, [r4, #16]
     8ce:	5ce2      	ldrb	r2, [r4, r3]
     8d0:	9b03      	ldr	r3, [sp, #12]
     8d2:	5ce1      	ldrb	r1, [r4, r3]
     8d4:	f002 f9a2 	bl	2c1c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>
  sercom->enableUART();
     8d8:	6920      	ldr	r0, [r4, #16]
     8da:	f002 f9bd 	bl	2c58 <_ZN6SERCOM10enableUARTEv>
}
     8de:	b005      	add	sp, #20
     8e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     8e2:	46c0      	nop			; (mov r8, r8)
     8e4:	00003eb0 	.word	0x00003eb0
     8e8:	00000225 	.word	0x00000225
     8ec:	00000227 	.word	0x00000227
     8f0:	41004418 	.word	0x41004418
     8f4:	41004414 	.word	0x41004414
     8f8:	00000226 	.word	0x00000226

000008fc <_ZN11RingBufferNILi256EEC1Ev>:
    memset( _aucBuffer, 0, N ) ;
     8fc:	2280      	movs	r2, #128	; 0x80
RingBufferN<N>::RingBufferN( void )
     8fe:	b510      	push	{r4, lr}
     900:	0004      	movs	r4, r0
    memset( _aucBuffer, 0, N ) ;
     902:	0052      	lsls	r2, r2, #1
     904:	2100      	movs	r1, #0
     906:	f003 f928 	bl	3b5a <memset>
  _iHead = 0;
     90a:	0023      	movs	r3, r4
     90c:	2200      	movs	r2, #0
     90e:	33fc      	adds	r3, #252	; 0xfc
     910:	605a      	str	r2, [r3, #4]
}
     912:	0020      	movs	r0, r4
  _iTail = 0;
     914:	609a      	str	r2, [r3, #8]
}
     916:	bd10      	pop	{r4, pc}

00000918 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>:
Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX) :
     918:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
     91a:	001d      	movs	r5, r3
     91c:	ab08      	add	r3, sp, #32
     91e:	781b      	ldrb	r3, [r3, #0]
     920:	0004      	movs	r4, r0
     922:	9300      	str	r3, [sp, #0]
     924:	ab09      	add	r3, sp, #36	; 0x24
     926:	781b      	ldrb	r3, [r3, #0]
     928:	0016      	movs	r6, r2
     92a:	9301      	str	r3, [sp, #4]
    Print() : write_error(0) {}
     92c:	2300      	movs	r3, #0
     92e:	6043      	str	r3, [r0, #4]
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
     930:	23fa      	movs	r3, #250	; 0xfa
     932:	009b      	lsls	r3, r3, #2
     934:	6083      	str	r3, [r0, #8]
Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX, uint8_t _pinRTS, uint8_t _pinCTS)
     936:	4b11      	ldr	r3, [pc, #68]	; (97c <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x64>)
Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX) :
     938:	000f      	movs	r7, r1
Uart::Uart(SERCOM *_s, uint8_t _pinRX, uint8_t _pinTX, SercomRXPad _padRX, SercomUartTXPad _padTX, uint8_t _pinRTS, uint8_t _pinCTS)
     93a:	3308      	adds	r3, #8
     93c:	6003      	str	r3, [r0, #0]
     93e:	3014      	adds	r0, #20
     940:	f7ff ffdc 	bl	8fc <_ZN11RingBufferNILi256EEC1Ev>
     944:	0020      	movs	r0, r4
     946:	301d      	adds	r0, #29
     948:	30ff      	adds	r0, #255	; 0xff
     94a:	f7ff ffd7 	bl	8fc <_ZN11RingBufferNILi256EEC1Ev>
  uc_pinRX = _pinRX;
     94e:	2389      	movs	r3, #137	; 0x89
  uc_padRX = _padRX ;
     950:	466a      	mov	r2, sp
  uc_pinRX = _pinRX;
     952:	009b      	lsls	r3, r3, #2
  sercom = _s;
     954:	6127      	str	r7, [r4, #16]
  uc_pinRX = _pinRX;
     956:	54e6      	strb	r6, [r4, r3]
  uc_pinTX = _pinTX;
     958:	4b09      	ldr	r3, [pc, #36]	; (980 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x68>)
  uc_padRX = _padRX ;
     95a:	7812      	ldrb	r2, [r2, #0]
  uc_pinTX = _pinTX;
     95c:	54e5      	strb	r5, [r4, r3]
  uc_padRX = _padRX ;
     95e:	4b09      	ldr	r3, [pc, #36]	; (984 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x6c>)
}
     960:	0020      	movs	r0, r4
  uc_padRX = _padRX ;
     962:	54e2      	strb	r2, [r4, r3]
  uc_padTX = _padTX;
     964:	466a      	mov	r2, sp
     966:	4b08      	ldr	r3, [pc, #32]	; (988 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad+0x70>)
     968:	7912      	ldrb	r2, [r2, #4]
     96a:	54e2      	strb	r2, [r4, r3]
  uc_pinRTS = _pinRTS;
     96c:	228a      	movs	r2, #138	; 0x8a
     96e:	3b29      	subs	r3, #41	; 0x29
     970:	3bff      	subs	r3, #255	; 0xff
     972:	0092      	lsls	r2, r2, #2
     974:	54a3      	strb	r3, [r4, r2]
  uc_pinCTS = _pinCTS;
     976:	3210      	adds	r2, #16
     978:	54a3      	strb	r3, [r4, r2]
}
     97a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
     97c:	00003e1c 	.word	0x00003e1c
     980:	00000225 	.word	0x00000225
     984:	00000226 	.word	0x00000226
     988:	00000227 	.word	0x00000227

0000098c <_ZN11RingBufferNILi256EE9availableEv>:
  int delta = _iHead - _iTail;
     98c:	0003      	movs	r3, r0
     98e:	33fc      	adds	r3, #252	; 0xfc
     990:	6858      	ldr	r0, [r3, #4]
     992:	689b      	ldr	r3, [r3, #8]
     994:	1ac0      	subs	r0, r0, r3
  if(delta < 0)
     996:	d501      	bpl.n	99c <_ZN11RingBufferNILi256EE9availableEv+0x10>
    return N + delta;
     998:	3001      	adds	r0, #1
     99a:	30ff      	adds	r0, #255	; 0xff
}
     99c:	4770      	bx	lr

0000099e <_ZN4Uart5flushEv>:
{
     99e:	b510      	push	{r4, lr}
     9a0:	0004      	movs	r4, r0
  while(txBuffer.available()); // wait until TX buffer is empty
     9a2:	0020      	movs	r0, r4
     9a4:	301d      	adds	r0, #29
     9a6:	30ff      	adds	r0, #255	; 0xff
     9a8:	f7ff fff0 	bl	98c <_ZN11RingBufferNILi256EE9availableEv>
     9ac:	2800      	cmp	r0, #0
     9ae:	d1f8      	bne.n	9a2 <_ZN4Uart5flushEv+0x4>
  sercom->flushUART();
     9b0:	6920      	ldr	r0, [r4, #16]
     9b2:	f002 f95a 	bl	2c6a <_ZN6SERCOM9flushUARTEv>
}
     9b6:	bd10      	pop	{r4, pc}

000009b8 <_ZN4Uart9availableEv>:
{
     9b8:	b510      	push	{r4, lr}
  return rxBuffer.available();
     9ba:	3014      	adds	r0, #20
     9bc:	f7ff ffe6 	bl	98c <_ZN11RingBufferNILi256EE9availableEv>
}
     9c0:	bd10      	pop	{r4, pc}

000009c2 <_ZN11RingBufferNILi256EE17availableForStoreEv>:
  if (_iHead >= _iTail)
     9c2:	0003      	movs	r3, r0
     9c4:	33fc      	adds	r3, #252	; 0xfc
     9c6:	6859      	ldr	r1, [r3, #4]
     9c8:	689a      	ldr	r2, [r3, #8]
     9ca:	4291      	cmp	r1, r2
     9cc:	db04      	blt.n	9d8 <_ZN11RingBufferNILi256EE17availableForStoreEv+0x16>
    return N - 1 - _iHead + _iTail;
     9ce:	685a      	ldr	r2, [r3, #4]
     9d0:	6898      	ldr	r0, [r3, #8]
     9d2:	1a80      	subs	r0, r0, r2
     9d4:	30ff      	adds	r0, #255	; 0xff
}
     9d6:	4770      	bx	lr
    return _iTail - _iHead - 1;
     9d8:	6898      	ldr	r0, [r3, #8]
     9da:	685b      	ldr	r3, [r3, #4]
     9dc:	1ac0      	subs	r0, r0, r3
     9de:	3801      	subs	r0, #1
     9e0:	e7f9      	b.n	9d6 <_ZN11RingBufferNILi256EE17availableForStoreEv+0x14>

000009e2 <_ZN4Uart17availableForWriteEv>:
{
     9e2:	b510      	push	{r4, lr}
  return txBuffer.availableForStore();
     9e4:	301d      	adds	r0, #29
     9e6:	30ff      	adds	r0, #255	; 0xff
     9e8:	f7ff ffeb 	bl	9c2 <_ZN11RingBufferNILi256EE17availableForStoreEv>
}
     9ec:	bd10      	pop	{r4, pc}

000009ee <_ZN4Uart10IrqHandlerEv>:
{
     9ee:	b510      	push	{r4, lr}
     9f0:	0004      	movs	r4, r0
  if (sercom->isFrameErrorUART()) {
     9f2:	6900      	ldr	r0, [r0, #16]
     9f4:	f002 f955 	bl	2ca2 <_ZN6SERCOM16isFrameErrorUARTEv>
     9f8:	2800      	cmp	r0, #0
     9fa:	d005      	beq.n	a08 <_ZN4Uart10IrqHandlerEv+0x1a>
    sercom->readDataUART();
     9fc:	6920      	ldr	r0, [r4, #16]
     9fe:	f002 f960 	bl	2cc2 <_ZN6SERCOM12readDataUARTEv>
    sercom->clearFrameErrorUART();
     a02:	6920      	ldr	r0, [r4, #16]
     a04:	f002 f952 	bl	2cac <_ZN6SERCOM19clearFrameErrorUARTEv>
  if (sercom->availableDataUART()) {
     a08:	6920      	ldr	r0, [r4, #16]
     a0a:	f002 f93a 	bl	2c82 <_ZN6SERCOM17availableDataUARTEv>
     a0e:	2800      	cmp	r0, #0
     a10:	d020      	beq.n	a54 <_ZN4Uart10IrqHandlerEv+0x66>
    rxBuffer.store_char(sercom->readDataUART());
     a12:	6920      	ldr	r0, [r4, #16]
     a14:	f002 f955 	bl	2cc2 <_ZN6SERCOM12readDataUARTEv>
  int i = nextIndex(_iHead);
     a18:	0022      	movs	r2, r4
     a1a:	32fc      	adds	r2, #252	; 0xfc
     a1c:	6993      	ldr	r3, [r2, #24]
  if ( i != _iTail )
     a1e:	69d1      	ldr	r1, [r2, #28]
}

template <int N>
int RingBufferN<N>::nextIndex(int index)
{
  return (uint32_t)(index + 1) % N;
     a20:	3301      	adds	r3, #1
     a22:	b2db      	uxtb	r3, r3
  if ( i != _iTail )
     a24:	428b      	cmp	r3, r1
     a26:	d003      	beq.n	a30 <_ZN4Uart10IrqHandlerEv+0x42>
    _aucBuffer[_iHead] = c ;
     a28:	6991      	ldr	r1, [r2, #24]
     a2a:	1861      	adds	r1, r4, r1
     a2c:	7508      	strb	r0, [r1, #20]
    _iHead = i ;
     a2e:	6193      	str	r3, [r2, #24]
    if (uc_pinRTS != NO_RTS_PIN) {
     a30:	238a      	movs	r3, #138	; 0x8a
     a32:	009b      	lsls	r3, r3, #2
     a34:	5ce3      	ldrb	r3, [r4, r3]
     a36:	2bff      	cmp	r3, #255	; 0xff
     a38:	d00c      	beq.n	a54 <_ZN4Uart10IrqHandlerEv+0x66>
    rxBuffer.store_char(sercom->readDataUART());
     a3a:	0020      	movs	r0, r4
     a3c:	3014      	adds	r0, #20
      if (rxBuffer.availableForStore() < RTS_RX_THRESHOLD) {
     a3e:	f7ff ffc0 	bl	9c2 <_ZN11RingBufferNILi256EE17availableForStoreEv>
     a42:	2809      	cmp	r0, #9
     a44:	dc06      	bgt.n	a54 <_ZN4Uart10IrqHandlerEv+0x66>
        *pul_outsetRTS = ul_pinMaskRTS;
     a46:	238b      	movs	r3, #139	; 0x8b
     a48:	228d      	movs	r2, #141	; 0x8d
     a4a:	009b      	lsls	r3, r3, #2
     a4c:	0092      	lsls	r2, r2, #2
     a4e:	58e3      	ldr	r3, [r4, r3]
     a50:	58a2      	ldr	r2, [r4, r2]
     a52:	601a      	str	r2, [r3, #0]
  if (sercom->isDataRegisterEmptyUART()) {
     a54:	6920      	ldr	r0, [r4, #16]
     a56:	f002 f92f 	bl	2cb8 <_ZN6SERCOM23isDataRegisterEmptyUARTEv>
     a5a:	2800      	cmp	r0, #0
     a5c:	d01a      	beq.n	a94 <_ZN4Uart10IrqHandlerEv+0xa6>
    if (txBuffer.available()) {
     a5e:	0020      	movs	r0, r4
     a60:	301d      	adds	r0, #29
     a62:	30ff      	adds	r0, #255	; 0xff
     a64:	f7ff ff92 	bl	98c <_ZN11RingBufferNILi256EE9availableEv>
     a68:	2800      	cmp	r0, #0
     a6a:	d022      	beq.n	ab2 <_ZN4Uart10IrqHandlerEv+0xc4>
  if(_iTail == _iHead)
     a6c:	2386      	movs	r3, #134	; 0x86
     a6e:	009b      	lsls	r3, r3, #2
     a70:	18e3      	adds	r3, r4, r3
     a72:	6899      	ldr	r1, [r3, #8]
     a74:	685a      	ldr	r2, [r3, #4]
     a76:	4291      	cmp	r1, r2
     a78:	d018      	beq.n	aac <_ZN4Uart10IrqHandlerEv+0xbe>
  uint8_t value = _aucBuffer[_iTail];
     a7a:	218e      	movs	r1, #142	; 0x8e
     a7c:	689a      	ldr	r2, [r3, #8]
     a7e:	0049      	lsls	r1, r1, #1
     a80:	18a2      	adds	r2, r4, r2
     a82:	5c51      	ldrb	r1, [r2, r1]
  _iTail = nextIndex(_iTail);
     a84:	689a      	ldr	r2, [r3, #8]
  return (uint32_t)(index + 1) % N;
     a86:	3201      	adds	r2, #1
     a88:	b2d2      	uxtb	r2, r2
  _iTail = nextIndex(_iTail);
     a8a:	609a      	str	r2, [r3, #8]
      sercom->writeDataUART(data);
     a8c:	b2c9      	uxtb	r1, r1
     a8e:	6920      	ldr	r0, [r4, #16]
     a90:	f002 f91b 	bl	2cca <_ZN6SERCOM13writeDataUARTEh>
  if (sercom->isUARTError()) {
     a94:	6920      	ldr	r0, [r4, #16]
     a96:	f002 f8f9 	bl	2c8c <_ZN6SERCOM11isUARTErrorEv>
     a9a:	2800      	cmp	r0, #0
     a9c:	d005      	beq.n	aaa <_ZN4Uart10IrqHandlerEv+0xbc>
    sercom->acknowledgeUARTError();
     a9e:	6920      	ldr	r0, [r4, #16]
     aa0:	f002 f8f8 	bl	2c94 <_ZN6SERCOM20acknowledgeUARTErrorEv>
    sercom->clearStatusUART();
     aa4:	6920      	ldr	r0, [r4, #16]
     aa6:	f002 f8e8 	bl	2c7a <_ZN6SERCOM15clearStatusUARTEv>
}
     aaa:	bd10      	pop	{r4, pc}
    return -1;
     aac:	2101      	movs	r1, #1
     aae:	4249      	negs	r1, r1
     ab0:	e7ec      	b.n	a8c <_ZN4Uart10IrqHandlerEv+0x9e>
      sercom->disableDataRegisterEmptyInterruptUART();
     ab2:	6920      	ldr	r0, [r4, #16]
     ab4:	f002 f915 	bl	2ce2 <_ZN6SERCOM37disableDataRegisterEmptyInterruptUARTEv>
     ab8:	e7ec      	b.n	a94 <_ZN4Uart10IrqHandlerEv+0xa6>
	...

00000abc <_ZN4Uart5writeEh>:
{
     abc:	b570      	push	{r4, r5, r6, lr}
     abe:	0004      	movs	r4, r0
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
     ac0:	6900      	ldr	r0, [r0, #16]
{
     ac2:	000d      	movs	r5, r1
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
     ac4:	f002 f8f8 	bl	2cb8 <_ZN6SERCOM23isDataRegisterEmptyUARTEv>
     ac8:	2800      	cmp	r0, #0
     aca:	d124      	bne.n	b16 <_ZN4Uart5writeEh+0x5a>
  return (uint32_t)(index + 1) % N;
     acc:	26ff      	movs	r6, #255	; 0xff
}

template <int N>
bool RingBufferN<N>::isFull()
{
  return (nextIndex(_iHead) == _iTail);
     ace:	2386      	movs	r3, #134	; 0x86
     ad0:	009b      	lsls	r3, r3, #2
     ad2:	18e3      	adds	r3, r4, r3
     ad4:	685a      	ldr	r2, [r3, #4]
     ad6:	6899      	ldr	r1, [r3, #8]
  return (uint32_t)(index + 1) % N;
     ad8:	3201      	adds	r2, #1
     ada:	4032      	ands	r2, r6
    while(txBuffer.isFull()) {
     adc:	428a      	cmp	r2, r1
     ade:	d12f      	bne.n	b40 <_ZN4Uart5writeEh+0x84>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     ae0:	f3ef 8310 	mrs	r3, PRIMASK
      if (interruptsEnabled) {
     ae4:	07db      	lsls	r3, r3, #31
     ae6:	d40d      	bmi.n	b04 <_ZN4Uart5writeEh+0x48>
        uint32_t exceptionNumber = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
     ae8:	4b1e      	ldr	r3, [pc, #120]	; (b64 <_ZN4Uart5writeEh+0xa8>)
     aea:	685b      	ldr	r3, [r3, #4]
     aec:	05db      	lsls	r3, r3, #23
     aee:	0ddb      	lsrs	r3, r3, #23
        if (exceptionNumber == 0 ||
     af0:	d0ed      	beq.n	ace <_ZN4Uart5writeEh+0x12>
              NVIC_GetPriority((IRQn_Type)(exceptionNumber - 16)) > SERCOM_NVIC_PRIORITY) {
     af2:	3b10      	subs	r3, #16
     af4:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
     af6:	2b00      	cmp	r3, #0
     af8:	db19      	blt.n	b2e <_ZN4Uart5writeEh+0x72>
    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
     afa:	089b      	lsrs	r3, r3, #2
     afc:	33c0      	adds	r3, #192	; 0xc0
     afe:	4a1a      	ldr	r2, [pc, #104]	; (b68 <_ZN4Uart5writeEh+0xac>)
     b00:	009b      	lsls	r3, r3, #2
     b02:	589b      	ldr	r3, [r3, r2]
      if (sercom->isDataRegisterEmptyUART()) {
     b04:	6920      	ldr	r0, [r4, #16]
     b06:	f002 f8d7 	bl	2cb8 <_ZN6SERCOM23isDataRegisterEmptyUARTEv>
     b0a:	2800      	cmp	r0, #0
     b0c:	d0df      	beq.n	ace <_ZN4Uart5writeEh+0x12>
        IrqHandler();
     b0e:	0020      	movs	r0, r4
     b10:	f7ff ff6d 	bl	9ee <_ZN4Uart10IrqHandlerEv>
     b14:	e7db      	b.n	ace <_ZN4Uart5writeEh+0x12>
  if (sercom->isDataRegisterEmptyUART() && txBuffer.available() == 0) {
     b16:	0020      	movs	r0, r4
     b18:	301d      	adds	r0, #29
     b1a:	30ff      	adds	r0, #255	; 0xff
     b1c:	f7ff ff36 	bl	98c <_ZN11RingBufferNILi256EE9availableEv>
     b20:	2800      	cmp	r0, #0
     b22:	d1d3      	bne.n	acc <_ZN4Uart5writeEh+0x10>
    sercom->writeDataUART(data);
     b24:	0029      	movs	r1, r5
     b26:	6920      	ldr	r0, [r4, #16]
     b28:	f002 f8cf 	bl	2cca <_ZN6SERCOM13writeDataUARTEh>
  return 1;
     b2c:	e017      	b.n	b5e <_ZN4Uart5writeEh+0xa2>
    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
     b2e:	220f      	movs	r2, #15
     b30:	4013      	ands	r3, r2
     b32:	3b08      	subs	r3, #8
     b34:	089b      	lsrs	r3, r3, #2
     b36:	4a0d      	ldr	r2, [pc, #52]	; (b6c <_ZN4Uart5writeEh+0xb0>)
     b38:	009b      	lsls	r3, r3, #2
     b3a:	189b      	adds	r3, r3, r2
     b3c:	681b      	ldr	r3, [r3, #0]
     b3e:	e7e1      	b.n	b04 <_ZN4Uart5writeEh+0x48>
  int i = nextIndex(_iHead);
     b40:	685a      	ldr	r2, [r3, #4]
  return (uint32_t)(index + 1) % N;
     b42:	3201      	adds	r2, #1
     b44:	4016      	ands	r6, r2
  if ( i != _iTail )
     b46:	689a      	ldr	r2, [r3, #8]
     b48:	4296      	cmp	r6, r2
     b4a:	d005      	beq.n	b58 <_ZN4Uart5writeEh+0x9c>
    _aucBuffer[_iHead] = c ;
     b4c:	218e      	movs	r1, #142	; 0x8e
     b4e:	685a      	ldr	r2, [r3, #4]
     b50:	0049      	lsls	r1, r1, #1
     b52:	18a2      	adds	r2, r4, r2
     b54:	5455      	strb	r5, [r2, r1]
    _iHead = i ;
     b56:	605e      	str	r6, [r3, #4]
    sercom->enableDataRegisterEmptyInterruptUART();
     b58:	6920      	ldr	r0, [r4, #16]
     b5a:	f002 f8be 	bl	2cda <_ZN6SERCOM36enableDataRegisterEmptyInterruptUARTEv>
}
     b5e:	2001      	movs	r0, #1
     b60:	bd70      	pop	{r4, r5, r6, pc}
     b62:	46c0      	nop			; (mov r8, r8)
     b64:	e000ed00 	.word	0xe000ed00
     b68:	e000e100 	.word	0xe000e100
     b6c:	e000ed1c 	.word	0xe000ed1c

00000b70 <_ZN4Uart4readEv>:
  if(_iTail == _iHead)
     b70:	0003      	movs	r3, r0
     b72:	33fc      	adds	r3, #252	; 0xfc
     b74:	69d9      	ldr	r1, [r3, #28]
     b76:	699a      	ldr	r2, [r3, #24]
{
     b78:	b570      	push	{r4, r5, r6, lr}
     b7a:	0004      	movs	r4, r0
     b7c:	4291      	cmp	r1, r2
     b7e:	d01a      	beq.n	bb6 <_ZN4Uart4readEv+0x46>
  uint8_t value = _aucBuffer[_iTail];
     b80:	69da      	ldr	r2, [r3, #28]
     b82:	1882      	adds	r2, r0, r2
     b84:	7d15      	ldrb	r5, [r2, #20]
  _iTail = nextIndex(_iTail);
     b86:	69da      	ldr	r2, [r3, #28]
  return (uint32_t)(index + 1) % N;
     b88:	3201      	adds	r2, #1
     b8a:	b2d2      	uxtb	r2, r2
  _iTail = nextIndex(_iTail);
     b8c:	61da      	str	r2, [r3, #28]
  if (uc_pinRTS != NO_RTS_PIN) {
     b8e:	238a      	movs	r3, #138	; 0x8a
     b90:	009b      	lsls	r3, r3, #2
     b92:	5ce3      	ldrb	r3, [r4, r3]
     b94:	2bff      	cmp	r3, #255	; 0xff
     b96:	d00c      	beq.n	bb2 <_ZN4Uart4readEv+0x42>
  int c = rxBuffer.read_char();
     b98:	0020      	movs	r0, r4
     b9a:	3014      	adds	r0, #20
    if (rxBuffer.availableForStore() > RTS_RX_THRESHOLD) {
     b9c:	f7ff ff11 	bl	9c2 <_ZN11RingBufferNILi256EE17availableForStoreEv>
     ba0:	280a      	cmp	r0, #10
     ba2:	dd06      	ble.n	bb2 <_ZN4Uart4readEv+0x42>
      *pul_outclrRTS = ul_pinMaskRTS;
     ba4:	238c      	movs	r3, #140	; 0x8c
     ba6:	228d      	movs	r2, #141	; 0x8d
     ba8:	009b      	lsls	r3, r3, #2
     baa:	0092      	lsls	r2, r2, #2
     bac:	58e3      	ldr	r3, [r4, r3]
     bae:	58a2      	ldr	r2, [r4, r2]
     bb0:	601a      	str	r2, [r3, #0]
}
     bb2:	0028      	movs	r0, r5
     bb4:	bd70      	pop	{r4, r5, r6, pc}
    return -1;
     bb6:	2501      	movs	r5, #1
     bb8:	426d      	negs	r5, r5
     bba:	e7e8      	b.n	b8e <_ZN4Uart4readEv+0x1e>

00000bbc <_ZL5utox8mPc>:
	packMessages(false);

	return true;
}

static void utox8(uint32_t val, char* s) {
     bbc:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < 8; i++) {
		int d = val & 0XF;
     bbe:	250f      	movs	r5, #15
     bc0:	1dcb      	adds	r3, r1, #7
     bc2:	3901      	subs	r1, #1
     bc4:	0002      	movs	r2, r0
     bc6:	402a      	ands	r2, r5
		val = (val >> 4);

		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
     bc8:	0014      	movs	r4, r2
		val = (val >> 4);
     bca:	0900      	lsrs	r0, r0, #4
		s[7 - i] = d > 9 ? 'A' + d - 10 : '0' + d;
     bcc:	3430      	adds	r4, #48	; 0x30
     bce:	2a09      	cmp	r2, #9
     bd0:	dd01      	ble.n	bd6 <_ZL5utox8mPc+0x1a>
     bd2:	3237      	adds	r2, #55	; 0x37
     bd4:	0014      	movs	r4, r2
     bd6:	701c      	strb	r4, [r3, #0]
     bd8:	3b01      	subs	r3, #1
	for (int i = 0; i < 8; i++) {
     bda:	428b      	cmp	r3, r1
     bdc:	d1f2      	bne.n	bc4 <_ZL5utox8mPc+0x8>
	}
}
     bde:	bd30      	pop	{r4, r5, pc}

00000be0 <_ZN26DoubleBufferedEPOutHandlerD1Ev>:
		usbd.epBank0SetAddress(ep, const_cast<uint8_t *>(data0));

		release();
	}

	virtual ~DoubleBufferedEPOutHandler() {
     be0:	b510      	push	{r4, lr}
     be2:	0004      	movs	r4, r0
		free((void*)data0);
     be4:	6980      	ldr	r0, [r0, #24]
     be6:	f002 ffa5 	bl	3b34 <free>
		free((void*)data1);
     bea:	6aa0      	ldr	r0, [r4, #40]	; 0x28
     bec:	f002 ffa2 	bl	3b34 <free>
	}
     bf0:	0020      	movs	r0, r4
     bf2:	bd10      	pop	{r4, pc}

00000bf4 <_ZN26DoubleBufferedEPOutHandlerD0Ev>:
	virtual ~DoubleBufferedEPOutHandler() {
     bf4:	b510      	push	{r4, lr}
     bf6:	0004      	movs	r4, r0
	}
     bf8:	f7ff fff2 	bl	be0 <_ZN26DoubleBufferedEPOutHandlerD1Ev>
     bfc:	0020      	movs	r0, r4
     bfe:	f001 ffed 	bl	2bdc <_ZdlPv>
     c02:	0020      	movs	r0, r4
     c04:	bd10      	pop	{r4, pc}
	...

00000c08 <_ZN14USBDeviceClass6initEPEmm.part.5>:
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
		initEP(i, EndPoints[i]);
	}
}

void USBDeviceClass::initEP(uint32_t ep, uint32_t config)
     c08:	b570      	push	{r4, r5, r6, lr}
		if (epHandlers[ep] != NULL) {
			delete (DoubleBufferedEPOutHandler*)epHandlers[ep];
		}
		epHandlers[ep] = new DoubleBufferedEPOutHandler(usbd, ep, 256);
	}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_IN(0)))
     c0a:	2982      	cmp	r1, #130	; 0x82
     c0c:	d11f      	bne.n	c4e <_ZN14USBDeviceClass6initEPEmm.part.5+0x46>
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
     c0e:	b2c3      	uxtb	r3, r0
     c10:	4d2c      	ldr	r5, [pc, #176]	; (cc4 <_ZN14USBDeviceClass6initEPEmm.part.5+0xbc>)
     c12:	015a      	lsls	r2, r3, #5
     c14:	18aa      	adds	r2, r5, r2
     c16:	6991      	ldr	r1, [r2, #24]
     c18:	4c2b      	ldr	r4, [pc, #172]	; (cc8 <_ZN14USBDeviceClass6initEPEmm.part.5+0xc0>)
	{
		usbd.epBank1SetSize(ep, 64);
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
     c1a:	0180      	lsls	r0, r0, #6
     c1c:	400c      	ands	r4, r1
     c1e:	21c0      	movs	r1, #192	; 0xc0
     c20:	0589      	lsls	r1, r1, #22
     c22:	4321      	orrs	r1, r4
     c24:	6191      	str	r1, [r2, #24]
     c26:	4929      	ldr	r1, [pc, #164]	; (ccc <_ZN14USBDeviceClass6initEPEmm.part.5+0xc4>)
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
     c28:	3308      	adds	r3, #8
     c2a:	1808      	adds	r0, r1, r0
     c2c:	2180      	movs	r1, #128	; 0x80
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
     c2e:	6150      	str	r0, [r2, #20]
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
     c30:	682a      	ldr	r2, [r5, #0]
     c32:	015b      	lsls	r3, r3, #5
     c34:	18d0      	adds	r0, r2, r3
     c36:	7904      	ldrb	r4, [r0, #4]
     c38:	4249      	negs	r1, r1
     c3a:	4321      	orrs	r1, r4
     c3c:	7101      	strb	r1, [r0, #4]
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
     c3e:	2070      	movs	r0, #112	; 0x70
     c40:	5c99      	ldrb	r1, [r3, r2]
     c42:	4381      	bics	r1, r0
     c44:	0008      	movs	r0, r1
     c46:	2130      	movs	r1, #48	; 0x30
     c48:	4301      	orrs	r1, r0
     c4a:	5499      	strb	r1, [r3, r2]
		usbd.epBank0SetByteCount(ep, 0);

		// NAK on endpoint OUT, the bank is full.
		usbd.epBank0SetReady(ep);
	}
}
     c4c:	bd70      	pop	{r4, r5, r6, pc}
	else if (config == USB_ENDPOINT_TYPE_CONTROL)
     c4e:	2900      	cmp	r1, #0
     c50:	d1fc      	bne.n	c4c <_ZN14USBDeviceClass6initEPEmm.part.5+0x44>
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
     c52:	24c0      	movs	r4, #192	; 0xc0
     c54:	b2c1      	uxtb	r1, r0
     c56:	4e1b      	ldr	r6, [pc, #108]	; (cc4 <_ZN14USBDeviceClass6initEPEmm.part.5+0xbc>)
     c58:	014b      	lsls	r3, r1, #5
     c5a:	18f3      	adds	r3, r6, r3
     c5c:	689a      	ldr	r2, [r3, #8]
     c5e:	4d1a      	ldr	r5, [pc, #104]	; (cc8 <_ZN14USBDeviceClass6initEPEmm.part.5+0xc0>)
     c60:	05a4      	lsls	r4, r4, #22
     c62:	402a      	ands	r2, r5
     c64:	4322      	orrs	r2, r4
     c66:	609a      	str	r2, [r3, #8]
		usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
     c68:	4a19      	ldr	r2, [pc, #100]	; (cd0 <_ZN14USBDeviceClass6initEPEmm.part.5+0xc8>)
     c6a:	0180      	lsls	r0, r0, #6
     c6c:	1810      	adds	r0, r2, r0
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
     c6e:	000a      	movs	r2, r1
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
     c70:	6058      	str	r0, [r3, #4]
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
     c72:	6830      	ldr	r0, [r6, #0]
     c74:	2607      	movs	r6, #7
     c76:	3208      	adds	r2, #8
     c78:	0152      	lsls	r2, r2, #5
     c7a:	5c11      	ldrb	r1, [r2, r0]
     c7c:	43b1      	bics	r1, r6
     c7e:	000e      	movs	r6, r1
     c80:	2101      	movs	r1, #1
     c82:	4331      	orrs	r1, r6
     c84:	5411      	strb	r1, [r2, r0]
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
     c86:	6999      	ldr	r1, [r3, #24]
     c88:	400d      	ands	r5, r1
     c8a:	432c      	orrs	r4, r5
     c8c:	619c      	str	r4, [r3, #24]
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
     c8e:	2470      	movs	r4, #112	; 0x70
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
     c90:	490e      	ldr	r1, [pc, #56]	; (ccc <_ZN14USBDeviceClass6initEPEmm.part.5+0xc4>)
     c92:	6159      	str	r1, [r3, #20]
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
     c94:	5c11      	ldrb	r1, [r2, r0]
     c96:	43a1      	bics	r1, r4
     c98:	000c      	movs	r4, r1
     c9a:	2110      	movs	r1, #16
     c9c:	4321      	orrs	r1, r4
     c9e:	5411      	strb	r1, [r2, r0]
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
     ca0:	6899      	ldr	r1, [r3, #8]
     ca2:	4c0c      	ldr	r4, [pc, #48]	; (cd4 <_ZN14USBDeviceClass6initEPEmm.part.5+0xcc>)
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
     ca4:	1882      	adds	r2, r0, r2
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
     ca6:	400c      	ands	r4, r1
     ca8:	2180      	movs	r1, #128	; 0x80
     caa:	0349      	lsls	r1, r1, #13
     cac:	4321      	orrs	r1, r4
     cae:	6099      	str	r1, [r3, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
     cb0:	6899      	ldr	r1, [r3, #8]
     cb2:	0b89      	lsrs	r1, r1, #14
     cb4:	0389      	lsls	r1, r1, #14
     cb6:	6099      	str	r1, [r3, #8]
	inline void epBank0SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK0RDY = 1; }
     cb8:	2340      	movs	r3, #64	; 0x40
     cba:	7951      	ldrb	r1, [r2, #5]
     cbc:	430b      	orrs	r3, r1
     cbe:	7153      	strb	r3, [r2, #5]
     cc0:	e7c4      	b.n	c4c <_ZN14USBDeviceClass6initEPEmm.part.5+0x44>
     cc2:	46c0      	nop			; (mov r8, r8)
     cc4:	200005ec 	.word	0x200005ec
     cc8:	8fffffff 	.word	0x8fffffff
     ccc:	20000160 	.word	0x20000160
     cd0:	20000320 	.word	0x20000320
     cd4:	f0003fff 	.word	0xf0003fff

00000cd8 <_ZN20USBDevice_SAMD21G18x5resetEv>:
void USBDevice_SAMD21G18x::reset() {
     cd8:	b570      	push	{r4, r5, r6, lr}
	usb.CTRLA.bit.SWRST = 1;
     cda:	0004      	movs	r4, r0
     cdc:	2301      	movs	r3, #1
     cde:	cc20      	ldmia	r4!, {r5}
	memset(EP, 0, sizeof(EP));
     ce0:	2100      	movs	r1, #0
	usb.CTRLA.bit.SWRST = 1;
     ce2:	782a      	ldrb	r2, [r5, #0]
	memset(EP, 0, sizeof(EP));
     ce4:	0020      	movs	r0, r4
	usb.CTRLA.bit.SWRST = 1;
     ce6:	4313      	orrs	r3, r2
	memset(EP, 0, sizeof(EP));
     ce8:	2280      	movs	r2, #128	; 0x80
	usb.CTRLA.bit.SWRST = 1;
     cea:	702b      	strb	r3, [r5, #0]
	memset(EP, 0, sizeof(EP));
     cec:	0052      	lsls	r2, r2, #1
     cee:	f002 ff34 	bl	3b5a <memset>
	while (usb.SYNCBUSY.bit.SWRST) {}
     cf2:	78ab      	ldrb	r3, [r5, #2]
     cf4:	07db      	lsls	r3, r3, #31
     cf6:	d4fc      	bmi.n	cf2 <_ZN20USBDevice_SAMD21G18x5resetEv+0x1a>
	usb.DESCADD.reg = (uint32_t)(&EP);
     cf8:	626c      	str	r4, [r5, #36]	; 0x24
}
     cfa:	bd70      	pop	{r4, r5, r6, pc}

00000cfc <_ZN20USBDevice_SAMD21G18x9calibrateEv>:
	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
     cfc:	221f      	movs	r2, #31
     cfe:	4b14      	ldr	r3, [pc, #80]	; (d50 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x54>)
void USBDevice_SAMD21G18x::calibrate() {
     d00:	b570      	push	{r4, r5, r6, lr}
	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
     d02:	681b      	ldr	r3, [r3, #0]
     d04:	0b59      	lsrs	r1, r3, #13
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
     d06:	0c9c      	lsrs	r4, r3, #18
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
     d08:	019b      	lsls	r3, r3, #6
	uint32_t pad_transn = (*pad_transn_p & USB_FUSES_TRANSN_Msk) >> USB_FUSES_TRANSN_Pos;
     d0a:	4011      	ands	r1, r2
	uint32_t pad_trim   = (*pad_trim_p   & USB_FUSES_TRIM_Msk  ) >> USB_FUSES_TRIM_Pos;
     d0c:	0f5b      	lsrs	r3, r3, #29
	uint32_t pad_transp = (*pad_transp_p & USB_FUSES_TRANSP_Msk) >> USB_FUSES_TRANSP_Pos;
     d0e:	4022      	ands	r2, r4
	if (pad_transn == 0x1F)  // maximum value (31)
     d10:	291f      	cmp	r1, #31
     d12:	d100      	bne.n	d16 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x1a>
		pad_transn = 5;
     d14:	391a      	subs	r1, #26
	if (pad_transp == 0x1F)  // maximum value (31)
     d16:	2a1f      	cmp	r2, #31
     d18:	d100      	bne.n	d1c <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x20>
		pad_transp = 29;
     d1a:	3a02      	subs	r2, #2
	if (pad_trim == 0x7)     // maximum value (7)
     d1c:	2b07      	cmp	r3, #7
     d1e:	d100      	bne.n	d22 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x26>
		pad_trim = 3;
     d20:	3b04      	subs	r3, #4
	usb.PADCAL.bit.TRANSN = pad_transn;
     d22:	251f      	movs	r5, #31
     d24:	6800      	ldr	r0, [r0, #0]
     d26:	018e      	lsls	r6, r1, #6
     d28:	8d04      	ldrh	r4, [r0, #40]	; 0x28
     d2a:	490a      	ldr	r1, [pc, #40]	; (d54 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x58>)
	usb.PADCAL.bit.TRANSP = pad_transp;
     d2c:	402a      	ands	r2, r5
	usb.PADCAL.bit.TRANSN = pad_transn;
     d2e:	4021      	ands	r1, r4
     d30:	4331      	orrs	r1, r6
     d32:	8501      	strh	r1, [r0, #40]	; 0x28
	usb.PADCAL.bit.TRANSP = pad_transp;
     d34:	8d01      	ldrh	r1, [r0, #40]	; 0x28
     d36:	0014      	movs	r4, r2
     d38:	000a      	movs	r2, r1
     d3a:	43aa      	bics	r2, r5
     d3c:	4322      	orrs	r2, r4
     d3e:	8502      	strh	r2, [r0, #40]	; 0x28
	usb.PADCAL.bit.TRIM   = pad_trim;
     d40:	8d02      	ldrh	r2, [r0, #40]	; 0x28
     d42:	0319      	lsls	r1, r3, #12
     d44:	4b04      	ldr	r3, [pc, #16]	; (d58 <_ZN20USBDevice_SAMD21G18x9calibrateEv+0x5c>)
     d46:	4013      	ands	r3, r2
     d48:	430b      	orrs	r3, r1
     d4a:	8503      	strh	r3, [r0, #40]	; 0x28
}
     d4c:	bd70      	pop	{r4, r5, r6, pc}
     d4e:	46c0      	nop			; (mov r8, r8)
     d50:	00806024 	.word	0x00806024
     d54:	fffff83f 	.word	0xfffff83f
     d58:	ffff8fff 	.word	0xffff8fff

00000d5c <_ZN7__GuardC1Ev>:
     d5c:	f3ef 8310 	mrs	r3, PRIMASK
	__Guard() : primask(__get_PRIMASK()), loops(1) {
     d60:	6003      	str	r3, [r0, #0]
     d62:	2301      	movs	r3, #1
     d64:	6043      	str	r3, [r0, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     d66:	b672      	cpsid	i
	}
     d68:	4770      	bx	lr

00000d6a <_ZN7__GuardD1Ev>:
		if (primask == 0) {
     d6a:	6803      	ldr	r3, [r0, #0]
     d6c:	2b00      	cmp	r3, #0
     d6e:	d102      	bne.n	d76 <_ZN7__GuardD1Ev+0xc>
  __ASM volatile ("cpsie i" : : : "memory");
     d70:	b662      	cpsie	i
  __ASM volatile ("isb 0xF":::"memory");
     d72:	f3bf 8f6f 	isb	sy
	}
     d76:	4770      	bx	lr

00000d78 <_ZNK26DoubleBufferedEPOutHandler9availableEv>:
			release();
		}
	}

	// Returns how many bytes are stored in the buffers
	virtual uint32_t available() const {
     d78:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (current == 0) {
     d7a:	6905      	ldr	r5, [r0, #16]
	virtual uint32_t available() const {
     d7c:	0004      	movs	r4, r0
			bool ready = false;
			synchronized {
     d7e:	4668      	mov	r0, sp
		if (current == 0) {
     d80:	2d00      	cmp	r5, #0
     d82:	d114      	bne.n	dae <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x36>
			synchronized {
     d84:	f7ff ffea 	bl	d5c <_ZN7__GuardC1Ev>
     d88:	9b01      	ldr	r3, [sp, #4]
				ready = ready0;
     d8a:	1d62      	adds	r2, r4, #5
			synchronized {
     d8c:	3b01      	subs	r3, #1
     d8e:	d302      	bcc.n	d96 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x1e>
				ready = ready0;
     d90:	7fd5      	ldrb	r5, [r2, #31]
     d92:	b2ed      	uxtb	r5, r5
     d94:	e7fa      	b.n	d8c <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x14>
			synchronized {
     d96:	4668      	mov	r0, sp
     d98:	9301      	str	r3, [sp, #4]
     d9a:	f7ff ffe6 	bl	d6a <_ZN7__GuardD1Ev>
			}
			return ready ? (last0 - first0) : 0;
     d9e:	2d00      	cmp	r5, #0
     da0:	d101      	bne.n	da6 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x2e>
     da2:	2000      	movs	r0, #0
			synchronized {
				ready = ready1;
			}
			return ready ? (last1 - first1) : 0;
		}
	}
     da4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
			return ready ? (last0 - first0) : 0;
     da6:	6a20      	ldr	r0, [r4, #32]
     da8:	69e3      	ldr	r3, [r4, #28]
			return ready ? (last1 - first1) : 0;
     daa:	1ac0      	subs	r0, r0, r3
     dac:	e7fa      	b.n	da4 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x2c>
			synchronized {
     dae:	f7ff ffd5 	bl	d5c <_ZN7__GuardC1Ev>
				ready = ready1;
     db2:	0022      	movs	r2, r4
			bool ready = false;
     db4:	2500      	movs	r5, #0
     db6:	9b01      	ldr	r3, [sp, #4]
				ready = ready1;
     db8:	3234      	adds	r2, #52	; 0x34
			synchronized {
     dba:	3b01      	subs	r3, #1
     dbc:	d302      	bcc.n	dc4 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x4c>
				ready = ready1;
     dbe:	7815      	ldrb	r5, [r2, #0]
     dc0:	b2ed      	uxtb	r5, r5
			synchronized {
     dc2:	e7fa      	b.n	dba <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x42>
     dc4:	4668      	mov	r0, sp
     dc6:	9301      	str	r3, [sp, #4]
     dc8:	f7ff ffcf 	bl	d6a <_ZN7__GuardD1Ev>
			return ready ? (last1 - first1) : 0;
     dcc:	2d00      	cmp	r5, #0
     dce:	d0e8      	beq.n	da2 <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x2a>
     dd0:	6b20      	ldr	r0, [r4, #48]	; 0x30
     dd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
     dd4:	e7e9      	b.n	daa <_ZNK26DoubleBufferedEPOutHandler9availableEv+0x32>
	...

00000dd8 <_ZN26DoubleBufferedEPOutHandler7releaseEv>:

	void release() {
     dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
     dda:	2501      	movs	r5, #1
		// Release OUT EP
		usbd.epBank0EnableTransferComplete(ep);
     ddc:	6846      	ldr	r6, [r0, #4]
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
     dde:	7a03      	ldrb	r3, [r0, #8]
     de0:	6831      	ldr	r1, [r6, #0]
     de2:	015a      	lsls	r2, r3, #5
     de4:	188c      	adds	r4, r1, r2
     de6:	34ff      	adds	r4, #255	; 0xff
     de8:	7aa7      	ldrb	r7, [r4, #10]
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
     dea:	18b2      	adds	r2, r6, r2
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
     dec:	433d      	orrs	r5, r7
     dee:	72a5      	strb	r5, [r4, #10]
		usbd.epBank0SetMultiPacketSize(ep, size);
     df0:	68c4      	ldr	r4, [r0, #12]
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
     df2:	4d09      	ldr	r5, [pc, #36]	; (e18 <_ZN26DoubleBufferedEPOutHandler7releaseEv+0x40>)
     df4:	6890      	ldr	r0, [r2, #8]
     df6:	04a4      	lsls	r4, r4, #18
     df8:	4028      	ands	r0, r5
     dfa:	0924      	lsrs	r4, r4, #4
     dfc:	4320      	orrs	r0, r4
     dfe:	6090      	str	r0, [r2, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
     e00:	6890      	ldr	r0, [r2, #8]
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
     e02:	3308      	adds	r3, #8
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
     e04:	0b80      	lsrs	r0, r0, #14
     e06:	0380      	lsls	r0, r0, #14
     e08:	6090      	str	r0, [r2, #8]
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
     e0a:	2240      	movs	r2, #64	; 0x40
     e0c:	015b      	lsls	r3, r3, #5
     e0e:	18cb      	adds	r3, r1, r3
     e10:	7919      	ldrb	r1, [r3, #4]
     e12:	430a      	orrs	r2, r1
     e14:	711a      	strb	r2, [r3, #4]
		usbd.epBank0SetByteCount(ep, 0);
		usbd.epBank0ResetReady(ep);
	}
     e16:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e18:	f0003fff 	.word	0xf0003fff

00000e1c <_ZN26DoubleBufferedEPOutHandler4recvEPvm>:
	virtual uint32_t recv(void *_data, uint32_t len)
     e1c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
		if (current == 0) {
     e1e:	6903      	ldr	r3, [r0, #16]
	virtual uint32_t recv(void *_data, uint32_t len)
     e20:	0004      	movs	r4, r0
     e22:	000e      	movs	r6, r1
     e24:	0017      	movs	r7, r2
			synchronized {
     e26:	4668      	mov	r0, sp
		if (current == 0) {
     e28:	2b00      	cmp	r3, #0
     e2a:	d13d      	bne.n	ea8 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x8c>
			synchronized {
     e2c:	f7ff ff96 	bl	d5c <_ZN7__GuardC1Ev>
     e30:	9b01      	ldr	r3, [sp, #4]
				if (!ready0) {
     e32:	1d61      	adds	r1, r4, #5
     e34:	3b01      	subs	r3, #1
			synchronized {
     e36:	1c5a      	adds	r2, r3, #1
     e38:	d00c      	beq.n	e54 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x38>
				if (!ready0) {
     e3a:	7fcd      	ldrb	r5, [r1, #31]
     e3c:	1e5a      	subs	r2, r3, #1
     e3e:	b2ed      	uxtb	r5, r5
     e40:	2d00      	cmp	r5, #0
     e42:	d105      	bne.n	e50 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x34>
				synchronized {
     e44:	4668      	mov	r0, sp
     e46:	9301      	str	r3, [sp, #4]
     e48:	f7ff ff8f 	bl	d6a <_ZN7__GuardD1Ev>
	}
     e4c:	0028      	movs	r0, r5
     e4e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
     e50:	0013      	movs	r3, r2
     e52:	e7f0      	b.n	e36 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x1a>
			synchronized {
     e54:	4668      	mov	r0, sp
     e56:	9301      	str	r3, [sp, #4]
			for (i=0; i<len && first0 < last0; i++) {
     e58:	2500      	movs	r5, #0
			synchronized {
     e5a:	f7ff ff86 	bl	d6a <_ZN7__GuardD1Ev>
     e5e:	69e3      	ldr	r3, [r4, #28]
			for (i=0; i<len && first0 < last0; i++) {
     e60:	42af      	cmp	r7, r5
     e62:	d002      	beq.n	e6a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x4e>
     e64:	6a22      	ldr	r2, [r4, #32]
     e66:	4293      	cmp	r3, r2
     e68:	d357      	bcc.n	f1a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xfe>
			if (first0 == last0) {
     e6a:	6a22      	ldr	r2, [r4, #32]
     e6c:	4293      	cmp	r3, r2
     e6e:	d1ed      	bne.n	e4c <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x30>
				first0 = 0;
     e70:	2300      	movs	r3, #0
     e72:	61e3      	str	r3, [r4, #28]
				current = 1;
     e74:	3301      	adds	r3, #1
     e76:	6123      	str	r3, [r4, #16]
				synchronized {
     e78:	4668      	mov	r0, sp
     e7a:	f7ff ff6f 	bl	d5c <_ZN7__GuardC1Ev>
					if (notify) {
     e7e:	0022      	movs	r2, r4
					ready0 = false;
     e80:	2100      	movs	r1, #0
     e82:	9b01      	ldr	r3, [sp, #4]
     e84:	1d67      	adds	r7, r4, #5
     e86:	3b01      	subs	r3, #1
					if (notify) {
     e88:	3235      	adds	r2, #53	; 0x35
				synchronized {
     e8a:	1c58      	adds	r0, r3, #1
     e8c:	d0da      	beq.n	e44 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x28>
					ready0 = false;
     e8e:	77f9      	strb	r1, [r7, #31]
					if (notify) {
     e90:	7810      	ldrb	r0, [r2, #0]
     e92:	1e5e      	subs	r6, r3, #1
     e94:	2800      	cmp	r0, #0
     e96:	d005      	beq.n	ea4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x88>
						notify = false;
     e98:	7011      	strb	r1, [r2, #0]
						release();
     e9a:	0020      	movs	r0, r4
     e9c:	9301      	str	r3, [sp, #4]
     e9e:	f7ff ff9b 	bl	dd8 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
     ea2:	e7ec      	b.n	e7e <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x62>
					if (notify) {
     ea4:	0033      	movs	r3, r6
     ea6:	e7f0      	b.n	e8a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x6e>
			synchronized {
     ea8:	f7ff ff58 	bl	d5c <_ZN7__GuardC1Ev>
				if (!ready1) {
     eac:	0021      	movs	r1, r4
     eae:	9b01      	ldr	r3, [sp, #4]
     eb0:	3134      	adds	r1, #52	; 0x34
     eb2:	3b01      	subs	r3, #1
			synchronized {
     eb4:	1c5a      	adds	r2, r3, #1
     eb6:	d006      	beq.n	ec6 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xaa>
				if (!ready1) {
     eb8:	780d      	ldrb	r5, [r1, #0]
     eba:	1e5a      	subs	r2, r3, #1
     ebc:	b2ed      	uxtb	r5, r5
     ebe:	2d00      	cmp	r5, #0
     ec0:	d0c0      	beq.n	e44 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x28>
     ec2:	0013      	movs	r3, r2
     ec4:	e7f6      	b.n	eb4 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x98>
			synchronized {
     ec6:	4668      	mov	r0, sp
     ec8:	9301      	str	r3, [sp, #4]
			for (i=0; i<len && first1 < last1; i++) {
     eca:	2500      	movs	r5, #0
			synchronized {
     ecc:	f7ff ff4d 	bl	d6a <_ZN7__GuardD1Ev>
     ed0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			for (i=0; i<len && first1 < last1; i++) {
     ed2:	42bd      	cmp	r5, r7
     ed4:	d002      	beq.n	edc <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xc0>
     ed6:	6b22      	ldr	r2, [r4, #48]	; 0x30
     ed8:	4293      	cmp	r3, r2
     eda:	d326      	bcc.n	f2a <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x10e>
			if (first1 == last1) {
     edc:	6b22      	ldr	r2, [r4, #48]	; 0x30
     ede:	4293      	cmp	r3, r2
     ee0:	d1b4      	bne.n	e4c <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x30>
				first1 = 0;
     ee2:	2300      	movs	r3, #0
				synchronized {
     ee4:	4668      	mov	r0, sp
				first1 = 0;
     ee6:	62e3      	str	r3, [r4, #44]	; 0x2c
				current = 0;
     ee8:	6123      	str	r3, [r4, #16]
				synchronized {
     eea:	f7ff ff37 	bl	d5c <_ZN7__GuardC1Ev>
					ready1 = false;
     eee:	0027      	movs	r7, r4
					if (notify) {
     ef0:	0022      	movs	r2, r4
					ready1 = false;
     ef2:	2100      	movs	r1, #0
     ef4:	9b01      	ldr	r3, [sp, #4]
     ef6:	3734      	adds	r7, #52	; 0x34
     ef8:	3b01      	subs	r3, #1
					if (notify) {
     efa:	3235      	adds	r2, #53	; 0x35
				synchronized {
     efc:	1c58      	adds	r0, r3, #1
     efe:	d0a1      	beq.n	e44 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x28>
					ready1 = false;
     f00:	7039      	strb	r1, [r7, #0]
					if (notify) {
     f02:	7810      	ldrb	r0, [r2, #0]
     f04:	1e5e      	subs	r6, r3, #1
     f06:	2800      	cmp	r0, #0
     f08:	d005      	beq.n	f16 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xfa>
						notify = false;
     f0a:	7011      	strb	r1, [r2, #0]
						release();
     f0c:	0020      	movs	r0, r4
     f0e:	9301      	str	r3, [sp, #4]
     f10:	f7ff ff62 	bl	dd8 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
     f14:	e7eb      	b.n	eee <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xd2>
     f16:	0033      	movs	r3, r6
     f18:	e7f0      	b.n	efc <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xe0>
				data[i] = data0[first0++];
     f1a:	1c5a      	adds	r2, r3, #1
     f1c:	61e2      	str	r2, [r4, #28]
     f1e:	69a2      	ldr	r2, [r4, #24]
     f20:	18d3      	adds	r3, r2, r3
     f22:	781b      	ldrb	r3, [r3, #0]
     f24:	5573      	strb	r3, [r6, r5]
			for (i=0; i<len && first0 < last0; i++) {
     f26:	3501      	adds	r5, #1
     f28:	e799      	b.n	e5e <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0x42>
				data[i] = data1[first1++];
     f2a:	1c5a      	adds	r2, r3, #1
     f2c:	62e2      	str	r2, [r4, #44]	; 0x2c
     f2e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
     f30:	18d3      	adds	r3, r2, r3
     f32:	781b      	ldrb	r3, [r3, #0]
     f34:	5573      	strb	r3, [r6, r5]
			for (i=0; i<len && first1 < last1; i++) {
     f36:	3501      	adds	r5, #1
     f38:	e7ca      	b.n	ed0 <_ZN26DoubleBufferedEPOutHandler4recvEPvm+0xb4>

00000f3a <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv>:
	virtual void handleEndpoint()
     f3a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
     f3c:	7a02      	ldrb	r2, [r0, #8]
		if (usbd.epBank0IsTransferComplete(ep))
     f3e:	6843      	ldr	r3, [r0, #4]
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
     f40:	0011      	movs	r1, r2
	virtual void handleEndpoint()
     f42:	0004      	movs	r4, r0
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
     f44:	3108      	adds	r1, #8
     f46:	6818      	ldr	r0, [r3, #0]
     f48:	0149      	lsls	r1, r1, #5
     f4a:	1841      	adds	r1, r0, r1
     f4c:	79c8      	ldrb	r0, [r1, #7]
		if (usbd.epBank0IsTransferComplete(ep))
     f4e:	07c0      	lsls	r0, r0, #31
     f50:	d527      	bpl.n	fa2 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x68>
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
     f52:	2501      	movs	r5, #1
     f54:	0152      	lsls	r2, r2, #5
     f56:	71cd      	strb	r5, [r1, #7]
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
     f58:	189b      	adds	r3, r3, r2
     f5a:	689a      	ldr	r2, [r3, #8]
			if (incoming == 0) {
     f5c:	6961      	ldr	r1, [r4, #20]
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
     f5e:	0492      	lsls	r2, r2, #18
     f60:	0c92      	lsrs	r2, r2, #18
			if (incoming == 0) {
     f62:	2900      	cmp	r1, #0
     f64:	d121      	bne.n	faa <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x70>
				last0 = usbd.epBank0ByteCount(ep);
     f66:	6222      	str	r2, [r4, #32]
				if (last0 != 0) {
     f68:	6a22      	ldr	r2, [r4, #32]
     f6a:	2a00      	cmp	r2, #0
     f6c:	d03e      	beq.n	fec <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb2>
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
     f6e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
					incoming = 1;
     f70:	6165      	str	r5, [r4, #20]
					synchronized {
     f72:	4668      	mov	r0, sp
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
     f74:	605a      	str	r2, [r3, #4]
					synchronized {
     f76:	f7ff fef1 	bl	d5c <_ZN7__GuardC1Ev>
						if (ready1) {
     f7a:	0027      	movs	r7, r4
     f7c:	0021      	movs	r1, r4
     f7e:	9b01      	ldr	r3, [sp, #4]
						ready0 = true;
     f80:	1d66      	adds	r6, r4, #5
     f82:	3b01      	subs	r3, #1
						if (ready1) {
     f84:	3734      	adds	r7, #52	; 0x34
     f86:	3135      	adds	r1, #53	; 0x35
					synchronized {
     f88:	1c5a      	adds	r2, r3, #1
     f8a:	d02b      	beq.n	fe4 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xaa>
						ready0 = true;
     f8c:	77f5      	strb	r5, [r6, #31]
						if (ready1) {
     f8e:	783a      	ldrb	r2, [r7, #0]
     f90:	1e58      	subs	r0, r3, #1
     f92:	b2d2      	uxtb	r2, r2
     f94:	2a00      	cmp	r2, #0
     f96:	d005      	beq.n	fa4 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x6a>
     f98:	9301      	str	r3, [sp, #4]
							return;
     f9a:	4668      	mov	r0, sp
							notify = true;
     f9c:	700d      	strb	r5, [r1, #0]
							return;
     f9e:	f7ff fee4 	bl	d6a <_ZN7__GuardD1Ev>
	}
     fa2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
						notify = false;
     fa4:	700a      	strb	r2, [r1, #0]
					synchronized {
     fa6:	0003      	movs	r3, r0
     fa8:	e7ee      	b.n	f88 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x4e>
				last1 = usbd.epBank0ByteCount(ep);
     faa:	6322      	str	r2, [r4, #48]	; 0x30
				if (last1 != 0) {
     fac:	6b22      	ldr	r2, [r4, #48]	; 0x30
     fae:	2a00      	cmp	r2, #0
     fb0:	d01c      	beq.n	fec <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xb2>
					incoming = 0;
     fb2:	2200      	movs	r2, #0
     fb4:	6162      	str	r2, [r4, #20]
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
     fb6:	69a2      	ldr	r2, [r4, #24]
					synchronized {
     fb8:	4668      	mov	r0, sp
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
     fba:	605a      	str	r2, [r3, #4]
					synchronized {
     fbc:	f7ff fece 	bl	d5c <_ZN7__GuardC1Ev>
						ready1 = true;
     fc0:	0026      	movs	r6, r4
     fc2:	0021      	movs	r1, r4
     fc4:	9b01      	ldr	r3, [sp, #4]
     fc6:	3634      	adds	r6, #52	; 0x34
     fc8:	3b01      	subs	r3, #1
						if (ready0) {
     fca:	1d67      	adds	r7, r4, #5
     fcc:	3135      	adds	r1, #53	; 0x35
					synchronized {
     fce:	1c5a      	adds	r2, r3, #1
     fd0:	d008      	beq.n	fe4 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0xaa>
						ready1 = true;
     fd2:	7035      	strb	r5, [r6, #0]
						if (ready0) {
     fd4:	7ffa      	ldrb	r2, [r7, #31]
     fd6:	1e58      	subs	r0, r3, #1
     fd8:	b2d2      	uxtb	r2, r2
     fda:	2a00      	cmp	r2, #0
     fdc:	d1dc      	bne.n	f98 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x5e>
						notify = false;
     fde:	700a      	strb	r2, [r1, #0]
					synchronized {
     fe0:	0003      	movs	r3, r0
     fe2:	e7f4      	b.n	fce <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x94>
     fe4:	4668      	mov	r0, sp
     fe6:	9301      	str	r3, [sp, #4]
     fe8:	f7ff febf 	bl	d6a <_ZN7__GuardD1Ev>
			release();
     fec:	0020      	movs	r0, r4
     fee:	f7ff fef3 	bl	dd8 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
     ff2:	e7d6      	b.n	fa2 <_ZN26DoubleBufferedEPOutHandler14handleEndpointEv+0x68>

00000ff4 <_ZN14USBDeviceClass14SendInterfacesEPm>:
{
     ff4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t interfaces = 0;
     ff6:	466b      	mov	r3, sp
     ff8:	1ddc      	adds	r4, r3, #7
     ffa:	2300      	movs	r3, #0
{
     ffc:	000d      	movs	r5, r1
	total[0] += CDC_GetInterface(&interfaces);
     ffe:	0020      	movs	r0, r4
	uint8_t interfaces = 0;
    1000:	7023      	strb	r3, [r4, #0]
	total[0] += CDC_GetInterface(&interfaces);
    1002:	f001 ff3f 	bl	2e84 <_Z16CDC_GetInterfacePh>
    1006:	682b      	ldr	r3, [r5, #0]
    1008:	1818      	adds	r0, r3, r0
    100a:	6028      	str	r0, [r5, #0]
	total[0] += PluggableUSB().getInterface(&interfaces);
    100c:	f001 ffde 	bl	2fcc <_Z12PluggableUSBv>
    1010:	0021      	movs	r1, r4
    1012:	f001 ff97 	bl	2f44 <_ZN13PluggableUSB_12getInterfaceEPh>
    1016:	682b      	ldr	r3, [r5, #0]
    1018:	1818      	adds	r0, r3, r0
    101a:	6028      	str	r0, [r5, #0]
	return interfaces;
    101c:	7820      	ldrb	r0, [r4, #0]
}
    101e:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

00001020 <_ZN14USBDeviceClass14handleEndpointEh>:
	if (ep == CDC_ENDPOINT_IN)
    1020:	2903      	cmp	r1, #3
    1022:	d10e      	bne.n	1042 <_ZN14USBDeviceClass14handleEndpointEh+0x22>
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    1024:	2280      	movs	r2, #128	; 0x80
    1026:	4b0e      	ldr	r3, [pc, #56]	; (1060 <_ZN14USBDeviceClass14handleEndpointEh+0x40>)
    1028:	3162      	adds	r1, #98	; 0x62
    102a:	681b      	ldr	r3, [r3, #0]
    102c:	31ff      	adds	r1, #255	; 0xff
    102e:	5c58      	ldrb	r0, [r3, r1]
    1030:	4252      	negs	r2, r2
    1032:	4302      	orrs	r2, r0
    1034:	545a      	strb	r2, [r3, r1]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    1036:	2268      	movs	r2, #104	; 0x68
    1038:	3963      	subs	r1, #99	; 0x63
    103a:	39ff      	subs	r1, #255	; 0xff
    103c:	32ff      	adds	r2, #255	; 0xff
    103e:	5499      	strb	r1, [r3, r2]
}
    1040:	4770      	bx	lr
	if (ep == CDC_ENDPOINT_ACM)
    1042:	2901      	cmp	r1, #1
    1044:	d1fc      	bne.n	1040 <_ZN14USBDeviceClass14handleEndpointEh+0x20>
	inline void epBank1ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK1RDY = 1; }
    1046:	2280      	movs	r2, #128	; 0x80
    1048:	4b05      	ldr	r3, [pc, #20]	; (1060 <_ZN14USBDeviceClass14handleEndpointEh+0x40>)
    104a:	3124      	adds	r1, #36	; 0x24
    104c:	681b      	ldr	r3, [r3, #0]
    104e:	31ff      	adds	r1, #255	; 0xff
    1050:	5c58      	ldrb	r0, [r3, r1]
    1052:	4252      	negs	r2, r2
    1054:	4302      	orrs	r2, r0
    1056:	545a      	strb	r2, [r3, r1]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    1058:	3923      	subs	r1, #35	; 0x23
    105a:	39ff      	subs	r1, #255	; 0xff
    105c:	2228      	movs	r2, #40	; 0x28
    105e:	e7ed      	b.n	103c <_ZN14USBDeviceClass14handleEndpointEh+0x1c>
    1060:	200005ec 	.word	0x200005ec

00001064 <_ZN14USBDeviceClass4initEv>:
{
    1064:	b570      	push	{r4, r5, r6, lr}
	txLEDPulse = 0;
    1066:	2500      	movs	r5, #0
    1068:	4b2f      	ldr	r3, [pc, #188]	; (1128 <_ZN14USBDeviceClass4initEv+0xc4>)
	pinMode(PIN_LED_TXL, OUTPUT);
    106a:	2101      	movs	r1, #1
{
    106c:	0004      	movs	r4, r0
	pinMode(PIN_LED_TXL, OUTPUT);
    106e:	201f      	movs	r0, #31
	txLEDPulse = 0;
    1070:	701d      	strb	r5, [r3, #0]
	pinMode(PIN_LED_TXL, OUTPUT);
    1072:	f000 fe13 	bl	1c9c <pinMode>
	digitalWrite(PIN_LED_TXL, HIGH);
    1076:	2101      	movs	r1, #1
    1078:	201f      	movs	r0, #31
    107a:	f000 fe5b 	bl	1d34 <digitalWrite>
	rxLEDPulse = 0;
    107e:	4b2b      	ldr	r3, [pc, #172]	; (112c <_ZN14USBDeviceClass4initEv+0xc8>)
	pinMode(PIN_LED_RXL, OUTPUT);
    1080:	2101      	movs	r1, #1
    1082:	201e      	movs	r0, #30
	rxLEDPulse = 0;
    1084:	701d      	strb	r5, [r3, #0]
	pinMode(PIN_LED_RXL, OUTPUT);
    1086:	f000 fe09 	bl	1c9c <pinMode>
	digitalWrite(PIN_LED_RXL, HIGH);
    108a:	2101      	movs	r1, #1
    108c:	201e      	movs	r0, #30
    108e:	f000 fe51 	bl	1d34 <digitalWrite>
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
    1092:	2320      	movs	r3, #32
    1094:	4a26      	ldr	r2, [pc, #152]	; (1130 <_ZN14USBDeviceClass4initEv+0xcc>)
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
    1096:	200f      	movs	r0, #15
	PM->APBBMASK.reg |= PM_APBBMASK_USB;
    1098:	69d1      	ldr	r1, [r2, #28]
    109a:	430b      	orrs	r3, r1
    109c:	61d3      	str	r3, [r2, #28]
	PORT->Group[0].PINCFG[PIN_PA24G_USB_DM].bit.PMUXEN = 1;
    109e:	2201      	movs	r2, #1
    10a0:	4924      	ldr	r1, [pc, #144]	; (1134 <_ZN14USBDeviceClass4initEv+0xd0>)
    10a2:	780b      	ldrb	r3, [r1, #0]
    10a4:	4313      	orrs	r3, r2
    10a6:	700b      	strb	r3, [r1, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg &= ~(0xF << (4 * (PIN_PA24G_USB_DM & 0x01u)));
    10a8:	4b23      	ldr	r3, [pc, #140]	; (1138 <_ZN14USBDeviceClass4initEv+0xd4>)
    10aa:	7819      	ldrb	r1, [r3, #0]
    10ac:	4381      	bics	r1, r0
    10ae:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA24G_USB_DM/2].reg |= MUX_PA24G_USB_DM << (4 * (PIN_PA24G_USB_DM & 0x01u));
    10b0:	2106      	movs	r1, #6
    10b2:	781d      	ldrb	r5, [r3, #0]
    10b4:	4329      	orrs	r1, r5
    10b6:	7019      	strb	r1, [r3, #0]
	PORT->Group[0].PINCFG[PIN_PA25G_USB_DP].bit.PMUXEN = 1;
    10b8:	4920      	ldr	r1, [pc, #128]	; (113c <_ZN14USBDeviceClass4initEv+0xd8>)
    10ba:	780d      	ldrb	r5, [r1, #0]
    10bc:	432a      	orrs	r2, r5
    10be:	700a      	strb	r2, [r1, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg &= ~(0xF << (4 * (PIN_PA25G_USB_DP & 0x01u)));
    10c0:	781a      	ldrb	r2, [r3, #0]
    10c2:	4002      	ands	r2, r0
    10c4:	701a      	strb	r2, [r3, #0]
	PORT->Group[0].PMUX[PIN_PA25G_USB_DP/2].reg |= MUX_PA25G_USB_DP << (4 * (PIN_PA25G_USB_DP & 0x01u));
    10c6:	2260      	movs	r2, #96	; 0x60
    10c8:	7819      	ldrb	r1, [r3, #0]
    10ca:	430a      	orrs	r2, r1
    10cc:	701a      	strb	r2, [r3, #0]
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(6)     | // Generic Clock Multiplexer 6
    10ce:	4b1c      	ldr	r3, [pc, #112]	; (1140 <_ZN14USBDeviceClass4initEv+0xdc>)
    10d0:	4a1c      	ldr	r2, [pc, #112]	; (1144 <_ZN14USBDeviceClass4initEv+0xe0>)
    10d2:	805a      	strh	r2, [r3, #2]
	while (GCLK->STATUS.bit.SYNCBUSY)
    10d4:	785a      	ldrb	r2, [r3, #1]
    10d6:	09d2      	lsrs	r2, r2, #7
    10d8:	d1fc      	bne.n	10d4 <_ZN14USBDeviceClass4initEv+0x70>
	USB_SetHandler(&UDD_Handler);
    10da:	481b      	ldr	r0, [pc, #108]	; (1148 <_ZN14USBDeviceClass4initEv+0xe4>)
    10dc:	f7ff f978 	bl	3d0 <USB_SetHandler>
	usbd.reset();
    10e0:	4d1a      	ldr	r5, [pc, #104]	; (114c <_ZN14USBDeviceClass4initEv+0xe8>)
    10e2:	0028      	movs	r0, r5
    10e4:	f7ff fdf8 	bl	cd8 <_ZN20USBDevice_SAMD21G18x5resetEv>
	usbd.calibrate();
    10e8:	0028      	movs	r0, r5
    10ea:	f7ff fe07 	bl	cfc <_ZN20USBDevice_SAMD21G18x9calibrateEv>
	inline void setUSBDeviceMode() { usb.CTRLA.bit.MODE = USB_CTRLA_MODE_DEVICE_Val; }
    10ee:	217f      	movs	r1, #127	; 0x7f
    10f0:	682b      	ldr	r3, [r5, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    10f2:	20c1      	movs	r0, #193	; 0xc1
    10f4:	781a      	ldrb	r2, [r3, #0]
    10f6:	0080      	lsls	r0, r0, #2
    10f8:	400a      	ands	r2, r1
    10fa:	701a      	strb	r2, [r3, #0]
	inline void runInStandby()   { usb.CTRLA.bit.RUNSTDBY = 1; }
    10fc:	2204      	movs	r2, #4
    10fe:	7819      	ldrb	r1, [r3, #0]
    1100:	430a      	orrs	r2, r1
	inline void setFullSpeed()       { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;   }
    1102:	210c      	movs	r1, #12
	inline void runInStandby()   { usb.CTRLA.bit.RUNSTDBY = 1; }
    1104:	701a      	strb	r2, [r3, #0]
	inline void setFullSpeed()       { usb.CTRLB.bit.SPDCONF = USB_DEVICE_CTRLB_SPDCONF_FS_Val;   }
    1106:	891a      	ldrh	r2, [r3, #8]
    1108:	438a      	bics	r2, r1
    110a:	4911      	ldr	r1, [pc, #68]	; (1150 <_ZN14USBDeviceClass4initEv+0xec>)
    110c:	811a      	strh	r2, [r3, #8]
    110e:	580a      	ldr	r2, [r1, r0]
    1110:	0212      	lsls	r2, r2, #8
    1112:	0a12      	lsrs	r2, r2, #8
    1114:	500a      	str	r2, [r1, r0]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1116:	2280      	movs	r2, #128	; 0x80
    1118:	600a      	str	r2, [r1, #0]
	inline void enable()  { usb.CTRLA.bit.ENABLE = 1; }
    111a:	7819      	ldrb	r1, [r3, #0]
    111c:	3a7e      	subs	r2, #126	; 0x7e
    111e:	430a      	orrs	r2, r1
    1120:	701a      	strb	r2, [r3, #0]
	initialized = true;
    1122:	2301      	movs	r3, #1
    1124:	7023      	strb	r3, [r4, #0]
}
    1126:	bd70      	pop	{r4, r5, r6, pc}
    1128:	20000155 	.word	0x20000155
    112c:	20000154 	.word	0x20000154
    1130:	40000400 	.word	0x40000400
    1134:	41004458 	.word	0x41004458
    1138:	4100443c 	.word	0x4100443c
    113c:	41004459 	.word	0x41004459
    1140:	40000c00 	.word	0x40000c00
    1144:	00004006 	.word	0x00004006
    1148:	00001b29 	.word	0x00001b29
    114c:	200005ec 	.word	0x200005ec
    1150:	e000e100 	.word	0xe000e100

00001154 <_ZN14USBDeviceClass6attachEv>:
	if (!initialized)
    1154:	7800      	ldrb	r0, [r0, #0]
    1156:	2800      	cmp	r0, #0
    1158:	d010      	beq.n	117c <_ZN14USBDeviceClass6attachEv+0x28>
	inline void attach() { usb.CTRLB.bit.DETACH = 0; }
    115a:	2101      	movs	r1, #1
    115c:	4b08      	ldr	r3, [pc, #32]	; (1180 <_ZN14USBDeviceClass6attachEv+0x2c>)
    115e:	681b      	ldr	r3, [r3, #0]
    1160:	891a      	ldrh	r2, [r3, #8]
    1162:	438a      	bics	r2, r1
    1164:	811a      	strh	r2, [r3, #8]
	inline void enableEndOfResetInterrupt()    { usb.INTENSET.bit.EORST = 1; }
    1166:	2208      	movs	r2, #8
    1168:	8b19      	ldrh	r1, [r3, #24]
    116a:	430a      	orrs	r2, r1
    116c:	831a      	strh	r2, [r3, #24]
	inline void enableStartOfFrameInterrupt()  { usb.INTENSET.bit.SOF = 1; }
    116e:	2204      	movs	r2, #4
    1170:	8b19      	ldrh	r1, [r3, #24]
    1172:	430a      	orrs	r2, r1
    1174:	831a      	strh	r2, [r3, #24]
	_usbConfiguration = 0;
    1176:	2200      	movs	r2, #0
    1178:	4b02      	ldr	r3, [pc, #8]	; (1184 <_ZN14USBDeviceClass6attachEv+0x30>)
    117a:	601a      	str	r2, [r3, #0]
}
    117c:	4770      	bx	lr
    117e:	46c0      	nop			; (mov r8, r8)
    1180:	200005ec 	.word	0x200005ec
    1184:	200005e4 	.word	0x200005e4

00001188 <_ZN14USBDeviceClass10setAddressEm>:
{
    1188:	b510      	push	{r4, lr}
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    118a:	4a0f      	ldr	r2, [pc, #60]	; (11c8 <_ZN14USBDeviceClass10setAddressEm+0x40>)
    118c:	6993      	ldr	r3, [r2, #24]
    118e:	0b9b      	lsrs	r3, r3, #14
    1190:	039b      	lsls	r3, r3, #14
    1192:	6193      	str	r3, [r2, #24]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    1194:	6813      	ldr	r3, [r2, #0]
    1196:	2202      	movs	r2, #2
    1198:	33ff      	adds	r3, #255	; 0xff
    119a:	721a      	strb	r2, [r3, #8]
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    119c:	7998      	ldrb	r0, [r3, #6]
    119e:	3a82      	subs	r2, #130	; 0x82
    11a0:	4302      	orrs	r2, r0
    11a2:	719a      	strb	r2, [r3, #6]
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    11a4:	7a1a      	ldrb	r2, [r3, #8]
	while (!usbd.epBank1IsTransferComplete(0)) {}
    11a6:	0792      	lsls	r2, r2, #30
    11a8:	d5fc      	bpl.n	11a4 <_ZN14USBDeviceClass10setAddressEm+0x1c>
	USB->DEVICE.DADD.bit.DADD = addr; // Address
    11aa:	247f      	movs	r4, #127	; 0x7f
    11ac:	4a07      	ldr	r2, [pc, #28]	; (11cc <_ZN14USBDeviceClass10setAddressEm+0x44>)
    11ae:	4021      	ands	r1, r4
    11b0:	7a93      	ldrb	r3, [r2, #10]
    11b2:	0008      	movs	r0, r1
    11b4:	43a3      	bics	r3, r4
    11b6:	0019      	movs	r1, r3
	USB->DEVICE.DADD.bit.ADDEN = 1; // Enable
    11b8:	2380      	movs	r3, #128	; 0x80
	USB->DEVICE.DADD.bit.DADD = addr; // Address
    11ba:	4301      	orrs	r1, r0
    11bc:	7291      	strb	r1, [r2, #10]
	USB->DEVICE.DADD.bit.ADDEN = 1; // Enable
    11be:	7a91      	ldrb	r1, [r2, #10]
    11c0:	425b      	negs	r3, r3
    11c2:	430b      	orrs	r3, r1
    11c4:	7293      	strb	r3, [r2, #10]
}
    11c6:	bd10      	pop	{r4, pc}
    11c8:	200005ec 	.word	0x200005ec
    11cc:	41005000 	.word	0x41005000

000011d0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>:
{
    11d0:	b510      	push	{r4, lr}
	if (CDC_ACM_INTERFACE == i)
    11d2:	790b      	ldrb	r3, [r1, #4]
{
    11d4:	000c      	movs	r4, r1
	if (CDC_ACM_INTERFACE == i)
    11d6:	2b00      	cmp	r3, #0
    11d8:	d10c      	bne.n	11f4 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x24>
		if (CDC_Setup(setup) == false) {
    11da:	0008      	movs	r0, r1
    11dc:	f001 fe60 	bl	2ea0 <_Z9CDC_SetupR8USBSetup>
    11e0:	2800      	cmp	r0, #0
    11e2:	d001      	beq.n	11e8 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x18>
		return true;
    11e4:	2001      	movs	r0, #1
}
    11e6:	bd10      	pop	{r4, pc}
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    11e8:	4a09      	ldr	r2, [pc, #36]	; (1210 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x40>)
    11ea:	6993      	ldr	r3, [r2, #24]
    11ec:	0b9b      	lsrs	r3, r3, #14
    11ee:	039b      	lsls	r3, r3, #14
    11f0:	6193      	str	r3, [r2, #24]
    11f2:	e7f7      	b.n	11e4 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x14>
	bool ret = PluggableUSB().setup(setup);
    11f4:	f001 feea 	bl	2fcc <_Z12PluggableUSBv>
    11f8:	0021      	movs	r1, r4
    11fa:	f001 fed6 	bl	2faa <_ZN13PluggableUSB_5setupER8USBSetup>
	if ( ret == false) {
    11fe:	2800      	cmp	r0, #0
    1200:	d1f0      	bne.n	11e4 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x14>
    1202:	4a03      	ldr	r2, [pc, #12]	; (1210 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x40>)
    1204:	6993      	ldr	r3, [r2, #24]
    1206:	0b9b      	lsrs	r3, r3, #14
    1208:	039b      	lsls	r3, r3, #14
    120a:	6193      	str	r3, [r2, #24]
    120c:	e7eb      	b.n	11e6 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup+0x16>
    120e:	46c0      	nop			; (mov r8, r8)
    1210:	200005ec 	.word	0x200005ec

00001214 <_ZN14USBDeviceClass6initEPEmm>:
{
    1214:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    1216:	000d      	movs	r5, r1
	if (config == (USB_ENDPOINT_TYPE_INTERRUPT | USB_ENDPOINT_IN(0)))
    1218:	2a83      	cmp	r2, #131	; 0x83
    121a:	d119      	bne.n	1250 <_ZN14USBDeviceClass6initEPEmm+0x3c>
	inline void epBank1SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    121c:	b2cb      	uxtb	r3, r1
    121e:	4c33      	ldr	r4, [pc, #204]	; (12ec <_ZN14USBDeviceClass6initEPEmm+0xd8>)
    1220:	015a      	lsls	r2, r3, #5
    1222:	18a2      	adds	r2, r4, r2
    1224:	6991      	ldr	r1, [r2, #24]
    1226:	4832      	ldr	r0, [pc, #200]	; (12f0 <_ZN14USBDeviceClass6initEPEmm+0xdc>)
		usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
    1228:	01ad      	lsls	r5, r5, #6
    122a:	4008      	ands	r0, r1
    122c:	21c0      	movs	r1, #192	; 0xc0
    122e:	0589      	lsls	r1, r1, #22
    1230:	4301      	orrs	r1, r0
    1232:	6191      	str	r1, [r2, #24]
    1234:	492f      	ldr	r1, [pc, #188]	; (12f4 <_ZN14USBDeviceClass6initEPEmm+0xe0>)
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    1236:	6820      	ldr	r0, [r4, #0]
    1238:	194d      	adds	r5, r1, r5
    123a:	2170      	movs	r1, #112	; 0x70
    123c:	3308      	adds	r3, #8
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    123e:	6155      	str	r5, [r2, #20]
	inline void epBank1SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE1 = type; }
    1240:	015b      	lsls	r3, r3, #5
    1242:	5c1a      	ldrb	r2, [r3, r0]
    1244:	438a      	bics	r2, r1
    1246:	0011      	movs	r1, r2
    1248:	2240      	movs	r2, #64	; 0x40
    124a:	430a      	orrs	r2, r1
    124c:	541a      	strb	r2, [r3, r0]
}
    124e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	else if (config == (USB_ENDPOINT_TYPE_BULK | USB_ENDPOINT_OUT(0)))
    1250:	2a02      	cmp	r2, #2
    1252:	d145      	bne.n	12e0 <_ZN14USBDeviceClass6initEPEmm+0xcc>
		if (epHandlers[ep] != NULL) {
    1254:	4a28      	ldr	r2, [pc, #160]	; (12f8 <_ZN14USBDeviceClass6initEPEmm+0xe4>)
    1256:	008b      	lsls	r3, r1, #2
    1258:	5898      	ldr	r0, [r3, r2]
    125a:	2800      	cmp	r0, #0
    125c:	d002      	beq.n	1264 <_ZN14USBDeviceClass6initEPEmm+0x50>
			delete (DoubleBufferedEPOutHandler*)epHandlers[ep];
    125e:	6803      	ldr	r3, [r0, #0]
    1260:	691b      	ldr	r3, [r3, #16]
    1262:	4798      	blx	r3
		epHandlers[ep] = new DoubleBufferedEPOutHandler(usbd, ep, 256);
    1264:	2038      	movs	r0, #56	; 0x38
    1266:	f001 fcb5 	bl	2bd4 <_Znwj>
		notify(false)
    126a:	4b24      	ldr	r3, [pc, #144]	; (12fc <_ZN14USBDeviceClass6initEPEmm+0xe8>)
    126c:	2780      	movs	r7, #128	; 0x80
    126e:	6003      	str	r3, [r0, #0]
    1270:	2300      	movs	r3, #0
    1272:	4e1e      	ldr	r6, [pc, #120]	; (12ec <_ZN14USBDeviceClass6initEPEmm+0xd8>)
    1274:	007f      	lsls	r7, r7, #1
    1276:	1d42      	adds	r2, r0, #5
    1278:	6203      	str	r3, [r0, #32]
    127a:	6103      	str	r3, [r0, #16]
    127c:	6143      	str	r3, [r0, #20]
    127e:	61c3      	str	r3, [r0, #28]
    1280:	6046      	str	r6, [r0, #4]
    1282:	6085      	str	r5, [r0, #8]
    1284:	60c7      	str	r7, [r0, #12]
    1286:	77d3      	strb	r3, [r2, #31]
    1288:	322f      	adds	r2, #47	; 0x2f
    128a:	62c3      	str	r3, [r0, #44]	; 0x2c
    128c:	6303      	str	r3, [r0, #48]	; 0x30
    128e:	0004      	movs	r4, r0
    1290:	7013      	strb	r3, [r2, #0]
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
    1292:	0038      	movs	r0, r7
		notify(false)
    1294:	7053      	strb	r3, [r2, #1]
		data0 = reinterpret_cast<uint8_t *>(malloc(size));
    1296:	f002 fc43 	bl	3b20 <malloc>
    129a:	9001      	str	r0, [sp, #4]
    129c:	61a0      	str	r0, [r4, #24]
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
    129e:	0038      	movs	r0, r7
    12a0:	f002 fc3e 	bl	3b20 <malloc>
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    12a4:	b2eb      	uxtb	r3, r5
    12a6:	015a      	lsls	r2, r3, #5
		data1 = reinterpret_cast<uint8_t *>(malloc(size));
    12a8:	62a0      	str	r0, [r4, #40]	; 0x28
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    12aa:	18b2      	adds	r2, r6, r2
    12ac:	6891      	ldr	r1, [r2, #8]
    12ae:	4810      	ldr	r0, [pc, #64]	; (12f0 <_ZN14USBDeviceClass6initEPEmm+0xdc>)
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    12b0:	3308      	adds	r3, #8
	inline void epBank0SetSize(ep_t ep, uint16_t size) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.SIZE = EP_PCKSIZE_SIZE(size); }
    12b2:	4008      	ands	r0, r1
    12b4:	21c0      	movs	r1, #192	; 0xc0
    12b6:	0589      	lsls	r1, r1, #22
    12b8:	4301      	orrs	r1, r0
    12ba:	6091      	str	r1, [r2, #8]
	inline void epBank0SetType(ep_t ep, uint8_t type) { usb.DeviceEndpoint[ep].EPCFG.bit.EPTYPE0 = type; }
    12bc:	6831      	ldr	r1, [r6, #0]
    12be:	2607      	movs	r6, #7
    12c0:	015b      	lsls	r3, r3, #5
    12c2:	5c58      	ldrb	r0, [r3, r1]
    12c4:	00ad      	lsls	r5, r5, #2
    12c6:	43b0      	bics	r0, r6
    12c8:	0006      	movs	r6, r0
    12ca:	2003      	movs	r0, #3
    12cc:	4330      	orrs	r0, r6
    12ce:	5458      	strb	r0, [r3, r1]
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    12d0:	9b01      	ldr	r3, [sp, #4]
		release();
    12d2:	0020      	movs	r0, r4
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    12d4:	6053      	str	r3, [r2, #4]
		release();
    12d6:	f7ff fd7f 	bl	dd8 <_ZN26DoubleBufferedEPOutHandler7releaseEv>
    12da:	4b07      	ldr	r3, [pc, #28]	; (12f8 <_ZN14USBDeviceClass6initEPEmm+0xe4>)
    12dc:	515c      	str	r4, [r3, r5]
    12de:	e7b6      	b.n	124e <_ZN14USBDeviceClass6initEPEmm+0x3a>
    12e0:	0011      	movs	r1, r2
    12e2:	0028      	movs	r0, r5
    12e4:	f7ff fc90 	bl	c08 <_ZN14USBDeviceClass6initEPEmm.part.5>
}
    12e8:	e7b1      	b.n	124e <_ZN14USBDeviceClass6initEPEmm+0x3a>
    12ea:	46c0      	nop			; (mov r8, r8)
    12ec:	200005ec 	.word	0x200005ec
    12f0:	8fffffff 	.word	0x8fffffff
    12f4:	20000160 	.word	0x20000160
    12f8:	20000138 	.word	0x20000138
    12fc:	00003e58 	.word	0x00003e58

00001300 <_ZN14USBDeviceClass13initEndpointsEv>:
void USBDeviceClass::initEndpoints() {
    1300:	b570      	push	{r4, r5, r6, lr}
    1302:	0005      	movs	r5, r0
    1304:	2401      	movs	r4, #1
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
    1306:	4b06      	ldr	r3, [pc, #24]	; (1320 <_ZN14USBDeviceClass13initEndpointsEv+0x20>)
    1308:	00a2      	lsls	r2, r4, #2
    130a:	58d2      	ldr	r2, [r2, r3]
    130c:	2a00      	cmp	r2, #0
    130e:	d005      	beq.n	131c <_ZN14USBDeviceClass13initEndpointsEv+0x1c>
		initEP(i, EndPoints[i]);
    1310:	0021      	movs	r1, r4
    1312:	0028      	movs	r0, r5
    1314:	f7ff ff7e 	bl	1214 <_ZN14USBDeviceClass6initEPEmm>
    1318:	3401      	adds	r4, #1
	for (uint8_t i = 1; i < sizeof(EndPoints) && EndPoints[i] != 0; i++) {
    131a:	e7f4      	b.n	1306 <_ZN14USBDeviceClass13initEndpointsEv+0x6>
}
    131c:	bd70      	pop	{r4, r5, r6, pc}
    131e:	46c0      	nop			; (mov r8, r8)
    1320:	20000004 	.word	0x20000004

00001324 <_ZN14USBDeviceClass9availableEm>:
}

// Number of bytes, assumes a rx endpoint
uint32_t USBDeviceClass::available(uint32_t ep)
{
	if (epHandlers[ep]) {
    1324:	4b08      	ldr	r3, [pc, #32]	; (1348 <_ZN14USBDeviceClass9availableEm+0x24>)
    1326:	008a      	lsls	r2, r1, #2
    1328:	58d0      	ldr	r0, [r2, r3]
{
    132a:	b510      	push	{r4, lr}
	if (epHandlers[ep]) {
    132c:	2800      	cmp	r0, #0
    132e:	d003      	beq.n	1338 <_ZN14USBDeviceClass9availableEm+0x14>
		return epHandlers[ep]->available();
    1330:	6803      	ldr	r3, [r0, #0]
    1332:	689b      	ldr	r3, [r3, #8]
    1334:	4798      	blx	r3
	} else {
		return usbd.epBank0ByteCount(ep);
	}
}
    1336:	bd10      	pop	{r4, pc}
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    1338:	b2c9      	uxtb	r1, r1
    133a:	4b04      	ldr	r3, [pc, #16]	; (134c <_ZN14USBDeviceClass9availableEm+0x28>)
    133c:	0149      	lsls	r1, r1, #5
    133e:	1859      	adds	r1, r3, r1
    1340:	6888      	ldr	r0, [r1, #8]
    1342:	0480      	lsls	r0, r0, #18
    1344:	0c80      	lsrs	r0, r0, #18
		return usbd.epBank0ByteCount(ep);
    1346:	e7f6      	b.n	1336 <_ZN14USBDeviceClass9availableEm+0x12>
    1348:	20000138 	.word	0x20000138
    134c:	200005ec 	.word	0x200005ec

00001350 <_ZN14USBDeviceClass5flushEm>:
{
    1350:	b510      	push	{r4, lr}
    1352:	000c      	movs	r4, r1
	if (available(ep)) {
    1354:	f7ff ffe6 	bl	1324 <_ZN14USBDeviceClass9availableEm>
    1358:	2800      	cmp	r0, #0
    135a:	d00c      	beq.n	1376 <_ZN14USBDeviceClass5flushEm+0x26>
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    135c:	4b06      	ldr	r3, [pc, #24]	; (1378 <_ZN14USBDeviceClass5flushEm+0x28>)
    135e:	b2e4      	uxtb	r4, r4
    1360:	681b      	ldr	r3, [r3, #0]
    1362:	3408      	adds	r4, #8
    1364:	0164      	lsls	r4, r4, #5
    1366:	191c      	adds	r4, r3, r4
    1368:	2380      	movs	r3, #128	; 0x80
    136a:	7962      	ldrb	r2, [r4, #5]
    136c:	425b      	negs	r3, r3
    136e:	4313      	orrs	r3, r2
    1370:	7163      	strb	r3, [r4, #5]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    1372:	2302      	movs	r3, #2
    1374:	71e3      	strb	r3, [r4, #7]
}
    1376:	bd10      	pop	{r4, pc}
    1378:	200005ec 	.word	0x200005ec

0000137c <_ZN14USBDeviceClass14armRecvCtrlOUTEm>:
		return c;
	}
}

uint8_t USBDeviceClass::armRecvCtrlOUT(uint32_t ep)
{
    137c:	b570      	push	{r4, r5, r6, lr}
	// Get endpoint configuration from setting register
	usbd.epBank0SetAddress(ep, &udd_ep_out_cache_buffer[ep]);
    137e:	4b13      	ldr	r3, [pc, #76]	; (13cc <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x50>)
	inline void epBank0SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[0].ADDR.reg = (uint32_t)addr; }
    1380:	b2cc      	uxtb	r4, r1
    1382:	4a13      	ldr	r2, [pc, #76]	; (13d0 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x54>)
    1384:	0160      	lsls	r0, r4, #5
    1386:	0189      	lsls	r1, r1, #6
    1388:	1859      	adds	r1, r3, r1
    138a:	1813      	adds	r3, r2, r0
    138c:	6059      	str	r1, [r3, #4]
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    138e:	6899      	ldr	r1, [r3, #8]
    1390:	4d10      	ldr	r5, [pc, #64]	; (13d4 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x58>)
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    1392:	3408      	adds	r4, #8
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    1394:	400d      	ands	r5, r1
    1396:	2180      	movs	r1, #128	; 0x80
    1398:	0289      	lsls	r1, r1, #10
    139a:	4329      	orrs	r1, r5
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    139c:	2540      	movs	r5, #64	; 0x40
	inline void epBank0SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    139e:	6099      	str	r1, [r3, #8]
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    13a0:	6899      	ldr	r1, [r3, #8]
    13a2:	0b89      	lsrs	r1, r1, #14
    13a4:	0389      	lsls	r1, r1, #14
    13a6:	6099      	str	r1, [r3, #8]
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    13a8:	6811      	ldr	r1, [r2, #0]
    13aa:	0163      	lsls	r3, r4, #5
    13ac:	18cb      	adds	r3, r1, r3
    13ae:	791e      	ldrb	r6, [r3, #4]
    13b0:	4335      	orrs	r5, r6
    13b2:	711d      	strb	r5, [r3, #4]
	inline bool epBank0IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK0RDY; }
    13b4:	799d      	ldrb	r5, [r3, #6]
	usbd.epBank0SetByteCount(ep, 0);

	usbd.epBank0ResetReady(ep);

	// Wait OUT
	while (!usbd.epBank0IsReady(ep)) {}
    13b6:	066d      	lsls	r5, r5, #25
    13b8:	d5fc      	bpl.n	13b4 <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x38>
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    13ba:	0164      	lsls	r4, r4, #5
    13bc:	1909      	adds	r1, r1, r4
    13be:	79cb      	ldrb	r3, [r1, #7]
	while (!usbd.epBank0IsTransferComplete(ep)) {}
    13c0:	07db      	lsls	r3, r3, #31
    13c2:	d5fc      	bpl.n	13be <_ZN14USBDeviceClass14armRecvCtrlOUTEm+0x42>
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    13c4:	1812      	adds	r2, r2, r0
    13c6:	6890      	ldr	r0, [r2, #8]
	return usbd.epBank0ByteCount(ep);
    13c8:	b2c0      	uxtb	r0, r0
}
    13ca:	bd70      	pop	{r4, r5, r6, pc}
    13cc:	20000320 	.word	0x20000320
    13d0:	200005ec 	.word	0x200005ec
    13d4:	f0003fff 	.word	0xf0003fff

000013d8 <_ZN14USBDeviceClass11recvControlEPvm>:
{
    13d8:	b570      	push	{r4, r5, r6, lr}
    13da:	0014      	movs	r4, r2
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    13dc:	2240      	movs	r2, #64	; 0x40
    13de:	4b0b      	ldr	r3, [pc, #44]	; (140c <_ZN14USBDeviceClass11recvControlEPvm+0x34>)
    13e0:	000d      	movs	r5, r1
    13e2:	681b      	ldr	r3, [r3, #0]
    13e4:	33ff      	adds	r3, #255	; 0xff
    13e6:	7959      	ldrb	r1, [r3, #5]
    13e8:	430a      	orrs	r2, r1
    13ea:	715a      	strb	r2, [r3, #5]
	uint32_t read = armRecvCtrlOUT(0);
    13ec:	2100      	movs	r1, #0
    13ee:	f7ff ffc5 	bl	137c <_ZN14USBDeviceClass14armRecvCtrlOUTEm>
    13f2:	42a0      	cmp	r0, r4
    13f4:	d900      	bls.n	13f8 <_ZN14USBDeviceClass11recvControlEPvm+0x20>
    13f6:	0020      	movs	r0, r4
	for (uint32_t i=0; i<len; i++) {
    13f8:	2300      	movs	r3, #0
		data[i] = buffer[i];
    13fa:	4905      	ldr	r1, [pc, #20]	; (1410 <_ZN14USBDeviceClass11recvControlEPvm+0x38>)
	for (uint32_t i=0; i<len; i++) {
    13fc:	42a3      	cmp	r3, r4
    13fe:	d003      	beq.n	1408 <_ZN14USBDeviceClass11recvControlEPvm+0x30>
		data[i] = buffer[i];
    1400:	5c5a      	ldrb	r2, [r3, r1]
    1402:	54ea      	strb	r2, [r5, r3]
	for (uint32_t i=0; i<len; i++) {
    1404:	3301      	adds	r3, #1
    1406:	e7f9      	b.n	13fc <_ZN14USBDeviceClass11recvControlEPvm+0x24>
}
    1408:	bd70      	pop	{r4, r5, r6, pc}
    140a:	46c0      	nop			; (mov r8, r8)
    140c:	200005ec 	.word	0x200005ec
    1410:	20000320 	.word	0x20000320

00001414 <_ZN14USBDeviceClass7armRecvEm>:

uint8_t USBDeviceClass::armRecv(uint32_t ep)
{
    1414:	b510      	push	{r4, lr}
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    1416:	b2c9      	uxtb	r1, r1
    1418:	480b      	ldr	r0, [pc, #44]	; (1448 <_ZN14USBDeviceClass7armRecvEm+0x34>)
    141a:	0149      	lsls	r1, r1, #5
    141c:	1842      	adds	r2, r0, r1
    141e:	6893      	ldr	r3, [r2, #8]
    1420:	049b      	lsls	r3, r3, #18
    1422:	0c9b      	lsrs	r3, r3, #18
	uint16_t count = usbd.epBank0ByteCount(ep);
	if (count >= 64) {
    1424:	2b3f      	cmp	r3, #63	; 0x3f
    1426:	dd0b      	ble.n	1440 <_ZN14USBDeviceClass7armRecvEm+0x2c>
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    1428:	6894      	ldr	r4, [r2, #8]
		usbd.epBank0SetByteCount(ep, count - 64);
    142a:	3b40      	subs	r3, #64	; 0x40
    142c:	049b      	lsls	r3, r3, #18
    142e:	0ba4      	lsrs	r4, r4, #14
    1430:	0c9b      	lsrs	r3, r3, #18
    1432:	03a4      	lsls	r4, r4, #14
    1434:	4323      	orrs	r3, r4
    1436:	6093      	str	r3, [r2, #8]
	inline uint16_t epBank0ByteCount(ep_t ep) { return EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT; }
    1438:	1841      	adds	r1, r0, r1
    143a:	6888      	ldr	r0, [r1, #8]
	} else {
		usbd.epBank0SetByteCount(ep, 0);
	}
	return usbd.epBank0ByteCount(ep);
    143c:	b2c0      	uxtb	r0, r0
}
    143e:	bd10      	pop	{r4, pc}
	inline void epBank0SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[0].PCKSIZE.bit.BYTE_COUNT = bc; }
    1440:	6893      	ldr	r3, [r2, #8]
    1442:	0b9b      	lsrs	r3, r3, #14
    1444:	039b      	lsls	r3, r3, #14
    1446:	e7f6      	b.n	1436 <_ZN14USBDeviceClass7armRecvEm+0x22>
    1448:	200005ec 	.word	0x200005ec

0000144c <_ZN14USBDeviceClass4recvEmPvm>:
{
    144c:	b5f0      	push	{r4, r5, r6, r7, lr}
    144e:	001c      	movs	r4, r3
	if (!_usbConfiguration)
    1450:	4b30      	ldr	r3, [pc, #192]	; (1514 <_ZN14USBDeviceClass4recvEmPvm+0xc8>)
{
    1452:	b085      	sub	sp, #20
	if (!_usbConfiguration)
    1454:	681b      	ldr	r3, [r3, #0]
{
    1456:	0006      	movs	r6, r0
    1458:	000d      	movs	r5, r1
    145a:	9201      	str	r2, [sp, #4]
	if (!_usbConfiguration)
    145c:	2b00      	cmp	r3, #0
    145e:	d055      	beq.n	150c <_ZN14USBDeviceClass4recvEmPvm+0xc0>
	if (rxLEDPulse == 0)
    1460:	4f2d      	ldr	r7, [pc, #180]	; (1518 <_ZN14USBDeviceClass4recvEmPvm+0xcc>)
    1462:	7839      	ldrb	r1, [r7, #0]
    1464:	b2c9      	uxtb	r1, r1
    1466:	2900      	cmp	r1, #0
    1468:	d102      	bne.n	1470 <_ZN14USBDeviceClass4recvEmPvm+0x24>
		digitalWrite(PIN_LED_RXL, LOW);
    146a:	201e      	movs	r0, #30
    146c:	f000 fc62 	bl	1d34 <digitalWrite>
	rxLEDPulse = TX_RX_LED_PULSE_MS;
    1470:	2364      	movs	r3, #100	; 0x64
    1472:	703b      	strb	r3, [r7, #0]
	if (epHandlers[ep]) {
    1474:	4b29      	ldr	r3, [pc, #164]	; (151c <_ZN14USBDeviceClass4recvEmPvm+0xd0>)
    1476:	00aa      	lsls	r2, r5, #2
    1478:	58d0      	ldr	r0, [r2, r3]
    147a:	2800      	cmp	r0, #0
    147c:	d008      	beq.n	1490 <_ZN14USBDeviceClass4recvEmPvm+0x44>
		return epHandlers[ep]->recv(_data, len);
    147e:	6803      	ldr	r3, [r0, #0]
    1480:	0022      	movs	r2, r4
    1482:	685b      	ldr	r3, [r3, #4]
    1484:	9901      	ldr	r1, [sp, #4]
    1486:	4798      	blx	r3
    1488:	0004      	movs	r4, r0
}
    148a:	0020      	movs	r0, r4
    148c:	b005      	add	sp, #20
    148e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (available(ep) < len)
    1490:	0029      	movs	r1, r5
    1492:	0030      	movs	r0, r6
    1494:	f7ff ff46 	bl	1324 <_ZN14USBDeviceClass9availableEm>
    1498:	4284      	cmp	r4, r0
    149a:	d904      	bls.n	14a6 <_ZN14USBDeviceClass4recvEmPvm+0x5a>
		len = available(ep);
    149c:	0029      	movs	r1, r5
    149e:	0030      	movs	r0, r6
    14a0:	f7ff ff40 	bl	1324 <_ZN14USBDeviceClass9availableEm>
    14a4:	0004      	movs	r4, r0
	armRecv(ep);
    14a6:	0029      	movs	r1, r5
    14a8:	0030      	movs	r0, r6
    14aa:	f7ff ffb3 	bl	1414 <_ZN14USBDeviceClass7armRecvEm>
	inline void epBank0DisableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENCLR.bit.TRCPT0 = 1; }
    14ae:	2101      	movs	r1, #1
    14b0:	b2eb      	uxtb	r3, r5
    14b2:	4f1b      	ldr	r7, [pc, #108]	; (1520 <_ZN14USBDeviceClass4recvEmPvm+0xd4>)
    14b4:	9303      	str	r3, [sp, #12]
    14b6:	015b      	lsls	r3, r3, #5
    14b8:	9302      	str	r3, [sp, #8]
    14ba:	9a02      	ldr	r2, [sp, #8]
    14bc:	683b      	ldr	r3, [r7, #0]
	memcpy(_data, udd_ep_out_cache_buffer[ep], len);
    14be:	9801      	ldr	r0, [sp, #4]
    14c0:	189b      	adds	r3, r3, r2
    14c2:	33ff      	adds	r3, #255	; 0xff
    14c4:	7a5a      	ldrb	r2, [r3, #9]
    14c6:	430a      	orrs	r2, r1
    14c8:	4916      	ldr	r1, [pc, #88]	; (1524 <_ZN14USBDeviceClass4recvEmPvm+0xd8>)
    14ca:	725a      	strb	r2, [r3, #9]
    14cc:	01ab      	lsls	r3, r5, #6
    14ce:	18c9      	adds	r1, r1, r3
    14d0:	0022      	movs	r2, r4
    14d2:	f002 fb39 	bl	3b48 <memcpy>
	if (len && !available(ep)) {
    14d6:	2c00      	cmp	r4, #0
    14d8:	d0d7      	beq.n	148a <_ZN14USBDeviceClass4recvEmPvm+0x3e>
    14da:	0029      	movs	r1, r5
    14dc:	0030      	movs	r0, r6
    14de:	f7ff ff21 	bl	1324 <_ZN14USBDeviceClass9availableEm>
    14e2:	2800      	cmp	r0, #0
    14e4:	d1d1      	bne.n	148a <_ZN14USBDeviceClass4recvEmPvm+0x3e>
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    14e6:	2140      	movs	r1, #64	; 0x40
    14e8:	9b03      	ldr	r3, [sp, #12]
    14ea:	683a      	ldr	r2, [r7, #0]
    14ec:	3308      	adds	r3, #8
    14ee:	015b      	lsls	r3, r3, #5
    14f0:	18d3      	adds	r3, r2, r3
    14f2:	7918      	ldrb	r0, [r3, #4]
    14f4:	4301      	orrs	r1, r0
    14f6:	7119      	strb	r1, [r3, #4]
	inline void epBank0AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(1); }
    14f8:	2101      	movs	r1, #1
    14fa:	71d9      	strb	r1, [r3, #7]
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    14fc:	2101      	movs	r1, #1
    14fe:	9b02      	ldr	r3, [sp, #8]
    1500:	18d3      	adds	r3, r2, r3
    1502:	33ff      	adds	r3, #255	; 0xff
    1504:	7a9a      	ldrb	r2, [r3, #10]
    1506:	430a      	orrs	r2, r1
    1508:	729a      	strb	r2, [r3, #10]
    150a:	e7be      	b.n	148a <_ZN14USBDeviceClass4recvEmPvm+0x3e>
		return -1;
    150c:	2401      	movs	r4, #1
    150e:	4264      	negs	r4, r4
    1510:	e7bb      	b.n	148a <_ZN14USBDeviceClass4recvEmPvm+0x3e>
    1512:	46c0      	nop			; (mov r8, r8)
    1514:	200005e4 	.word	0x200005e4
    1518:	20000154 	.word	0x20000154
    151c:	20000138 	.word	0x20000138
    1520:	200005ec 	.word	0x200005ec
    1524:	20000320 	.word	0x20000320

00001528 <_ZN14USBDeviceClass4recvEm>:
{
    1528:	b513      	push	{r0, r1, r4, lr}
	if (recv(ep, &c, 1) != 1) {
    152a:	466b      	mov	r3, sp
    152c:	1ddc      	adds	r4, r3, #7
    152e:	0022      	movs	r2, r4
    1530:	2301      	movs	r3, #1
    1532:	f7ff ff8b 	bl	144c <_ZN14USBDeviceClass4recvEmPvm>
    1536:	2801      	cmp	r0, #1
    1538:	d101      	bne.n	153e <_ZN14USBDeviceClass4recvEm+0x16>
		return c;
    153a:	7820      	ldrb	r0, [r4, #0]
}
    153c:	bd16      	pop	{r1, r2, r4, pc}
		return -1;
    153e:	2001      	movs	r0, #1
    1540:	4240      	negs	r0, r0
    1542:	e7fb      	b.n	153c <_ZN14USBDeviceClass4recvEm+0x14>

00001544 <_ZN14USBDeviceClass4sendEmPKvm>:
	0
};

// Blocking Send of data to an endpoint
uint32_t USBDeviceClass::send(uint32_t ep, const void *data, uint32_t len)
{
    1544:	b5f0      	push	{r4, r5, r6, r7, lr}
    1546:	001e      	movs	r6, r3
	uint32_t written = 0;
	uint32_t length = 0;

	if (!_usbConfiguration)
    1548:	4b3a      	ldr	r3, [pc, #232]	; (1634 <_ZN14USBDeviceClass4sendEmPKvm+0xf0>)
{
    154a:	b085      	sub	sp, #20
	if (!_usbConfiguration)
    154c:	681b      	ldr	r3, [r3, #0]
{
    154e:	000f      	movs	r7, r1
    1550:	9201      	str	r2, [sp, #4]
	if (!_usbConfiguration)
    1552:	2b00      	cmp	r3, #0
    1554:	d03f      	beq.n	15d6 <_ZN14USBDeviceClass4sendEmPKvm+0x92>
		return -1;
	if (len > 16384)
    1556:	2380      	movs	r3, #128	; 0x80
    1558:	01db      	lsls	r3, r3, #7
    155a:	429e      	cmp	r6, r3
    155c:	d83b      	bhi.n	15d6 <_ZN14USBDeviceClass4sendEmPKvm+0x92>
		return -1;

#ifdef PIN_LED_TXL
	if (txLEDPulse == 0)
    155e:	4c36      	ldr	r4, [pc, #216]	; (1638 <_ZN14USBDeviceClass4sendEmPKvm+0xf4>)
    1560:	7821      	ldrb	r1, [r4, #0]
    1562:	b2c9      	uxtb	r1, r1
    1564:	2900      	cmp	r1, #0
    1566:	d102      	bne.n	156e <_ZN14USBDeviceClass4sendEmPKvm+0x2a>
		digitalWrite(PIN_LED_TXL, LOW);
    1568:	201f      	movs	r0, #31
    156a:	f000 fbe3 	bl	1d34 <digitalWrite>

	txLEDPulse = TX_RX_LED_PULSE_MS;
    156e:	2364      	movs	r3, #100	; 0x64
	uint32_t written = 0;
    1570:	2500      	movs	r5, #0
		} else {
			length = len;
		}

		/* memcopy could be safer in multi threaded environment */
		memcpy(&udd_ep_in_cache_buffer[ep], data, length);
    1572:	4a32      	ldr	r2, [pc, #200]	; (163c <_ZN14USBDeviceClass4sendEmPKvm+0xf8>)
	txLEDPulse = TX_RX_LED_PULSE_MS;
    1574:	7023      	strb	r3, [r4, #0]
		memcpy(&udd_ep_in_cache_buffer[ep], data, length);
    1576:	01bb      	lsls	r3, r7, #6
    1578:	18d3      	adds	r3, r2, r3
    157a:	9302      	str	r3, [sp, #8]
	while (len != 0)
    157c:	2e00      	cmp	r6, #0
    157e:	d02c      	beq.n	15da <_ZN14USBDeviceClass4sendEmPKvm+0x96>
	inline bool epBank1IsReady(ep_t ep)    { return usb.DeviceEndpoint[ep].EPSTATUS.bit.BK1RDY; }
    1580:	4b2f      	ldr	r3, [pc, #188]	; (1640 <_ZN14USBDeviceClass4sendEmPKvm+0xfc>)
    1582:	681b      	ldr	r3, [r3, #0]
    1584:	9303      	str	r3, [sp, #12]
    1586:	23ff      	movs	r3, #255	; 0xff
    1588:	403b      	ands	r3, r7
    158a:	001c      	movs	r4, r3
    158c:	9300      	str	r3, [sp, #0]
    158e:	3408      	adds	r4, #8
    1590:	9b03      	ldr	r3, [sp, #12]
    1592:	0164      	lsls	r4, r4, #5
    1594:	191c      	adds	r4, r3, r4
    1596:	79a3      	ldrb	r3, [r4, #6]
    1598:	09db      	lsrs	r3, r3, #7
		if (usbd.epBank1IsReady(ep)) {
    159a:	d021      	beq.n	15e0 <_ZN14USBDeviceClass4sendEmPKvm+0x9c>
			uint32_t timeout = microsecondsToClockCycles(TX_TIMEOUT_MS * 1000) / 23;
    159c:	4b29      	ldr	r3, [pc, #164]	; (1644 <_ZN14USBDeviceClass4sendEmPKvm+0x100>)
    159e:	492a      	ldr	r1, [pc, #168]	; (1648 <_ZN14USBDeviceClass4sendEmPKvm+0x104>)
    15a0:	6818      	ldr	r0, [r3, #0]
    15a2:	f002 fa0d 	bl	39c0 <__udivsi3>
    15a6:	4b29      	ldr	r3, [pc, #164]	; (164c <_ZN14USBDeviceClass4sendEmPKvm+0x108>)
    15a8:	2117      	movs	r1, #23
    15aa:	4358      	muls	r0, r3
    15ac:	f002 fa08 	bl	39c0 <__udivsi3>
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
    15b0:	4b27      	ldr	r3, [pc, #156]	; (1650 <_ZN14USBDeviceClass4sendEmPKvm+0x10c>)
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    15b2:	79e2      	ldrb	r2, [r4, #7]
			while (!usbd.epBank1IsTransferComplete(ep)) {
    15b4:	0792      	lsls	r2, r2, #30
    15b6:	d413      	bmi.n	15e0 <_ZN14USBDeviceClass4sendEmPKvm+0x9c>
				if (LastTransmitTimedOut[ep] || timeout-- == 0) {
    15b8:	5dda      	ldrb	r2, [r3, r7]
    15ba:	2a00      	cmp	r2, #0
    15bc:	d101      	bne.n	15c2 <_ZN14USBDeviceClass4sendEmPKvm+0x7e>
    15be:	3801      	subs	r0, #1
    15c0:	d2f7      	bcs.n	15b2 <_ZN14USBDeviceClass4sendEmPKvm+0x6e>
					LastTransmitTimedOut[ep] = 1;
    15c2:	2201      	movs	r2, #1
    15c4:	55da      	strb	r2, [r3, r7]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    15c6:	9b00      	ldr	r3, [sp, #0]
    15c8:	015a      	lsls	r2, r3, #5
    15ca:	4b1d      	ldr	r3, [pc, #116]	; (1640 <_ZN14USBDeviceClass4sendEmPKvm+0xfc>)
    15cc:	189b      	adds	r3, r3, r2
    15ce:	699a      	ldr	r2, [r3, #24]
    15d0:	0b92      	lsrs	r2, r2, #14
    15d2:	0392      	lsls	r2, r2, #14
    15d4:	619a      	str	r2, [r3, #24]
					return -1;
    15d6:	2501      	movs	r5, #1
    15d8:	426d      	negs	r5, r5
		written += length;
		len -= length;
		data = (char *)data + length;
	}
	return written;
}
    15da:	0028      	movs	r0, r5
    15dc:	b005      	add	sp, #20
    15de:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LastTransmitTimedOut[ep] = 0;
    15e0:	2200      	movs	r2, #0
    15e2:	4b1b      	ldr	r3, [pc, #108]	; (1650 <_ZN14USBDeviceClass4sendEmPKvm+0x10c>)
    15e4:	0034      	movs	r4, r6
    15e6:	55da      	strb	r2, [r3, r7]
    15e8:	2e3f      	cmp	r6, #63	; 0x3f
    15ea:	d900      	bls.n	15ee <_ZN14USBDeviceClass4sendEmPKvm+0xaa>
    15ec:	243f      	movs	r4, #63	; 0x3f
		memcpy(&udd_ep_in_cache_buffer[ep], data, length);
    15ee:	0022      	movs	r2, r4
    15f0:	9901      	ldr	r1, [sp, #4]
    15f2:	9802      	ldr	r0, [sp, #8]
    15f4:	f002 faa8 	bl	3b48 <memcpy>
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    15f8:	9b00      	ldr	r3, [sp, #0]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    15fa:	04a1      	lsls	r1, r4, #18
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    15fc:	015a      	lsls	r2, r3, #5
    15fe:	4b10      	ldr	r3, [pc, #64]	; (1640 <_ZN14USBDeviceClass4sendEmPKvm+0xfc>)
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    1600:	0c89      	lsrs	r1, r1, #18
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    1602:	189b      	adds	r3, r3, r2
    1604:	9a02      	ldr	r2, [sp, #8]
		written += length;
    1606:	192d      	adds	r5, r5, r4
    1608:	615a      	str	r2, [r3, #20]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    160a:	699a      	ldr	r2, [r3, #24]
		len -= length;
    160c:	1b36      	subs	r6, r6, r4
    160e:	0b92      	lsrs	r2, r2, #14
    1610:	0392      	lsls	r2, r2, #14
    1612:	430a      	orrs	r2, r1
    1614:	619a      	str	r2, [r3, #24]
	inline void epBank1AckTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_TRCPT(2); }
    1616:	9b00      	ldr	r3, [sp, #0]
    1618:	9a03      	ldr	r2, [sp, #12]
    161a:	3308      	adds	r3, #8
    161c:	015b      	lsls	r3, r3, #5
    161e:	18d3      	adds	r3, r2, r3
    1620:	2202      	movs	r2, #2
    1622:	71da      	strb	r2, [r3, #7]
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    1624:	7959      	ldrb	r1, [r3, #5]
    1626:	3a82      	subs	r2, #130	; 0x82
    1628:	430a      	orrs	r2, r1
    162a:	715a      	strb	r2, [r3, #5]
		data = (char *)data + length;
    162c:	9b01      	ldr	r3, [sp, #4]
    162e:	191b      	adds	r3, r3, r4
    1630:	9301      	str	r3, [sp, #4]
	while (len != 0)
    1632:	e7a3      	b.n	157c <_ZN14USBDeviceClass4sendEmPKvm+0x38>
    1634:	200005e4 	.word	0x200005e4
    1638:	20000155 	.word	0x20000155
    163c:	20000160 	.word	0x20000160
    1640:	200005ec 	.word	0x200005ec
    1644:	2000002c 	.word	0x2000002c
    1648:	000f4240 	.word	0x000f4240
    164c:	00011170 	.word	0x00011170
    1650:	20000157 	.word	0x20000157

00001654 <_ZN14USBDeviceClass7armSendEmPKvm>:

uint32_t USBDeviceClass::armSend(uint32_t ep, const void* data, uint32_t len)
{
    1654:	b570      	push	{r4, r5, r6, lr}
    1656:	000d      	movs	r5, r1
    1658:	001c      	movs	r4, r3
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
    165a:	4e0d      	ldr	r6, [pc, #52]	; (1690 <_ZN14USBDeviceClass7armSendEmPKvm+0x3c>)
    165c:	01ab      	lsls	r3, r5, #6
    165e:	18f6      	adds	r6, r6, r3
{
    1660:	0011      	movs	r1, r2
	memcpy(&udd_ep_in_cache_buffer[ep], data, len);
    1662:	0030      	movs	r0, r6
    1664:	0022      	movs	r2, r4
    1666:	f002 fa6f 	bl	3b48 <memcpy>
	inline void epBank1SetAddress(ep_t ep, void *addr) { EP[ep].DeviceDescBank[1].ADDR.reg = (uint32_t)addr; }
    166a:	b2ed      	uxtb	r5, r5
    166c:	4909      	ldr	r1, [pc, #36]	; (1694 <_ZN14USBDeviceClass7armSendEmPKvm+0x40>)
    166e:	016d      	lsls	r5, r5, #5
    1670:	194d      	adds	r5, r1, r5
    1672:	616e      	str	r6, [r5, #20]
	inline void epBank1SetMultiPacketSize(ep_t ep, uint16_t s) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = s; }
    1674:	69ab      	ldr	r3, [r5, #24]
    1676:	4a08      	ldr	r2, [pc, #32]	; (1698 <_ZN14USBDeviceClass7armSendEmPKvm+0x44>)
	usbd.epBank1SetAddress(ep, &udd_ep_in_cache_buffer[ep]);
	usbd.epBank1SetMultiPacketSize(ep, 0);
	usbd.epBank1SetByteCount(ep, len);

	return len;
}
    1678:	0020      	movs	r0, r4
    167a:	4013      	ands	r3, r2
    167c:	61ab      	str	r3, [r5, #24]
	inline void epBank1SetByteCount(ep_t ep, uint16_t bc) { EP[ep].DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = bc; }
    167e:	69ab      	ldr	r3, [r5, #24]
    1680:	04a2      	lsls	r2, r4, #18
    1682:	0b9b      	lsrs	r3, r3, #14
    1684:	0c92      	lsrs	r2, r2, #18
    1686:	039b      	lsls	r3, r3, #14
    1688:	4313      	orrs	r3, r2
    168a:	61ab      	str	r3, [r5, #24]
    168c:	bd70      	pop	{r4, r5, r6, pc}
    168e:	46c0      	nop			; (mov r8, r8)
    1690:	20000160 	.word	0x20000160
    1694:	200005ec 	.word	0x200005ec
    1698:	f0003fff 	.word	0xf0003fff

0000169c <_ZN14USBDeviceClass11sendControlEPKvm>:

uint32_t USBDeviceClass::sendControl(const void* _data, uint32_t len)
{
    169c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const uint8_t *data = reinterpret_cast<const uint8_t *>(_data);
	uint32_t length = len;
	uint32_t sent = 0;
	uint32_t pos = 0;

	if (_dry_run == true)
    169e:	4b10      	ldr	r3, [pc, #64]	; (16e0 <_ZN14USBDeviceClass11sendControlEPKvm+0x44>)
{
    16a0:	9001      	str	r0, [sp, #4]
	if (_dry_run == true)
    16a2:	781b      	ldrb	r3, [r3, #0]
{
    16a4:	000f      	movs	r7, r1
    16a6:	0015      	movs	r5, r2
	if (_dry_run == true)
    16a8:	2b00      	cmp	r3, #0
    16aa:	d10c      	bne.n	16c6 <_ZN14USBDeviceClass11sendControlEPKvm+0x2a>
		return length;

	if (_pack_message == true) {
    16ac:	4b0d      	ldr	r3, [pc, #52]	; (16e4 <_ZN14USBDeviceClass11sendControlEPKvm+0x48>)
    16ae:	0016      	movs	r6, r2
    16b0:	781c      	ldrb	r4, [r3, #0]
    16b2:	2c00      	cmp	r4, #0
    16b4:	d009      	beq.n	16ca <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
		memcpy(&_pack_buffer[_pack_size], data, len);
    16b6:	4e0c      	ldr	r6, [pc, #48]	; (16e8 <_ZN14USBDeviceClass11sendControlEPKvm+0x4c>)
    16b8:	480c      	ldr	r0, [pc, #48]	; (16ec <_ZN14USBDeviceClass11sendControlEPKvm+0x50>)
    16ba:	8834      	ldrh	r4, [r6, #0]
    16bc:	1900      	adds	r0, r0, r4
		_pack_size += len;
    16be:	1964      	adds	r4, r4, r5
		memcpy(&_pack_buffer[_pack_size], data, len);
    16c0:	f002 fa42 	bl	3b48 <memcpy>
		_pack_size += len;
    16c4:	8034      	strh	r4, [r6, #0]
		pos += sent;
		len -= sent;
 	}

	return length;
}
    16c6:	0028      	movs	r0, r5
    16c8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 	while (len > 0)
    16ca:	2e00      	cmp	r6, #0
    16cc:	d0fb      	beq.n	16c6 <_ZN14USBDeviceClass11sendControlEPKvm+0x2a>
		sent = armSend(EP0, data + pos, len);
    16ce:	193a      	adds	r2, r7, r4
    16d0:	0033      	movs	r3, r6
    16d2:	2100      	movs	r1, #0
    16d4:	9801      	ldr	r0, [sp, #4]
    16d6:	f7ff ffbd 	bl	1654 <_ZN14USBDeviceClass7armSendEmPKvm>
		pos += sent;
    16da:	1824      	adds	r4, r4, r0
		len -= sent;
    16dc:	1a36      	subs	r6, r6, r0
 	while (len > 0)
    16de:	e7f4      	b.n	16ca <_ZN14USBDeviceClass11sendControlEPKvm+0x2e>
    16e0:	200004e0 	.word	0x200004e0
    16e4:	200005e1 	.word	0x200005e1
    16e8:	200005e2 	.word	0x200005e2
    16ec:	200004e1 	.word	0x200004e1

000016f0 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>:
{
    16f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		return false;
    16f2:	2000      	movs	r0, #0
{
    16f4:	af00      	add	r7, sp, #0
    16f6:	000e      	movs	r6, r1
    16f8:	0015      	movs	r5, r2
	if (maxlen < 2)
    16fa:	2a01      	cmp	r2, #1
    16fc:	dd26      	ble.n	174c <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x5c>
	uint8_t buffer[maxlen];
    16fe:	1dd3      	adds	r3, r2, #7
    1700:	466a      	mov	r2, sp
    1702:	08db      	lsrs	r3, r3, #3
    1704:	00db      	lsls	r3, r3, #3
    1706:	1ad3      	subs	r3, r2, r3
    1708:	469d      	mov	sp, r3
	buffer[0] = strlen((const char*)string) * 2 + 2;
    170a:	0008      	movs	r0, r1
    170c:	f002 fae8 	bl	3ce0 <strlen>
	uint8_t buffer[maxlen];
    1710:	466c      	mov	r4, sp
	buffer[1] = 0x03;
    1712:	2303      	movs	r3, #3
		buffer[i] = 0;
    1714:	2100      	movs	r1, #0
	buffer[0] = strlen((const char*)string) * 2 + 2;
    1716:	3001      	adds	r0, #1
    1718:	0040      	lsls	r0, r0, #1
    171a:	7020      	strb	r0, [r4, #0]
	buffer[1] = 0x03;
    171c:	7063      	strb	r3, [r4, #1]
    171e:	1e5a      	subs	r2, r3, #1
    1720:	b2d2      	uxtb	r2, r2
	for (i = 2; i < maxlen && *string; i++) {
    1722:	4295      	cmp	r5, r2
    1724:	dd0b      	ble.n	173e <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
    1726:	7830      	ldrb	r0, [r6, #0]
    1728:	2800      	cmp	r0, #0
    172a:	d008      	beq.n	173e <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4e>
		buffer[i++] = *string++;
    172c:	3601      	adds	r6, #1
    172e:	54a0      	strb	r0, [r4, r2]
		if (i == maxlen) break;
    1730:	429d      	cmp	r5, r3
    1732:	d003      	beq.n	173c <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x4c>
		buffer[i] = 0;
    1734:	54e1      	strb	r1, [r4, r3]
    1736:	3302      	adds	r3, #2
    1738:	b2db      	uxtb	r3, r3
	for (i = 2; i < maxlen && *string; i++) {
    173a:	e7f0      	b.n	171e <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x2e>
    173c:	002a      	movs	r2, r5
	return USBDevice.sendControl(buffer, i);
    173e:	0021      	movs	r1, r4
    1740:	4803      	ldr	r0, [pc, #12]	; (1750 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh+0x60>)
    1742:	f7ff ffab 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
    1746:	1e43      	subs	r3, r0, #1
    1748:	4198      	sbcs	r0, r3
    174a:	b2c0      	uxtb	r0, r0
}
    174c:	46bd      	mov	sp, r7
    174e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1750:	20000134 	.word	0x20000134

00001754 <_ZN14USBDeviceClass17sendConfigurationEm>:
{
    1754:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t total = 0;
    1756:	2700      	movs	r7, #0
	_dry_run = true;
    1758:	2601      	movs	r6, #1
{
    175a:	b087      	sub	sp, #28
	_dry_run = true;
    175c:	4b1e      	ldr	r3, [pc, #120]	; (17d8 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)
{
    175e:	9100      	str	r1, [sp, #0]
	uint8_t interfaces = SendInterfaces(&total);
    1760:	a902      	add	r1, sp, #8
	_dry_run = true;
    1762:	701e      	strb	r6, [r3, #0]
{
    1764:	0005      	movs	r5, r0
	uint32_t total = 0;
    1766:	9702      	str	r7, [sp, #8]
	uint8_t interfaces = SendInterfaces(&total);
    1768:	f7ff fc44 	bl	ff4 <_ZN14USBDeviceClass14SendInterfacesEPm>
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
    176c:	ac03      	add	r4, sp, #12
	uint8_t interfaces = SendInterfaces(&total);
    176e:	9001      	str	r0, [sp, #4]
	ConfigDescriptor config = D_CONFIG((uint16_t)(total + sizeof(ConfigDescriptor)), interfaces);
    1770:	2209      	movs	r2, #9
    1772:	0039      	movs	r1, r7
    1774:	0020      	movs	r0, r4
    1776:	f002 f9f0 	bl	3b5a <memset>
    177a:	2309      	movs	r3, #9
    177c:	7023      	strb	r3, [r4, #0]
    177e:	2302      	movs	r3, #2
    1780:	7063      	strb	r3, [r4, #1]
    1782:	339e      	adds	r3, #158	; 0x9e
    1784:	71e3      	strb	r3, [r4, #7]
    1786:	335a      	adds	r3, #90	; 0x5a
    1788:	7223      	strb	r3, [r4, #8]
    178a:	9b02      	ldr	r3, [sp, #8]
    178c:	7166      	strb	r6, [r4, #5]
    178e:	3309      	adds	r3, #9
    1790:	8063      	strh	r3, [r4, #2]
    1792:	466b      	mov	r3, sp
    1794:	791b      	ldrb	r3, [r3, #4]
    1796:	7123      	strb	r3, [r4, #4]
	_dry_run = false;
    1798:	4b0f      	ldr	r3, [pc, #60]	; (17d8 <_ZN14USBDeviceClass17sendConfigurationEm+0x84>)
    179a:	701f      	strb	r7, [r3, #0]
	if (maxlen == sizeof(ConfigDescriptor)) {
    179c:	9b00      	ldr	r3, [sp, #0]
    179e:	2b09      	cmp	r3, #9
    17a0:	d107      	bne.n	17b2 <_ZN14USBDeviceClass17sendConfigurationEm+0x5e>
		sendControl(&config, sizeof(ConfigDescriptor));
    17a2:	001a      	movs	r2, r3
    17a4:	0021      	movs	r1, r4
		sendControl(_pack_buffer, _pack_size);
    17a6:	0028      	movs	r0, r5
    17a8:	f7ff ff78 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
}
    17ac:	2001      	movs	r0, #1
    17ae:	b007      	add	sp, #28
    17b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		_pack_message = true;
    17b2:	4b0a      	ldr	r3, [pc, #40]	; (17dc <_ZN14USBDeviceClass17sendConfigurationEm+0x88>)
	sendControl(&config, sizeof(ConfigDescriptor));
    17b4:	2209      	movs	r2, #9
		_pack_message = true;
    17b6:	701e      	strb	r6, [r3, #0]
		_pack_size = 0;
    17b8:	4e09      	ldr	r6, [pc, #36]	; (17e0 <_ZN14USBDeviceClass17sendConfigurationEm+0x8c>)
	sendControl(&config, sizeof(ConfigDescriptor));
    17ba:	0021      	movs	r1, r4
    17bc:	0028      	movs	r0, r5
	total = 0;
    17be:	9702      	str	r7, [sp, #8]
		_pack_size = 0;
    17c0:	8037      	strh	r7, [r6, #0]
	sendControl(&config, sizeof(ConfigDescriptor));
    17c2:	f7ff ff6b 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
	SendInterfaces(&total);
    17c6:	a902      	add	r1, sp, #8
    17c8:	0028      	movs	r0, r5
    17ca:	f7ff fc13 	bl	ff4 <_ZN14USBDeviceClass14SendInterfacesEPm>
		_pack_message = false;
    17ce:	4b03      	ldr	r3, [pc, #12]	; (17dc <_ZN14USBDeviceClass17sendConfigurationEm+0x88>)
		sendControl(_pack_buffer, _pack_size);
    17d0:	8832      	ldrh	r2, [r6, #0]
		_pack_message = false;
    17d2:	701f      	strb	r7, [r3, #0]
		sendControl(_pack_buffer, _pack_size);
    17d4:	4903      	ldr	r1, [pc, #12]	; (17e4 <_ZN14USBDeviceClass17sendConfigurationEm+0x90>)
    17d6:	e7e6      	b.n	17a6 <_ZN14USBDeviceClass17sendConfigurationEm+0x52>
    17d8:	200004e0 	.word	0x200004e0
    17dc:	200005e1 	.word	0x200005e1
    17e0:	200005e2 	.word	0x200005e2
    17e4:	200004e1 	.word	0x200004e1

000017e8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>:
{
    17e8:	b570      	push	{r4, r5, r6, lr}
	uint8_t t = setup.wValueH;
    17ea:	78ce      	ldrb	r6, [r1, #3]
{
    17ec:	b092      	sub	sp, #72	; 0x48
    17ee:	0005      	movs	r5, r0
    17f0:	000c      	movs	r4, r1
	if (t == USB_CONFIGURATION_DESCRIPTOR_TYPE)
    17f2:	2e02      	cmp	r6, #2
    17f4:	d108      	bne.n	1808 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x20>
		return USBDevice.sendConfiguration(setup.wLength);
    17f6:	88c9      	ldrh	r1, [r1, #6]
    17f8:	482b      	ldr	r0, [pc, #172]	; (18a8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc0>)
    17fa:	f7ff ffab 	bl	1754 <_ZN14USBDeviceClass17sendConfigurationEm>
    17fe:	1e43      	subs	r3, r0, #1
    1800:	4198      	sbcs	r0, r3
    1802:	b2c0      	uxtb	r0, r0
}
    1804:	b012      	add	sp, #72	; 0x48
    1806:	bd70      	pop	{r4, r5, r6, pc}
	ret = PluggableUSB().getDescriptor(setup);
    1808:	f001 fbe0 	bl	2fcc <_Z12PluggableUSBv>
    180c:	0021      	movs	r1, r4
    180e:	f001 fbad 	bl	2f6c <_ZN13PluggableUSB_13getDescriptorER8USBSetup>
	if (ret != 0) {
    1812:	2800      	cmp	r0, #0
    1814:	d003      	beq.n	181e <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x36>
		return (ret > 0 ? true : false);
    1816:	17c3      	asrs	r3, r0, #31
    1818:	1a18      	subs	r0, r3, r0
    181a:	0fc0      	lsrs	r0, r0, #31
    181c:	e7f2      	b.n	1804 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x1c>
	if (t == USB_DEVICE_DESCRIPTOR_TYPE)
    181e:	2e01      	cmp	r6, #1
    1820:	d10b      	bne.n	183a <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x52>
		if (setup.wLength == 8)
    1822:	88e2      	ldrh	r2, [r4, #6]
    1824:	4921      	ldr	r1, [pc, #132]	; (18ac <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc4>)
		if (*desc_addr > setup.wLength) {
    1826:	2a11      	cmp	r2, #17
    1828:	dc10      	bgt.n	184c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x64>
			desc_length = setup.wLength;
    182a:	b2d2      	uxtb	r2, r2
	if (desc_length == 0) {
    182c:	2a00      	cmp	r2, #0
    182e:	d00d      	beq.n	184c <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x64>
	sendControl(desc_addr, desc_length);
    1830:	0028      	movs	r0, r5
    1832:	f7ff ff33 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
	return true;
    1836:	2001      	movs	r0, #1
    1838:	e7e4      	b.n	1804 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x1c>
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    183a:	2e03      	cmp	r6, #3
    183c:	d1e2      	bne.n	1804 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x1c>
		if (setup.wValueL == 0) {
    183e:	78a3      	ldrb	r3, [r4, #2]
    1840:	2b00      	cmp	r3, #0
    1842:	d105      	bne.n	1850 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x68>
		if (*desc_addr > setup.wLength) {
    1844:	88e2      	ldrh	r2, [r4, #6]
    1846:	491a      	ldr	r1, [pc, #104]	; (18b0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xc8>)
    1848:	2a03      	cmp	r2, #3
    184a:	ddee      	ble.n	182a <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x42>
		desc_length = *desc_addr;
    184c:	780a      	ldrb	r2, [r1, #0]
    184e:	e7ef      	b.n	1830 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x48>
		else if (setup.wValueL == IPRODUCT) {
    1850:	2b02      	cmp	r3, #2
    1852:	d105      	bne.n	1860 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x78>
			return sendStringDescriptor(STRING_PRODUCT, setup.wLength);
    1854:	79a2      	ldrb	r2, [r4, #6]
    1856:	4917      	ldr	r1, [pc, #92]	; (18b4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xcc>)
			return sendStringDescriptor(STRING_MANUFACTURER, setup.wLength);
    1858:	0028      	movs	r0, r5
    185a:	f7ff ff49 	bl	16f0 <_ZN14USBDeviceClass20sendStringDescriptorEPKhh>
    185e:	e7d1      	b.n	1804 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x1c>
		else if (setup.wValueL == IMANUFACTURER) {
    1860:	2b01      	cmp	r3, #1
    1862:	d102      	bne.n	186a <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x82>
			return sendStringDescriptor(STRING_MANUFACTURER, setup.wLength);
    1864:	79a2      	ldrb	r2, [r4, #6]
    1866:	4914      	ldr	r1, [pc, #80]	; (18b8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd0>)
    1868:	e7f6      	b.n	1858 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
		else if (setup.wValueL == ISERIAL) {
    186a:	2b03      	cmp	r3, #3
    186c:	d1ca      	bne.n	1804 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x1c>
			utox8(SERIAL_NUMBER_WORD_0, &name[0]);
    186e:	4b13      	ldr	r3, [pc, #76]	; (18bc <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd4>)
    1870:	a901      	add	r1, sp, #4
    1872:	6818      	ldr	r0, [r3, #0]
    1874:	f7ff f9a2 	bl	bbc <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_1, &name[8]);
    1878:	4b11      	ldr	r3, [pc, #68]	; (18c0 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xd8>)
    187a:	a903      	add	r1, sp, #12
    187c:	6818      	ldr	r0, [r3, #0]
    187e:	f7ff f99d 	bl	bbc <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_2, &name[16]);
    1882:	4b10      	ldr	r3, [pc, #64]	; (18c4 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xdc>)
    1884:	a905      	add	r1, sp, #20
    1886:	6818      	ldr	r0, [r3, #0]
    1888:	f7ff f998 	bl	bbc <_ZL5utox8mPc>
			utox8(SERIAL_NUMBER_WORD_3, &name[24]);
    188c:	4b0e      	ldr	r3, [pc, #56]	; (18c8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0xe0>)
    188e:	a907      	add	r1, sp, #28
    1890:	6818      	ldr	r0, [r3, #0]
    1892:	f7ff f993 	bl	bbc <_ZL5utox8mPc>
			PluggableUSB().getShortName(&name[32]);
    1896:	f001 fb99 	bl	2fcc <_Z12PluggableUSBv>
    189a:	a909      	add	r1, sp, #36	; 0x24
    189c:	f001 fb76 	bl	2f8c <_ZN13PluggableUSB_12getShortNameEPc>
			return sendStringDescriptor((uint8_t*)name, setup.wLength);
    18a0:	79a2      	ldrb	r2, [r4, #6]
    18a2:	a901      	add	r1, sp, #4
    18a4:	e7d8      	b.n	1858 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup+0x70>
    18a6:	46c0      	nop			; (mov r8, r8)
    18a8:	20000134 	.word	0x20000134
    18ac:	00003e8c 	.word	0x00003e8c
    18b0:	00003e7c 	.word	0x00003e7c
    18b4:	00003e6c 	.word	0x00003e6c
    18b8:	00003e80 	.word	0x00003e80
    18bc:	0080a00c 	.word	0x0080a00c
    18c0:	0080a040 	.word	0x0080a040
    18c4:	0080a044 	.word	0x0080a044
    18c8:	0080a048 	.word	0x0080a048

000018cc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>:
	// Set the byte count as zero
	usbd.epBank1SetByteCount(ep, 0);
}

bool USBDeviceClass::handleStandardSetup(USBSetup &setup)
{
    18cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    18ce:	0006      	movs	r6, r0
	switch (setup.bRequest) {
    18d0:	7848      	ldrb	r0, [r1, #1]
{
    18d2:	000d      	movs	r5, r1
	switch (setup.bRequest) {
    18d4:	280b      	cmp	r0, #11
    18d6:	d811      	bhi.n	18fc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x30>
    18d8:	f002 f868 	bl	39ac <__gnu_thumb1_case_uqi>
    18dc:	2e101d06 	.word	0x2e101d06
    18e0:	70484310 	.word	0x70484310
    18e4:	6c694f4c 	.word	0x6c694f4c
	case GET_STATUS:
		if (setup.bmRequestType == 0)  // device
    18e8:	7809      	ldrb	r1, [r1, #0]
    18ea:	aa01      	add	r2, sp, #4
    18ec:	2900      	cmp	r1, #0
    18ee:	d107      	bne.n	1900 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x34>
		{
			// Send the device status
			// TODO: Check current configuration for power mode (if device is configured)
			// TODO: Check if remote wake-up is enabled
			uint8_t buff[] = { 0, 0 };
			armSend(0, buff, 2);
    18f0:	2302      	movs	r3, #2
			uint8_t buff[] = { 0, 0 };
    18f2:	7011      	strb	r1, [r2, #0]
    18f4:	7051      	strb	r1, [r2, #1]
			armSend(0, buff, 2);
    18f6:	0030      	movs	r0, r6
    18f8:	f7ff feac 	bl	1654 <_ZN14USBDeviceClass7armSendEmPKvm>
			return true;
    18fc:	2001      	movs	r0, #1
		return true;

	default:
		return true;
	}
}
    18fe:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
			uint8_t buff[] = { 0, 0 };
    1900:	2300      	movs	r3, #0
    1902:	7013      	strb	r3, [r2, #0]
    1904:	7053      	strb	r3, [r2, #1]
			if (isEndpointHalt == 1)
    1906:	4b2e      	ldr	r3, [pc, #184]	; (19c0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf4>)
			if (isRemoteWakeUpEnabled == 1)
    1908:	781b      	ldrb	r3, [r3, #0]
    190a:	2b01      	cmp	r3, #1
    190c:	d100      	bne.n	1910 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x44>
				buff[0] = 1;
    190e:	7013      	strb	r3, [r2, #0]
			armSend(0, buff, 2);
    1910:	2302      	movs	r3, #2
		armSend(0, (void*)&_usbSetInterface, 1);
    1912:	2100      	movs	r1, #0
    1914:	e7ef      	b.n	18f6 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x2a>
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
    1916:	788a      	ldrb	r2, [r1, #2]
    1918:	2300      	movs	r3, #0
    191a:	2a01      	cmp	r2, #1
    191c:	d104      	bne.n	1928 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x5c>
			uint8_t buff[] = { 0, 0 };
    191e:	aa01      	add	r2, sp, #4
    1920:	7013      	strb	r3, [r2, #0]
    1922:	7053      	strb	r3, [r2, #1]
			if (isRemoteWakeUpEnabled == 1)
    1924:	4b27      	ldr	r3, [pc, #156]	; (19c4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf8>)
    1926:	e7ef      	b.n	1908 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x3c>
			isEndpointHalt = 0;
    1928:	4a25      	ldr	r2, [pc, #148]	; (19c0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf4>)
    192a:	7013      	strb	r3, [r2, #0]
    192c:	4a26      	ldr	r2, [pc, #152]	; (19c8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfc>)
    192e:	6993      	ldr	r3, [r2, #24]
    1930:	0b9b      	lsrs	r3, r3, #14
    1932:	039b      	lsls	r3, r3, #14
    1934:	6193      	str	r3, [r2, #24]
    1936:	e7e1      	b.n	18fc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x30>
		if (setup.wValueL == 1) // DEVICEREMOTEWAKEUP
    1938:	788c      	ldrb	r4, [r1, #2]
    193a:	2c01      	cmp	r4, #1
    193c:	d106      	bne.n	194c <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x80>
			uint8_t buff[] = { 0 };
    193e:	2100      	movs	r1, #0
			isRemoteWakeUpEnabled = 1;
    1940:	4b20      	ldr	r3, [pc, #128]	; (19c4 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf8>)
			uint8_t buff[] = { 0 };
    1942:	aa01      	add	r2, sp, #4
			isRemoteWakeUpEnabled = 1;
    1944:	701c      	strb	r4, [r3, #0]
			uint8_t buff[] = { 0 };
    1946:	7011      	strb	r1, [r2, #0]
			armSend(0, buff, 1);
    1948:	0023      	movs	r3, r4
    194a:	e7d4      	b.n	18f6 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x2a>
		if (setup.wValueL == 0) // ENDPOINTHALT
    194c:	2c00      	cmp	r4, #0
    194e:	d108      	bne.n	1962 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x96>
			isEndpointHalt = 1;
    1950:	2001      	movs	r0, #1
    1952:	4b1b      	ldr	r3, [pc, #108]	; (19c0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xf4>)
    1954:	4a1c      	ldr	r2, [pc, #112]	; (19c8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfc>)
    1956:	7018      	strb	r0, [r3, #0]
    1958:	6993      	ldr	r3, [r2, #24]
    195a:	0b9b      	lsrs	r3, r3, #14
    195c:	039b      	lsls	r3, r3, #14
    195e:	6193      	str	r3, [r2, #24]
			return true;
    1960:	e7cd      	b.n	18fe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x32>
		setAddress(setup.wValueL);
    1962:	78a9      	ldrb	r1, [r5, #2]
    1964:	0030      	movs	r0, r6
    1966:	f7ff fc0f 	bl	1188 <_ZN14USBDeviceClass10setAddressEm>
    196a:	e7c7      	b.n	18fc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x30>
		return sendDescriptor(setup);
    196c:	0030      	movs	r0, r6
    196e:	f7ff ff3b 	bl	17e8 <_ZN14USBDeviceClass14sendDescriptorER8USBSetup>
    1972:	e7c4      	b.n	18fe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x32>
		armSend(0, (void*)&_usbConfiguration, 1);
    1974:	2301      	movs	r3, #1
    1976:	4a15      	ldr	r2, [pc, #84]	; (19cc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>)
    1978:	e7cb      	b.n	1912 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x46>
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
    197a:	780b      	ldrb	r3, [r1, #0]
			return false;
    197c:	2000      	movs	r0, #0
		if (REQUEST_DEVICE == (setup.bmRequestType & REQUEST_RECIPIENT)) {
    197e:	06db      	lsls	r3, r3, #27
    1980:	d1bd      	bne.n	18fe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x32>
			initEndpoints();
    1982:	0030      	movs	r0, r6
    1984:	f7ff fcbc 	bl	1300 <_ZN14USBDeviceClass13initEndpointsEv>
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }
    1988:	202a      	movs	r0, #42	; 0x2a
    198a:	2102      	movs	r1, #2
			_usbConfiguration = setup.wValueL;
    198c:	78aa      	ldrb	r2, [r5, #2]
    198e:	4b0f      	ldr	r3, [pc, #60]	; (19cc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x100>)
    1990:	30ff      	adds	r0, #255	; 0xff
    1992:	601a      	str	r2, [r3, #0]
    1994:	4a0c      	ldr	r2, [pc, #48]	; (19c8 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0xfc>)
    1996:	6813      	ldr	r3, [r2, #0]
    1998:	5c1c      	ldrb	r4, [r3, r0]
    199a:	4321      	orrs	r1, r4
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    199c:	244a      	movs	r4, #74	; 0x4a
	inline void epBank1EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT1 = 1; }
    199e:	5419      	strb	r1, [r3, r0]
	inline void epBank0EnableTransferComplete(ep_t ep) { usb.DeviceEndpoint[ep].EPINTENSET.bit.TRCPT0 = 1; }
    19a0:	34ff      	adds	r4, #255	; 0xff
    19a2:	5d19      	ldrb	r1, [r3, r4]
    19a4:	3829      	subs	r0, #41	; 0x29
    19a6:	38ff      	subs	r0, #255	; 0xff
    19a8:	4301      	orrs	r1, r0
    19aa:	5519      	strb	r1, [r3, r4]
    19ac:	e7d4      	b.n	1958 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x8c>
		armSend(0, (void*)&_usbSetInterface, 1);
    19ae:	2301      	movs	r3, #1
    19b0:	4a07      	ldr	r2, [pc, #28]	; (19d0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
    19b2:	e7ae      	b.n	1912 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x46>
		_usbSetInterface = setup.wValueL;
    19b4:	788a      	ldrb	r2, [r1, #2]
    19b6:	4b06      	ldr	r3, [pc, #24]	; (19d0 <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x104>)
    19b8:	601a      	str	r2, [r3, #0]
    19ba:	e7b7      	b.n	192c <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x60>
		return false;
    19bc:	2000      	movs	r0, #0
    19be:	e79e      	b.n	18fe <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup+0x32>
    19c0:	20000156 	.word	0x20000156
    19c4:	2000015e 	.word	0x2000015e
    19c8:	200005ec 	.word	0x200005ec
    19cc:	200005e4 	.word	0x200005e4
    19d0:	200005e8 	.word	0x200005e8

000019d4 <_ZN14USBDeviceClass10ISRHandlerEv>:

void USBDeviceClass::ISRHandler()
{

	if (_pack_message == true) {
    19d4:	4b4c      	ldr	r3, [pc, #304]	; (1b08 <_ZN14USBDeviceClass10ISRHandlerEv+0x134>)
{
    19d6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (_pack_message == true) {
    19d8:	781c      	ldrb	r4, [r3, #0]
{
    19da:	0007      	movs	r7, r0
	if (_pack_message == true) {
    19dc:	2c00      	cmp	r4, #0
    19de:	d000      	beq.n	19e2 <_ZN14USBDeviceClass10ISRHandlerEv+0xe>
    19e0:	e07d      	b.n	1ade <_ZN14USBDeviceClass10ISRHandlerEv+0x10a>
	inline bool isEndOfResetInterrupt()        { return usb.INTFLAG.bit.EORST; }
    19e2:	4e4a      	ldr	r6, [pc, #296]	; (1b0c <_ZN14USBDeviceClass10ISRHandlerEv+0x138>)
    19e4:	6833      	ldr	r3, [r6, #0]
    19e6:	8b9b      	ldrh	r3, [r3, #28]
		return;
	}
	// End-Of-Reset
	if (usbd.isEndOfResetInterrupt())
    19e8:	071b      	lsls	r3, r3, #28
    19ea:	d50e      	bpl.n	1a0a <_ZN14USBDeviceClass10ISRHandlerEv+0x36>
    19ec:	0021      	movs	r1, r4
    19ee:	0020      	movs	r0, r4
    19f0:	f7ff f90a 	bl	c08 <_ZN14USBDeviceClass6initEPEmm.part.5>
	inline void epBank0EnableSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTENSET.bit.RXSTP = 1; }
    19f4:	6832      	ldr	r2, [r6, #0]
    19f6:	2310      	movs	r3, #16
    19f8:	0011      	movs	r1, r2
    19fa:	31ff      	adds	r1, #255	; 0xff
    19fc:	7a88      	ldrb	r0, [r1, #10]
    19fe:	4303      	orrs	r3, r0
    1a00:	728b      	strb	r3, [r1, #10]
		initEP(0, USB_ENDPOINT_TYPE_CONTROL);

		// Enable Setup-Received interrupt
		usbd.epBank0EnableSetupReceived(0);

		_usbConfiguration = 0;
    1a02:	4b43      	ldr	r3, [pc, #268]	; (1b10 <_ZN14USBDeviceClass10ISRHandlerEv+0x13c>)
    1a04:	601c      	str	r4, [r3, #0]
	inline void ackEndOfResetInterrupt()       { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_EORST; }
    1a06:	2308      	movs	r3, #8
    1a08:	8393      	strh	r3, [r2, #28]
	inline bool isStartOfFrameInterrupt()      { return usb.INTFLAG.bit.SOF; }
    1a0a:	6833      	ldr	r3, [r6, #0]
    1a0c:	8b9a      	ldrh	r2, [r3, #28]

		usbd.ackEndOfResetInterrupt();
	}

	// Start-Of-Frame
	if (usbd.isStartOfFrameInterrupt())
    1a0e:	0752      	lsls	r2, r2, #29
    1a10:	d51f      	bpl.n	1a52 <_ZN14USBDeviceClass10ISRHandlerEv+0x7e>
	inline void ackStartOfFrameInterrupt()     { usb.INTFLAG.reg = USB_DEVICE_INTFLAG_SOF; }
    1a12:	2204      	movs	r2, #4
    1a14:	839a      	strh	r2, [r3, #28]
	{
		usbd.ackStartOfFrameInterrupt();

		// check whether the one-shot period has elapsed.  if so, turn off the LED
#ifdef PIN_LED_TXL
		if (txLEDPulse > 0) {
    1a16:	4a3f      	ldr	r2, [pc, #252]	; (1b14 <_ZN14USBDeviceClass10ISRHandlerEv+0x140>)
    1a18:	7813      	ldrb	r3, [r2, #0]
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d00a      	beq.n	1a34 <_ZN14USBDeviceClass10ISRHandlerEv+0x60>
			txLEDPulse--;
    1a1e:	7813      	ldrb	r3, [r2, #0]
    1a20:	3b01      	subs	r3, #1
    1a22:	b2db      	uxtb	r3, r3
    1a24:	7013      	strb	r3, [r2, #0]
			if (txLEDPulse == 0)
    1a26:	7813      	ldrb	r3, [r2, #0]
    1a28:	2b00      	cmp	r3, #0
    1a2a:	d103      	bne.n	1a34 <_ZN14USBDeviceClass10ISRHandlerEv+0x60>
				digitalWrite(PIN_LED_TXL, HIGH);
    1a2c:	2101      	movs	r1, #1
    1a2e:	201f      	movs	r0, #31
    1a30:	f000 f980 	bl	1d34 <digitalWrite>
		}
#endif

#ifdef PIN_LED_RXL
		if (rxLEDPulse > 0) {
    1a34:	4a38      	ldr	r2, [pc, #224]	; (1b18 <_ZN14USBDeviceClass10ISRHandlerEv+0x144>)
    1a36:	7813      	ldrb	r3, [r2, #0]
    1a38:	2b00      	cmp	r3, #0
    1a3a:	d00a      	beq.n	1a52 <_ZN14USBDeviceClass10ISRHandlerEv+0x7e>
			rxLEDPulse--;
    1a3c:	7813      	ldrb	r3, [r2, #0]
    1a3e:	3b01      	subs	r3, #1
    1a40:	b2db      	uxtb	r3, r3
    1a42:	7013      	strb	r3, [r2, #0]
			if (rxLEDPulse == 0)
    1a44:	7813      	ldrb	r3, [r2, #0]
    1a46:	2b00      	cmp	r3, #0
    1a48:	d103      	bne.n	1a52 <_ZN14USBDeviceClass10ISRHandlerEv+0x7e>
				digitalWrite(PIN_LED_RXL, HIGH);
    1a4a:	2101      	movs	r1, #1
    1a4c:	201e      	movs	r0, #30
    1a4e:	f000 f971 	bl	1d34 <digitalWrite>
	inline bool epBank0IsSetupReceived(ep_t ep)     { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.RXSTP; }
    1a52:	6833      	ldr	r3, [r6, #0]
    1a54:	33ff      	adds	r3, #255	; 0xff
    1a56:	7a1a      	ldrb	r2, [r3, #8]
		}
#endif
	}

	// Endpoint 0 Received Setup interrupt
	if (usbd.epBank0IsSetupReceived(0))
    1a58:	06d2      	lsls	r2, r2, #27
    1a5a:	d520      	bpl.n	1a9e <_ZN14USBDeviceClass10ISRHandlerEv+0xca>
	inline void epBank0AckSetupReceived(ep_t ep)    { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_RXSTP; }
    1a5c:	2210      	movs	r2, #16
    1a5e:	721a      	strb	r2, [r3, #8]
	inline void epBank0ResetReady(ep_t ep) { usb.DeviceEndpoint[ep].EPSTATUSCLR.bit.BK0RDY = 1; }
    1a60:	7959      	ldrb	r1, [r3, #5]
    1a62:	3230      	adds	r2, #48	; 0x30
    1a64:	430a      	orrs	r2, r1
    1a66:	715a      	strb	r2, [r3, #5]
		/* Clear the Bank 0 ready flag on Control OUT */
		// The RAM Buffer is empty: we can receive data
		usbd.epBank0ResetReady(0);

		bool ok;
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
    1a68:	2360      	movs	r3, #96	; 0x60
    1a6a:	492c      	ldr	r1, [pc, #176]	; (1b1c <_ZN14USBDeviceClass10ISRHandlerEv+0x148>)
			// Standard Requests
			ok = handleStandardSetup(*setup);
    1a6c:	0038      	movs	r0, r7
		if (REQUEST_STANDARD == (setup->bmRequestType & REQUEST_TYPE)) {
    1a6e:	780a      	ldrb	r2, [r1, #0]
    1a70:	421a      	tst	r2, r3
    1a72:	d135      	bne.n	1ae0 <_ZN14USBDeviceClass10ISRHandlerEv+0x10c>
			ok = handleStandardSetup(*setup);
    1a74:	f7ff ff2a 	bl	18cc <_ZN14USBDeviceClass19handleStandardSetupER8USBSetup>
		} else {
			// Class Interface Requests
			ok = handleClassInterfaceSetup(*setup);
		}

		if (ok) {
    1a78:	2800      	cmp	r0, #0
    1a7a:	d034      	beq.n	1ae6 <_ZN14USBDeviceClass10ISRHandlerEv+0x112>
	inline void epBank1SetReady(ep_t ep)   { usb.DeviceEndpoint[ep].EPSTATUSSET.bit.BK1RDY = 1; }
    1a7c:	2280      	movs	r2, #128	; 0x80
    1a7e:	6833      	ldr	r3, [r6, #0]
    1a80:	4252      	negs	r2, r2
    1a82:	33ff      	adds	r3, #255	; 0xff
    1a84:	7999      	ldrb	r1, [r3, #6]
    1a86:	430a      	orrs	r2, r1
	USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ(2);
    1a88:	719a      	strb	r2, [r3, #6]
	inline bool epBank1IsStalled(ep_t ep)           { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.STALL1; }
    1a8a:	6833      	ldr	r3, [r6, #0]
    1a8c:	33ff      	adds	r3, #255	; 0xff
    1a8e:	7a1a      	ldrb	r2, [r3, #8]
			usbd.epBank1SetReady(0);
		} else {
			stall(0);
		}

		if (usbd.epBank1IsStalled(0))
    1a90:	0652      	lsls	r2, r2, #25
    1a92:	d504      	bpl.n	1a9e <_ZN14USBDeviceClass10ISRHandlerEv+0xca>
	inline void epBank1AckStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTFLAG.reg = USB_DEVICE_EPINTFLAG_STALL(2); }
    1a94:	2240      	movs	r2, #64	; 0x40
    1a96:	721a      	strb	r2, [r3, #8]
	inline void epBank1DisableStalled(ep_t ep)          { usb.DeviceEndpoint[ep].EPINTENCLR.bit.STALL1 = 1; }
    1a98:	7a59      	ldrb	r1, [r3, #9]
    1a9a:	430a      	orrs	r2, r1
    1a9c:	725a      	strb	r2, [r3, #9]
	inline uint16_t epInterruptSummary() { return usb.EPINTSMRY.reg; }
    1a9e:	6833      	ldr	r3, [r6, #0]
		}

	} // end Received Setup handler

	uint8_t i=0;
	uint8_t ept_int = usbd.epInterruptSummary() & 0xFE; // Remove endpoint number 0 (setup)
    1aa0:	2500      	movs	r5, #0
    1aa2:	8c1c      	ldrh	r4, [r3, #32]
    1aa4:	2301      	movs	r3, #1
    1aa6:	439c      	bics	r4, r3
    1aa8:	b2e4      	uxtb	r4, r4
	while (ept_int != 0)
	{
		// Check if endpoint has a pending interrupt
		if ((ept_int & (1 << i)) != 0)
    1aaa:	9301      	str	r3, [sp, #4]
    1aac:	b2e9      	uxtb	r1, r5
	while (ept_int != 0)
    1aae:	2c00      	cmp	r4, #0
    1ab0:	d015      	beq.n	1ade <_ZN14USBDeviceClass10ISRHandlerEv+0x10a>
		if ((ept_int & (1 << i)) != 0)
    1ab2:	0023      	movs	r3, r4
    1ab4:	412b      	asrs	r3, r5
    1ab6:	9a01      	ldr	r2, [sp, #4]
    1ab8:	4213      	tst	r3, r2
    1aba:	d00d      	beq.n	1ad8 <_ZN14USBDeviceClass10ISRHandlerEv+0x104>
	inline bool epBank0IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT0; }
    1abc:	002b      	movs	r3, r5
    1abe:	6832      	ldr	r2, [r6, #0]
    1ac0:	3308      	adds	r3, #8
    1ac2:	015b      	lsls	r3, r3, #5
    1ac4:	18d3      	adds	r3, r2, r3
    1ac6:	79da      	ldrb	r2, [r3, #7]
		{
			// Endpoint Transfer Complete (0/1) Interrupt
			if (usbd.epBank0IsTransferComplete(i) ||
    1ac8:	07d2      	lsls	r2, r2, #31
    1aca:	d413      	bmi.n	1af4 <_ZN14USBDeviceClass10ISRHandlerEv+0x120>
	inline bool epBank1IsTransferComplete(ep_t ep)  { return usb.DeviceEndpoint[ep].EPINTFLAG.bit.TRCPT1; }
    1acc:	79db      	ldrb	r3, [r3, #7]
    1ace:	079b      	lsls	r3, r3, #30
    1ad0:	d410      	bmi.n	1af4 <_ZN14USBDeviceClass10ISRHandlerEv+0x120>
					epHandlers[i]->handleEndpoint();
				} else {
					handleEndpoint(i);
				}
			}
			ept_int &= ~(1 << i);
    1ad2:	9b01      	ldr	r3, [sp, #4]
    1ad4:	40ab      	lsls	r3, r5
    1ad6:	439c      	bics	r4, r3
    1ad8:	3501      	adds	r5, #1
		}
		i++;
		if (i > USB_EPT_NUM)
    1ada:	2d09      	cmp	r5, #9
    1adc:	d1e6      	bne.n	1aac <_ZN14USBDeviceClass10ISRHandlerEv+0xd8>
			break;  // fire exit
	}
}
    1ade:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
			ok = handleClassInterfaceSetup(*setup);
    1ae0:	f7ff fb76 	bl	11d0 <_ZN14USBDeviceClass25handleClassInterfaceSetupER8USBSetup>
    1ae4:	e7c8      	b.n	1a78 <_ZN14USBDeviceClass10ISRHandlerEv+0xa4>
	USB->DEVICE.DeviceEndpoint[ep].EPSTATUSSET.reg = USB_DEVICE_EPSTATUSSET_STALLRQ(2);
    1ae6:	2220      	movs	r2, #32
    1ae8:	4b0d      	ldr	r3, [pc, #52]	; (1b20 <_ZN14USBDeviceClass10ISRHandlerEv+0x14c>)
    1aea:	e7cd      	b.n	1a88 <_ZN14USBDeviceClass10ISRHandlerEv+0xb4>
					epHandlers[i]->handleEndpoint();
    1aec:	6803      	ldr	r3, [r0, #0]
    1aee:	681b      	ldr	r3, [r3, #0]
    1af0:	4798      	blx	r3
    1af2:	e7ee      	b.n	1ad2 <_ZN14USBDeviceClass10ISRHandlerEv+0xfe>
				if (epHandlers[i]) {
    1af4:	4b0b      	ldr	r3, [pc, #44]	; (1b24 <_ZN14USBDeviceClass10ISRHandlerEv+0x150>)
    1af6:	00aa      	lsls	r2, r5, #2
    1af8:	58d0      	ldr	r0, [r2, r3]
    1afa:	2800      	cmp	r0, #0
    1afc:	d1f6      	bne.n	1aec <_ZN14USBDeviceClass10ISRHandlerEv+0x118>
					handleEndpoint(i);
    1afe:	0038      	movs	r0, r7
    1b00:	f7ff fa8e 	bl	1020 <_ZN14USBDeviceClass14handleEndpointEh>
    1b04:	e7e5      	b.n	1ad2 <_ZN14USBDeviceClass10ISRHandlerEv+0xfe>
    1b06:	46c0      	nop			; (mov r8, r8)
    1b08:	200005e1 	.word	0x200005e1
    1b0c:	200005ec 	.word	0x200005ec
    1b10:	200005e4 	.word	0x200005e4
    1b14:	20000155 	.word	0x20000155
    1b18:	20000154 	.word	0x20000154
    1b1c:	20000320 	.word	0x20000320
    1b20:	410050ff 	.word	0x410050ff
    1b24:	20000138 	.word	0x20000138

00001b28 <UDD_Handler>:
extern "C" void UDD_Handler(void) {
    1b28:	b510      	push	{r4, lr}
	USBDevice.ISRHandler();
    1b2a:	4802      	ldr	r0, [pc, #8]	; (1b34 <UDD_Handler+0xc>)
    1b2c:	f7ff ff52 	bl	19d4 <_ZN14USBDeviceClass10ISRHandlerEv>
}
    1b30:	bd10      	pop	{r4, pc}
    1b32:	46c0      	nop			; (mov r8, r8)
    1b34:	20000134 	.word	0x20000134

00001b38 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv>:
	USBDevice_SAMD21G18x() : usb(USB->DEVICE) {
    1b38:	4a01      	ldr	r2, [pc, #4]	; (1b40 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0x8>)
    1b3a:	4b02      	ldr	r3, [pc, #8]	; (1b44 <_GLOBAL__sub_I__ZN20USBDevice_SAMD21G18x5resetEv+0xc>)
    1b3c:	601a      	str	r2, [r3, #0]
 * USB Device instance
 * -------------------
 */

// USBDevice class instance
USBDeviceClass USBDevice;
    1b3e:	4770      	bx	lr
    1b40:	41005000 	.word	0x41005000
    1b44:	200005ec 	.word	0x200005ec

00001b48 <init>:
 *   - During reset, all PORT lines are configured as inputs with input buffers, output buffers and pull disabled.
 */
void init( void )
{
  // Set Systick to 1ms interval, common to all Cortex-M variants
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    1b48:	21fa      	movs	r1, #250	; 0xfa
    1b4a:	4b31      	ldr	r3, [pc, #196]	; (1c10 <init+0xc8>)
{
    1b4c:	b510      	push	{r4, lr}
  if ( SysTick_Config( SystemCoreClock / 1000 ) )
    1b4e:	6818      	ldr	r0, [r3, #0]
    1b50:	0089      	lsls	r1, r1, #2
    1b52:	f001 ff35 	bl	39c0 <__udivsi3>
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    1b56:	4b2f      	ldr	r3, [pc, #188]	; (1c14 <init+0xcc>)
    1b58:	3801      	subs	r0, #1
    1b5a:	4298      	cmp	r0, r3
    1b5c:	d856      	bhi.n	1c0c <init+0xc4>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1b5e:	492e      	ldr	r1, [pc, #184]	; (1c18 <init+0xd0>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1b60:	4a2e      	ldr	r2, [pc, #184]	; (1c1c <init+0xd4>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1b62:	6048      	str	r0, [r1, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1b64:	20c0      	movs	r0, #192	; 0xc0
    1b66:	6a13      	ldr	r3, [r2, #32]
    1b68:	0600      	lsls	r0, r0, #24
    1b6a:	021b      	lsls	r3, r3, #8
    1b6c:	0a1b      	lsrs	r3, r3, #8
    1b6e:	4303      	orrs	r3, r0
    1b70:	6213      	str	r3, [r2, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    1b72:	2400      	movs	r4, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    1b74:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    1b76:	608c      	str	r4, [r1, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    1b78:	600b      	str	r3, [r1, #0]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    1b7a:	2180      	movs	r1, #128	; 0x80
    1b7c:	6a13      	ldr	r3, [r2, #32]
    1b7e:	0609      	lsls	r1, r1, #24
    1b80:	021b      	lsls	r3, r3, #8
    1b82:	0a1b      	lsrs	r3, r3, #8
    1b84:	430b      	orrs	r3, r1
    1b86:	6213      	str	r3, [r2, #32]
//
//  // Clock EIC for I/O interrupts
//  PM->APBAMASK.reg |= PM_APBAMASK_EIC ;

  // Clock SERCOM for Serial
  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM0 | PM_APBCMASK_SERCOM1 | PM_APBCMASK_SERCOM2 | PM_APBCMASK_SERCOM3 | PM_APBCMASK_SERCOM4 | PM_APBCMASK_SERCOM5 ;
    1b88:	22fc      	movs	r2, #252	; 0xfc
    1b8a:	4b25      	ldr	r3, [pc, #148]	; (1c20 <init+0xd8>)
    1b8c:	6a19      	ldr	r1, [r3, #32]
    1b8e:	430a      	orrs	r2, r1
    1b90:	621a      	str	r2, [r3, #32]

  // Clock TC/TCC for Pulse and Analog
  PM->APBCMASK.reg |= PM_APBCMASK_TCC0 | PM_APBCMASK_TCC1 | PM_APBCMASK_TCC2 | PM_APBCMASK_TC3 | PM_APBCMASK_TC4 | PM_APBCMASK_TC5 ;
    1b92:	22fc      	movs	r2, #252	; 0xfc
    1b94:	6a19      	ldr	r1, [r3, #32]
    1b96:	0192      	lsls	r2, r2, #6
    1b98:	430a      	orrs	r2, r1
    1b9a:	621a      	str	r2, [r3, #32]

  // Clock ADC/DAC for Analog
  PM->APBCMASK.reg |= PM_APBCMASK_ADC | PM_APBCMASK_DAC ;
    1b9c:	22a0      	movs	r2, #160	; 0xa0
    1b9e:	6a19      	ldr	r1, [r3, #32]
    1ba0:	02d2      	lsls	r2, r2, #11
    1ba2:	430a      	orrs	r2, r1
    1ba4:	621a      	str	r2, [r3, #32]

  // Setup all pins (digital and analog) in INPUT mode (default is nothing)
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
  {
    pinMode( ul, INPUT ) ;
    1ba6:	0020      	movs	r0, r4
    1ba8:	2100      	movs	r1, #0
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    1baa:	3401      	adds	r4, #1
    pinMode( ul, INPUT ) ;
    1bac:	f000 f876 	bl	1c9c <pinMode>
  for (uint32_t ul = 0 ; ul < NUM_DIGITAL_PINS ; ul++ )
    1bb0:	2c13      	cmp	r4, #19
    1bb2:	d1f8      	bne.n	1ba6 <init+0x5e>
  }

  // Initialize Analog Controller
  // Setting clock
  while(GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
    1bb4:	4b1b      	ldr	r3, [pc, #108]	; (1c24 <init+0xdc>)
    1bb6:	001c      	movs	r4, r3
    1bb8:	785a      	ldrb	r2, [r3, #1]
    1bba:	b252      	sxtb	r2, r2
    1bbc:	2a00      	cmp	r2, #0
    1bbe:	dbfb      	blt.n	1bb8 <init+0x70>

  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_ADC ) | // Generic Clock ADC
    1bc0:	4a19      	ldr	r2, [pc, #100]	; (1c28 <init+0xe0>)
    1bc2:	805a      	strh	r2, [r3, #2]
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    1bc4:	4b19      	ldr	r3, [pc, #100]	; (1c2c <init+0xe4>)
    1bc6:	001a      	movs	r2, r3
    1bc8:	7e59      	ldrb	r1, [r3, #25]
    1bca:	09c9      	lsrs	r1, r1, #7
    1bcc:	2901      	cmp	r1, #1
    1bce:	d0fb      	beq.n	1bc8 <init+0x80>

  ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 |    // Divide Clock by 512.
    1bd0:	21e4      	movs	r1, #228	; 0xe4
    1bd2:	00c9      	lsls	r1, r1, #3
    1bd4:	8099      	strh	r1, [r3, #4]
                   ADC_CTRLB_RESSEL_10BIT;         // 10 bits resolution as default

  ADC->SAMPCTRL.reg = 0x3f;                        // Set max Sampling Time Length
    1bd6:	213f      	movs	r1, #63	; 0x3f
    1bd8:	70d9      	strb	r1, [r3, #3]

  while( ADC->STATUS.bit.SYNCBUSY == 1 );          // Wait for synchronization of registers between the clock domains
    1bda:	7e53      	ldrb	r3, [r2, #25]
    1bdc:	09db      	lsrs	r3, r3, #7
    1bde:	2b01      	cmp	r3, #1
    1be0:	d0fb      	beq.n	1bda <init+0x92>

  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    1be2:	23c0      	movs	r3, #192	; 0xc0

  // Averaging (see datasheet table in AVGCTRL register description)
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    1be4:	2000      	movs	r0, #0
  ADC->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND;   // No Negative input (Internal Ground)
    1be6:	015b      	lsls	r3, r3, #5
    1be8:	6113      	str	r3, [r2, #16]
  ADC->AVGCTRL.reg = ADC_AVGCTRL_SAMPLENUM_1 |    // 1 sample only (no oversampling nor averaging)
    1bea:	7090      	strb	r0, [r2, #2]
                     ADC_AVGCTRL_ADJRES(0x0ul);   // Adjusting result by 0

  analogReference( AR_DEFAULT ) ; // Analog Reference is AREF pin (3.3v)
    1bec:	f000 f824 	bl	1c38 <analogReference>

  // Initialize DAC
  // Setting clock
  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY );
    1bf0:	7863      	ldrb	r3, [r4, #1]
    1bf2:	b25b      	sxtb	r3, r3
    1bf4:	2b00      	cmp	r3, #0
    1bf6:	dbfb      	blt.n	1bf0 <init+0xa8>
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_DAC ) | // Generic Clock ADC
    1bf8:	4b0d      	ldr	r3, [pc, #52]	; (1c30 <init+0xe8>)
                      GCLK_CLKCTRL_GEN_GCLK0     | // Generic Clock Generator 0 is source
                      GCLK_CLKCTRL_CLKEN ;

  while ( DAC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization of registers between the clock domains
    1bfa:	4a0e      	ldr	r2, [pc, #56]	; (1c34 <init+0xec>)
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( GCM_DAC ) | // Generic Clock ADC
    1bfc:	8063      	strh	r3, [r4, #2]
  while ( DAC->STATUS.bit.SYNCBUSY == 1 ); // Wait for synchronization of registers between the clock domains
    1bfe:	79d3      	ldrb	r3, [r2, #7]
    1c00:	09db      	lsrs	r3, r3, #7
    1c02:	2b01      	cmp	r3, #1
    1c04:	d0fb      	beq.n	1bfe <init+0xb6>
  DAC->CTRLB.reg = DAC_CTRLB_REFSEL_AVCC | // Using the 3.3V reference
    1c06:	2341      	movs	r3, #65	; 0x41
    1c08:	7053      	strb	r3, [r2, #1]
                   DAC_CTRLB_EOEN ;        // External Output Enable (Vout)
}
    1c0a:	bd10      	pop	{r4, pc}
    1c0c:	e7fe      	b.n	1c0c <init+0xc4>
    1c0e:	46c0      	nop			; (mov r8, r8)
    1c10:	2000002c 	.word	0x2000002c
    1c14:	00ffffff 	.word	0x00ffffff
    1c18:	e000e010 	.word	0xe000e010
    1c1c:	e000ed00 	.word	0xe000ed00
    1c20:	40000400 	.word	0x40000400
    1c24:	40000c00 	.word	0x40000c00
    1c28:	0000401e 	.word	0x0000401e
    1c2c:	42004000 	.word	0x42004000
    1c30:	00004021 	.word	0x00004021
    1c34:	42004800 	.word	0x42004800

00001c38 <analogReference>:
static int _writeResolution = 8;

// Wait for synchronization of registers between the clock domains
static __inline__ void syncADC() __attribute__((always_inline, unused));
static void syncADC() {
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    1c38:	4a16      	ldr	r2, [pc, #88]	; (1c94 <analogReference+0x5c>)
 * External Reference should be between 1v and VDDANA-0.6v=2.7v
 *
 * Warning : On Arduino Zero board the input/output voltage for SAMD21G18 is 3.3 volts maximum
 */
void analogReference(eAnalogReference mode)
{
    1c3a:	b500      	push	{lr}
    1c3c:	0013      	movs	r3, r2
  while (ADC->STATUS.bit.SYNCBUSY == 1)
    1c3e:	7e51      	ldrb	r1, [r2, #25]
    1c40:	09c9      	lsrs	r1, r1, #7
    1c42:	2901      	cmp	r1, #1
    1c44:	d0fb      	beq.n	1c3e <analogReference+0x6>
  syncADC();
  switch (mode)
    1c46:	3801      	subs	r0, #1
    1c48:	2804      	cmp	r0, #4
    1c4a:	d816      	bhi.n	1c7a <analogReference+0x42>
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INT1V_Val;   // 1.0V voltage reference
      break;

    case AR_INTERNAL1V65:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
    1c4c:	6919      	ldr	r1, [r3, #16]
    1c4e:	4a12      	ldr	r2, [pc, #72]	; (1c98 <analogReference+0x60>)
    1c50:	400a      	ands	r2, r1
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c52:	210f      	movs	r1, #15
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_1X_Val;      // Gain Factor Selection
    1c54:	611a      	str	r2, [r3, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c56:	785a      	ldrb	r2, [r3, #1]
    1c58:	438a      	bics	r2, r1
  switch (mode)
    1c5a:	f001 fea7 	bl	39ac <__gnu_thumb1_case_uqi>
    1c5e:	0803      	.short	0x0803
    1c60:	0b06      	.short	0x0b06
    1c62:	03          	.byte	0x03
    1c63:	00          	.byte	0x00
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC0_Val; // 1/1.48 VDDANA = 1/1.48* 3V3 = 2.2297
    1c64:	0011      	movs	r1, r2
    1c66:	2201      	movs	r2, #1
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c68:	430a      	orrs	r2, r1
    1c6a:	705a      	strb	r2, [r3, #1]
    default:
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_DIV2_Val;
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
      break;
  }
}
    1c6c:	bd00      	pop	{pc}
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_AREFA_Val;
    1c6e:	0011      	movs	r1, r2
    1c70:	2203      	movs	r2, #3
    1c72:	e7f9      	b.n	1c68 <analogReference+0x30>
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c74:	0011      	movs	r1, r2
    1c76:	2202      	movs	r2, #2
    1c78:	e7f6      	b.n	1c68 <analogReference+0x30>
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_DIV2_Val;
    1c7a:	23f0      	movs	r3, #240	; 0xf0
    1c7c:	6911      	ldr	r1, [r2, #16]
    1c7e:	051b      	lsls	r3, r3, #20
    1c80:	430b      	orrs	r3, r1
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c82:	210f      	movs	r1, #15
      ADC->INPUTCTRL.bit.GAIN = ADC_INPUTCTRL_GAIN_DIV2_Val;
    1c84:	6113      	str	r3, [r2, #16]
      ADC->REFCTRL.bit.REFSEL = ADC_REFCTRL_REFSEL_INTVCC1_Val; // 1/2 VDDANA = 0.5* 3V3 = 1.65V
    1c86:	7853      	ldrb	r3, [r2, #1]
    1c88:	438b      	bics	r3, r1
    1c8a:	0019      	movs	r1, r3
    1c8c:	2302      	movs	r3, #2
    1c8e:	430b      	orrs	r3, r1
    1c90:	7053      	strb	r3, [r2, #1]
}
    1c92:	e7eb      	b.n	1c6c <analogReference+0x34>
    1c94:	42004000 	.word	0x42004000
    1c98:	f0ffffff 	.word	0xf0ffffff

00001c9c <pinMode>:
#endif

void pinMode( uint32_t ulPin, uint32_t ulMode )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1c9c:	2318      	movs	r3, #24
{
    1c9e:	b530      	push	{r4, r5, lr}
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1ca0:	001d      	movs	r5, r3
{
    1ca2:	0004      	movs	r4, r0
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1ca4:	4345      	muls	r5, r0
    1ca6:	2008      	movs	r0, #8
    1ca8:	4a20      	ldr	r2, [pc, #128]	; (1d2c <pinMode+0x90>)
    1caa:	1955      	adds	r5, r2, r5
    1cac:	5628      	ldrsb	r0, [r5, r0]
    1cae:	3001      	adds	r0, #1
    1cb0:	d014      	beq.n	1cdc <pinMode+0x40>
  {
    return ;
  }

  // Set pin mode according to chapter '22.6.3 I/O Pin Configuration'
  switch ( ulMode )
    1cb2:	2903      	cmp	r1, #3
    1cb4:	d812      	bhi.n	1cdc <pinMode+0x40>
    1cb6:	0008      	movs	r0, r1
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    break ;

    case INPUT_PULLDOWN:
      // Set pin to input mode with pull-down resistor enabled
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    1cb8:	4363      	muls	r3, r4
    1cba:	56d1      	ldrsb	r1, [r2, r3]
    1cbc:	18d3      	adds	r3, r2, r3
  switch ( ulMode )
    1cbe:	f001 fe75 	bl	39ac <__gnu_thumb1_case_uqi>
    1cc2:	2802      	.short	0x2802
    1cc4:	1b0e      	.short	0x1b0e
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    1cc6:	6858      	ldr	r0, [r3, #4]
    1cc8:	01cb      	lsls	r3, r1, #7
    1cca:	2102      	movs	r1, #2
    1ccc:	4a18      	ldr	r2, [pc, #96]	; (1d30 <pinMode+0x94>)
    1cce:	189b      	adds	r3, r3, r2
    1cd0:	181a      	adds	r2, r3, r0
    1cd2:	3240      	adds	r2, #64	; 0x40
    1cd4:	7011      	strb	r1, [r2, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1cd6:	2201      	movs	r2, #1
    1cd8:	4082      	lsls	r2, r0
    1cda:	605a      	str	r2, [r3, #4]

    default:
      // do nothing
    break ;
  }
}
    1cdc:	bd30      	pop	{r4, r5, pc}
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    1cde:	6858      	ldr	r0, [r3, #4]
    1ce0:	01cb      	lsls	r3, r1, #7
    1ce2:	2106      	movs	r1, #6
    1ce4:	4a12      	ldr	r2, [pc, #72]	; (1d30 <pinMode+0x94>)
    1ce6:	189b      	adds	r3, r3, r2
    1ce8:	181a      	adds	r2, r3, r0
    1cea:	3240      	adds	r2, #64	; 0x40
    1cec:	7011      	strb	r1, [r2, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1cee:	2201      	movs	r2, #1
    1cf0:	4082      	lsls	r2, r0
    1cf2:	605a      	str	r2, [r3, #4]
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1cf4:	619a      	str	r2, [r3, #24]
    break ;
    1cf6:	e7f1      	b.n	1cdc <pinMode+0x40>
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN|PORT_PINCFG_PULLEN) ;
    1cf8:	6858      	ldr	r0, [r3, #4]
    1cfa:	01cb      	lsls	r3, r1, #7
    1cfc:	2106      	movs	r1, #6
    1cfe:	4a0c      	ldr	r2, [pc, #48]	; (1d30 <pinMode+0x94>)
    1d00:	189b      	adds	r3, r3, r2
    1d02:	181a      	adds	r2, r3, r0
    1d04:	3240      	adds	r2, #64	; 0x40
    1d06:	7011      	strb	r1, [r2, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1d08:	2201      	movs	r2, #1
    1d0a:	4082      	lsls	r2, r0
    1d0c:	605a      	str	r2, [r3, #4]
      PORT->Group[g_APinDescription[ulPin].ulPort].OUTCLR.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1d0e:	615a      	str	r2, [r3, #20]
    break ;
    1d10:	e7e4      	b.n	1cdc <pinMode+0x40>
      PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg=(uint8_t)(PORT_PINCFG_INEN) ;
    1d12:	6858      	ldr	r0, [r3, #4]
    1d14:	01cb      	lsls	r3, r1, #7
    1d16:	2102      	movs	r1, #2
    1d18:	4a05      	ldr	r2, [pc, #20]	; (1d30 <pinMode+0x94>)
    1d1a:	189b      	adds	r3, r3, r2
    1d1c:	181a      	adds	r2, r3, r0
    1d1e:	3240      	adds	r2, #64	; 0x40
    1d20:	7011      	strb	r1, [r2, #0]
      PORT->Group[g_APinDescription[ulPin].ulPort].DIRSET.reg = (uint32_t)(1<<g_APinDescription[ulPin].ulPin) ;
    1d22:	2201      	movs	r2, #1
    1d24:	4082      	lsls	r2, r0
    1d26:	609a      	str	r2, [r3, #8]
    break ;
    1d28:	e7d8      	b.n	1cdc <pinMode+0x40>
    1d2a:	46c0      	nop			; (mov r8, r8)
    1d2c:	00003eb0 	.word	0x00003eb0
    1d30:	41004400 	.word	0x41004400

00001d34 <digitalWrite>:

void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1d34:	2318      	movs	r3, #24
{
    1d36:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1d38:	2408      	movs	r4, #8
    1d3a:	4358      	muls	r0, r3
    1d3c:	4a11      	ldr	r2, [pc, #68]	; (1d84 <digitalWrite+0x50>)
    1d3e:	1813      	adds	r3, r2, r0
    1d40:	571c      	ldrsb	r4, [r3, r4]
    1d42:	3401      	adds	r4, #1
    1d44:	d01b      	beq.n	1d7e <digitalWrite+0x4a>
    return ;
  }

  EPortType port = g_APinDescription[ulPin].ulPort;
  uint32_t pin = g_APinDescription[ulPin].ulPin;
  uint32_t pinMask = (1ul << pin);
    1d46:	2601      	movs	r6, #1
    1d48:	0035      	movs	r5, r6
  uint32_t pin = g_APinDescription[ulPin].ulPin;
    1d4a:	685f      	ldr	r7, [r3, #4]

  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    1d4c:	5683      	ldrsb	r3, [r0, r2]
  uint32_t pinMask = (1ul << pin);
    1d4e:	40bd      	lsls	r5, r7
  if ( (PORT->Group[port].DIRSET.reg & pinMask) == 0 ) {
    1d50:	4a0d      	ldr	r2, [pc, #52]	; (1d88 <digitalWrite+0x54>)
    1d52:	01db      	lsls	r3, r3, #7
    1d54:	189a      	adds	r2, r3, r2
    1d56:	6890      	ldr	r0, [r2, #8]
    1d58:	4228      	tst	r0, r5
    1d5a:	d10b      	bne.n	1d74 <digitalWrite+0x40>
    // the pin is not an output, disable pull-up if val is LOW, otherwise enable pull-up
    PORT->Group[port].PINCFG[pin].bit.PULLEN = ((ulVal == LOW) ? 0 : 1) ;
    1d5c:	000c      	movs	r4, r1
    1d5e:	1e60      	subs	r0, r4, #1
    1d60:	4184      	sbcs	r4, r0
    1d62:	19d2      	adds	r2, r2, r7
    1d64:	3240      	adds	r2, #64	; 0x40
    1d66:	7810      	ldrb	r0, [r2, #0]
    1d68:	4034      	ands	r4, r6
    1d6a:	3603      	adds	r6, #3
    1d6c:	00a4      	lsls	r4, r4, #2
    1d6e:	43b0      	bics	r0, r6
    1d70:	4320      	orrs	r0, r4
    1d72:	7010      	strb	r0, [r2, #0]
  }

  switch ( ulVal )
  {
    case LOW:
      PORT->Group[port].OUTCLR.reg = pinMask;
    1d74:	4a04      	ldr	r2, [pc, #16]	; (1d88 <digitalWrite+0x54>)
    1d76:	189b      	adds	r3, r3, r2
  switch ( ulVal )
    1d78:	2900      	cmp	r1, #0
    1d7a:	d101      	bne.n	1d80 <digitalWrite+0x4c>
      PORT->Group[port].OUTCLR.reg = pinMask;
    1d7c:	615d      	str	r5, [r3, #20]
      PORT->Group[port].OUTSET.reg = pinMask;
    break ;
  }

  return ;
}
    1d7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      PORT->Group[port].OUTSET.reg = pinMask;
    1d80:	619d      	str	r5, [r3, #24]
    break ;
    1d82:	e7fc      	b.n	1d7e <digitalWrite+0x4a>
    1d84:	00003eb0 	.word	0x00003eb0
    1d88:	41004400 	.word	0x41004400

00001d8c <pinPeripheral>:

#include "Arduino.h"
#include "wiring_private.h"

int pinPeripheral( uint32_t ulPin, EPioType ulPeripheral )
{
    1d8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1d8e:	0003      	movs	r3, r0
  // Handle the case the pin isn't usable as PIO
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1d90:	2018      	movs	r0, #24
    1d92:	4358      	muls	r0, r3
    1d94:	4a2a      	ldr	r2, [pc, #168]	; (1e40 <pinPeripheral+0xb4>)
    1d96:	1810      	adds	r0, r2, r0
    1d98:	7a00      	ldrb	r0, [r0, #8]
    1d9a:	b240      	sxtb	r0, r0
  {
    return -1 ;
    1d9c:	0004      	movs	r4, r0
  if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    1d9e:	3001      	adds	r0, #1
    1da0:	d013      	beq.n	1dca <pinPeripheral+0x3e>
  }

  switch ( ulPeripheral )
    1da2:	1c48      	adds	r0, r1, #1
    case PIO_NOT_A_PIN:
      return -1l ;
    break ;
  }

  return 0l ;
    1da4:	2400      	movs	r4, #0
  switch ( ulPeripheral )
    1da6:	280c      	cmp	r0, #12
    1da8:	d80f      	bhi.n	1dca <pinPeripheral+0x3e>
    1daa:	f001 fdff 	bl	39ac <__gnu_thumb1_case_uqi>
    1dae:	1c45      	.short	0x1c45
    1db0:	1c1c1c1c 	.word	0x1c1c1c1c
    1db4:	071c1c1c 	.word	0x071c1c1c
    1db8:	0707      	.short	0x0707
    1dba:	07          	.byte	0x07
    1dbb:	00          	.byte	0x00
      if ( ulPeripheral == PIO_INPUT )
    1dbc:	2909      	cmp	r1, #9
    1dbe:	d106      	bne.n	1dce <pinPeripheral+0x42>
        pinMode( ulPin, INPUT ) ;
    1dc0:	2100      	movs	r1, #0
          pinMode( ulPin, INPUT_PULLUP ) ;
    1dc2:	0018      	movs	r0, r3
    1dc4:	f7ff ff6a 	bl	1c9c <pinMode>
  return 0l ;
    1dc8:	2400      	movs	r4, #0
}
    1dca:	0020      	movs	r0, r4
    1dcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ( ulPeripheral == PIO_INPUT_PULLUP )
    1dce:	290a      	cmp	r1, #10
    1dd0:	d101      	bne.n	1dd6 <pinPeripheral+0x4a>
          pinMode( ulPin, INPUT_PULLUP ) ;
    1dd2:	3908      	subs	r1, #8
    1dd4:	e7f5      	b.n	1dc2 <pinPeripheral+0x36>
  return 0l ;
    1dd6:	2400      	movs	r4, #0
          if ( ulPeripheral == PIO_OUTPUT )
    1dd8:	290b      	cmp	r1, #11
    1dda:	d1f6      	bne.n	1dca <pinPeripheral+0x3e>
            pinMode( ulPin, OUTPUT ) ;
    1ddc:	390a      	subs	r1, #10
    1dde:	0018      	movs	r0, r3
    1de0:	f7ff ff5c 	bl	1c9c <pinMode>
    1de4:	e7f1      	b.n	1dca <pinPeripheral+0x3e>
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    1de6:	2018      	movs	r0, #24
    1de8:	4343      	muls	r3, r0
    1dea:	18d0      	adds	r0, r2, r3
    1dec:	6846      	ldr	r6, [r0, #4]
    1dee:	2501      	movs	r5, #1
    1df0:	0034      	movs	r4, r6
    1df2:	56d2      	ldrsb	r2, [r2, r3]
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    1df4:	4813      	ldr	r0, [pc, #76]	; (1e44 <pinPeripheral+0xb8>)
    1df6:	01d2      	lsls	r2, r2, #7
    1df8:	1812      	adds	r2, r2, r0
    1dfa:	0873      	lsrs	r3, r6, #1
    1dfc:	18d3      	adds	r3, r2, r3
    1dfe:	3330      	adds	r3, #48	; 0x30
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    1e00:	402c      	ands	r4, r5
        temp = (PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg) & PORT_PMUX_PMUXE( 0xF ) ;
    1e02:	7818      	ldrb	r0, [r3, #0]
      if ( g_APinDescription[ulPin].ulPin & 1 ) // is pin odd?
    1e04:	2c00      	cmp	r4, #0
    1e06:	d00b      	beq.n	1e20 <pinPeripheral+0x94>
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    1e08:	240f      	movs	r4, #15
    1e0a:	0109      	lsls	r1, r1, #4
    1e0c:	4020      	ands	r0, r4
    1e0e:	4301      	orrs	r1, r0
    1e10:	b2c9      	uxtb	r1, r1
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    1e12:	1992      	adds	r2, r2, r6
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXO( ulPeripheral ) ;
    1e14:	7019      	strb	r1, [r3, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ;
    1e16:	3240      	adds	r2, #64	; 0x40
    1e18:	7813      	ldrb	r3, [r2, #0]
    1e1a:	431d      	orrs	r5, r3
    1e1c:	7015      	strb	r5, [r2, #0]
    1e1e:	e7d3      	b.n	1dc8 <pinPeripheral+0x3c>
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
    1e20:	270f      	movs	r7, #15
    1e22:	43b8      	bics	r0, r7
    1e24:	4301      	orrs	r1, r0
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    1e26:	1992      	adds	r2, r2, r6
        PORT->Group[g_APinDescription[ulPin].ulPort].PMUX[g_APinDescription[ulPin].ulPin >> 1].reg = temp|PORT_PMUX_PMUXE( ulPeripheral ) ;
    1e28:	b2c9      	uxtb	r1, r1
    1e2a:	7019      	strb	r1, [r3, #0]
        PORT->Group[g_APinDescription[ulPin].ulPort].PINCFG[g_APinDescription[ulPin].ulPin].reg |= PORT_PINCFG_PMUXEN ; // Enable port mux
    1e2c:	0013      	movs	r3, r2
    1e2e:	3340      	adds	r3, #64	; 0x40
    1e30:	781a      	ldrb	r2, [r3, #0]
    1e32:	4315      	orrs	r5, r2
    1e34:	701d      	strb	r5, [r3, #0]
    1e36:	e7c8      	b.n	1dca <pinPeripheral+0x3e>
      return -1l ;
    1e38:	2401      	movs	r4, #1
    1e3a:	4264      	negs	r4, r4
    1e3c:	e7c5      	b.n	1dca <pinPeripheral+0x3e>
    1e3e:	46c0      	nop			; (mov r8, r8)
    1e40:	00003eb0 	.word	0x00003eb0
    1e44:	41004400 	.word	0x41004400

00001e48 <vSetErrorLed>:
//************************************************************************

// set the error led to use by the rtos
void vSetErrorLed(uint8_t pin, uint8_t activeState)
{
	ErrorLed_Pin = pin;
    1e48:	4b02      	ldr	r3, [pc, #8]	; (1e54 <vSetErrorLed+0xc>)
    1e4a:	6018      	str	r0, [r3, #0]
	ErrorLed_ActiveState = activeState;
    1e4c:	4b02      	ldr	r3, [pc, #8]	; (1e58 <vSetErrorLed+0x10>)
    1e4e:	6019      	str	r1, [r3, #0]
}
    1e50:	4770      	bx	lr
    1e52:	46c0      	nop			; (mov r8, r8)
    1e54:	20000030 	.word	0x20000030
    1e58:	200006f0 	.word	0x200006f0

00001e5c <vNopDelayMS>:

// will delay the processors using nops
// this is used when the rtos has crashed and we cannot use more advanced timing
void vNopDelayMS(unsigned long millis) 
{
  unsigned long iterations = millis * CAL_FACTOR;
    1e5c:	23fa      	movs	r3, #250	; 0xfa
    1e5e:	015b      	lsls	r3, r3, #5
    1e60:	4358      	muls	r0, r3
  unsigned long i;
  for(i = 0; i < iterations; ++i) 
    1e62:	2300      	movs	r3, #0
    1e64:	4283      	cmp	r3, r0
    1e66:	d100      	bne.n	1e6a <vNopDelayMS+0xe>
  {
    asm volatile("nop\n\t");
  }
}
    1e68:	4770      	bx	lr
    asm volatile("nop\n\t");
    1e6a:	46c0      	nop			; (mov r8, r8)
  for(i = 0; i < iterations; ++i) 
    1e6c:	3301      	adds	r3, #1
    1e6e:	e7f9      	b.n	1e64 <vNopDelayMS+0x8>

00001e70 <errorBlink>:
{
    1e70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pinMode(ErrorLed_Pin, OUTPUT); 
    1e72:	4d10      	ldr	r5, [pc, #64]	; (1eb4 <errorBlink+0x44>)
{
    1e74:	0006      	movs	r6, r0
  pinMode(ErrorLed_Pin, OUTPUT); 
    1e76:	2101      	movs	r1, #1
    1e78:	6828      	ldr	r0, [r5, #0]
    1e7a:	f7ff ff0f 	bl	1c9c <pinMode>
  for(int x=0; x<errorNumber; ++x)
    1e7e:	2400      	movs	r4, #0
    1e80:	42b4      	cmp	r4, r6
    1e82:	db04      	blt.n	1e8e <errorBlink+0x1e>
  vNopDelayMS(1000);
    1e84:	20fa      	movs	r0, #250	; 0xfa
    1e86:	0080      	lsls	r0, r0, #2
    1e88:	f7ff ffe8 	bl	1e5c <vNopDelayMS>
}
    1e8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    digitalWrite(ErrorLed_Pin,  ErrorLed_ActiveState);   
    1e8e:	4f0a      	ldr	r7, [pc, #40]	; (1eb8 <errorBlink+0x48>)
    1e90:	6828      	ldr	r0, [r5, #0]
    1e92:	6839      	ldr	r1, [r7, #0]
    1e94:	f7ff ff4e 	bl	1d34 <digitalWrite>
    vNopDelayMS(100);
    1e98:	2064      	movs	r0, #100	; 0x64
    1e9a:	f7ff ffdf 	bl	1e5c <vNopDelayMS>
    digitalWrite(ErrorLed_Pin, !ErrorLed_ActiveState);
    1e9e:	6839      	ldr	r1, [r7, #0]
    1ea0:	6828      	ldr	r0, [r5, #0]
    1ea2:	424b      	negs	r3, r1
    1ea4:	4159      	adcs	r1, r3
    1ea6:	f7ff ff45 	bl	1d34 <digitalWrite>
    vNopDelayMS(100);   
    1eaa:	2064      	movs	r0, #100	; 0x64
    1eac:	f7ff ffd6 	bl	1e5c <vNopDelayMS>
  for(int x=0; x<errorNumber; ++x)
    1eb0:	3401      	adds	r4, #1
    1eb2:	e7e5      	b.n	1e80 <errorBlink+0x10>
    1eb4:	20000030 	.word	0x20000030
    1eb8:	200006f0 	.word	0x200006f0

00001ebc <rtosFatalError>:
{
    1ebc:	b510      	push	{r4, lr}
    errorBlink(3);
    1ebe:	2003      	movs	r0, #3
    1ec0:	f7ff ffd6 	bl	1e70 <errorBlink>
    1ec4:	e7fb      	b.n	1ebe <rtosFatalError+0x2>

00001ec6 <vApplicationMallocFailedHook>:
{
    1ec6:	b510      	push	{r4, lr}
    errorBlink(1);
    1ec8:	2001      	movs	r0, #1
    1eca:	f7ff ffd1 	bl	1e70 <errorBlink>
    1ece:	e7fb      	b.n	1ec8 <vApplicationMallocFailedHook+0x2>

00001ed0 <prvResetNextTaskUnblockTime>:
    1ed0:	4a07      	ldr	r2, [pc, #28]	; (1ef0 <prvResetNextTaskUnblockTime+0x20>)
    1ed2:	6813      	ldr	r3, [r2, #0]
    1ed4:	6819      	ldr	r1, [r3, #0]
    1ed6:	4b07      	ldr	r3, [pc, #28]	; (1ef4 <prvResetNextTaskUnblockTime+0x24>)
    1ed8:	2900      	cmp	r1, #0
    1eda:	d103      	bne.n	1ee4 <prvResetNextTaskUnblockTime+0x14>
    1edc:	2201      	movs	r2, #1
    1ede:	4252      	negs	r2, r2
    1ee0:	601a      	str	r2, [r3, #0]
    1ee2:	4770      	bx	lr
    1ee4:	6812      	ldr	r2, [r2, #0]
    1ee6:	68d2      	ldr	r2, [r2, #12]
    1ee8:	68d2      	ldr	r2, [r2, #12]
    1eea:	6852      	ldr	r2, [r2, #4]
    1eec:	e7f8      	b.n	1ee0 <prvResetNextTaskUnblockTime+0x10>
    1eee:	46c0      	nop			; (mov r8, r8)
    1ef0:	200006f8 	.word	0x200006f8
    1ef4:	200007f8 	.word	0x200007f8

00001ef8 <prvAddCurrentTaskToDelayedList>:
    1ef8:	4b0d      	ldr	r3, [pc, #52]	; (1f30 <prvAddCurrentTaskToDelayedList+0x38>)
    1efa:	b510      	push	{r4, lr}
    1efc:	681a      	ldr	r2, [r3, #0]
    1efe:	0004      	movs	r4, r0
    1f00:	6050      	str	r0, [r2, #4]
    1f02:	4a0c      	ldr	r2, [pc, #48]	; (1f34 <prvAddCurrentTaskToDelayedList+0x3c>)
    1f04:	6812      	ldr	r2, [r2, #0]
    1f06:	4290      	cmp	r0, r2
    1f08:	d206      	bcs.n	1f18 <prvAddCurrentTaskToDelayedList+0x20>
    1f0a:	4a0b      	ldr	r2, [pc, #44]	; (1f38 <prvAddCurrentTaskToDelayedList+0x40>)
    1f0c:	6810      	ldr	r0, [r2, #0]
    1f0e:	6819      	ldr	r1, [r3, #0]
    1f10:	3104      	adds	r1, #4
    1f12:	f001 f97d 	bl	3210 <vListInsert>
    1f16:	bd10      	pop	{r4, pc}
    1f18:	4a08      	ldr	r2, [pc, #32]	; (1f3c <prvAddCurrentTaskToDelayedList+0x44>)
    1f1a:	6810      	ldr	r0, [r2, #0]
    1f1c:	6819      	ldr	r1, [r3, #0]
    1f1e:	3104      	adds	r1, #4
    1f20:	f001 f976 	bl	3210 <vListInsert>
    1f24:	4b06      	ldr	r3, [pc, #24]	; (1f40 <prvAddCurrentTaskToDelayedList+0x48>)
    1f26:	681a      	ldr	r2, [r3, #0]
    1f28:	4294      	cmp	r4, r2
    1f2a:	d2f4      	bcs.n	1f16 <prvAddCurrentTaskToDelayedList+0x1e>
    1f2c:	601c      	str	r4, [r3, #0]
    1f2e:	e7f2      	b.n	1f16 <prvAddCurrentTaskToDelayedList+0x1e>
    1f30:	200006f4 	.word	0x200006f4
    1f34:	20000840 	.word	0x20000840
    1f38:	200006fc 	.word	0x200006fc
    1f3c:	200006f8 	.word	0x200006f8
    1f40:	200007f8 	.word	0x200007f8

00001f44 <xTaskGenericCreate>:
    1f44:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f46:	b085      	sub	sp, #20
    1f48:	0006      	movs	r6, r0
    1f4a:	9101      	str	r1, [sp, #4]
    1f4c:	0014      	movs	r4, r2
    1f4e:	9303      	str	r3, [sp, #12]
    1f50:	2800      	cmp	r0, #0
    1f52:	d102      	bne.n	1f5a <xTaskGenericCreate+0x16>
    1f54:	b672      	cpsid	i
    1f56:	f7ff ffb1 	bl	1ebc <rtosFatalError>
    1f5a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1f5c:	2b08      	cmp	r3, #8
    1f5e:	d902      	bls.n	1f66 <xTaskGenericCreate+0x22>
    1f60:	b672      	cpsid	i
    1f62:	f7ff ffab 	bl	1ebc <rtosFatalError>
    1f66:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    1f68:	2d00      	cmp	r5, #0
    1f6a:	d105      	bne.n	1f78 <xTaskGenericCreate+0x34>
    1f6c:	00a0      	lsls	r0, r4, #2
    1f6e:	f001 f895 	bl	309c <pvPortMalloc>
    1f72:	1e05      	subs	r5, r0, #0
    1f74:	d100      	bne.n	1f78 <xTaskGenericCreate+0x34>
    1f76:	e097      	b.n	20a8 <xTaskGenericCreate+0x164>
    1f78:	2054      	movs	r0, #84	; 0x54
    1f7a:	f001 f88f 	bl	309c <pvPortMalloc>
    1f7e:	1e07      	subs	r7, r0, #0
    1f80:	d100      	bne.n	1f84 <xTaskGenericCreate+0x40>
    1f82:	e08e      	b.n	20a2 <xTaskGenericCreate+0x15e>
    1f84:	00a4      	lsls	r4, r4, #2
    1f86:	6305      	str	r5, [r0, #48]	; 0x30
    1f88:	0022      	movs	r2, r4
    1f8a:	21a5      	movs	r1, #165	; 0xa5
    1f8c:	0028      	movs	r0, r5
    1f8e:	f001 fde4 	bl	3b5a <memset>
    1f92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    1f94:	3c04      	subs	r4, #4
    1f96:	191c      	adds	r4, r3, r4
    1f98:	2307      	movs	r3, #7
    1f9a:	439c      	bics	r4, r3
    1f9c:	2300      	movs	r3, #0
    1f9e:	9402      	str	r4, [sp, #8]
    1fa0:	9a01      	ldr	r2, [sp, #4]
    1fa2:	5cd1      	ldrb	r1, [r2, r3]
    1fa4:	001a      	movs	r2, r3
    1fa6:	3234      	adds	r2, #52	; 0x34
    1fa8:	54b9      	strb	r1, [r7, r2]
    1faa:	9a01      	ldr	r2, [sp, #4]
    1fac:	5cd2      	ldrb	r2, [r2, r3]
    1fae:	2a00      	cmp	r2, #0
    1fb0:	d002      	beq.n	1fb8 <xTaskGenericCreate+0x74>
    1fb2:	3301      	adds	r3, #1
    1fb4:	2b08      	cmp	r3, #8
    1fb6:	d1f3      	bne.n	1fa0 <xTaskGenericCreate+0x5c>
    1fb8:	003b      	movs	r3, r7
    1fba:	2400      	movs	r4, #0
    1fbc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    1fbe:	333b      	adds	r3, #59	; 0x3b
    1fc0:	701c      	strb	r4, [r3, #0]
    1fc2:	2d08      	cmp	r5, #8
    1fc4:	d900      	bls.n	1fc8 <xTaskGenericCreate+0x84>
    1fc6:	2508      	movs	r5, #8
    1fc8:	1d3b      	adds	r3, r7, #4
    1fca:	0018      	movs	r0, r3
    1fcc:	62fd      	str	r5, [r7, #44]	; 0x2c
    1fce:	647d      	str	r5, [r7, #68]	; 0x44
    1fd0:	64bc      	str	r4, [r7, #72]	; 0x48
    1fd2:	9301      	str	r3, [sp, #4]
    1fd4:	f001 f90d 	bl	31f2 <vListInitialiseItem>
    1fd8:	0038      	movs	r0, r7
    1fda:	3018      	adds	r0, #24
    1fdc:	f001 f909 	bl	31f2 <vListInitialiseItem>
    1fe0:	2309      	movs	r3, #9
    1fe2:	1b5d      	subs	r5, r3, r5
    1fe4:	003b      	movs	r3, r7
    1fe6:	3350      	adds	r3, #80	; 0x50
    1fe8:	613f      	str	r7, [r7, #16]
    1fea:	61bd      	str	r5, [r7, #24]
    1fec:	627f      	str	r7, [r7, #36]	; 0x24
    1fee:	64fc      	str	r4, [r7, #76]	; 0x4c
    1ff0:	9a03      	ldr	r2, [sp, #12]
    1ff2:	701c      	strb	r4, [r3, #0]
    1ff4:	0031      	movs	r1, r6
    1ff6:	9802      	ldr	r0, [sp, #8]
    1ff8:	f001 f94e 	bl	3298 <pxPortInitialiseStack>
    1ffc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ffe:	6038      	str	r0, [r7, #0]
    2000:	2b00      	cmp	r3, #0
    2002:	d000      	beq.n	2006 <xTaskGenericCreate+0xc2>
    2004:	601f      	str	r7, [r3, #0]
    2006:	f001 f96d 	bl	32e4 <vPortEnterCritical>
    200a:	4b2e      	ldr	r3, [pc, #184]	; (20c4 <xTaskGenericCreate+0x180>)
    200c:	4c2e      	ldr	r4, [pc, #184]	; (20c8 <xTaskGenericCreate+0x184>)
    200e:	681a      	ldr	r2, [r3, #0]
    2010:	4d2e      	ldr	r5, [pc, #184]	; (20cc <xTaskGenericCreate+0x188>)
    2012:	3201      	adds	r2, #1
    2014:	601a      	str	r2, [r3, #0]
    2016:	6822      	ldr	r2, [r4, #0]
    2018:	2a00      	cmp	r2, #0
    201a:	d148      	bne.n	20ae <xTaskGenericCreate+0x16a>
    201c:	6027      	str	r7, [r4, #0]
    201e:	681b      	ldr	r3, [r3, #0]
    2020:	2b01      	cmp	r3, #1
    2022:	d11c      	bne.n	205e <xTaskGenericCreate+0x11a>
    2024:	002e      	movs	r6, r5
    2026:	0030      	movs	r0, r6
    2028:	f001 f8d8 	bl	31dc <vListInitialise>
    202c:	4b28      	ldr	r3, [pc, #160]	; (20d0 <xTaskGenericCreate+0x18c>)
    202e:	3614      	adds	r6, #20
    2030:	42b3      	cmp	r3, r6
    2032:	d1f8      	bne.n	2026 <xTaskGenericCreate+0xe2>
    2034:	4827      	ldr	r0, [pc, #156]	; (20d4 <xTaskGenericCreate+0x190>)
    2036:	f001 f8d1 	bl	31dc <vListInitialise>
    203a:	4e27      	ldr	r6, [pc, #156]	; (20d8 <xTaskGenericCreate+0x194>)
    203c:	0030      	movs	r0, r6
    203e:	f001 f8cd 	bl	31dc <vListInitialise>
    2042:	4826      	ldr	r0, [pc, #152]	; (20dc <xTaskGenericCreate+0x198>)
    2044:	f001 f8ca 	bl	31dc <vListInitialise>
    2048:	4825      	ldr	r0, [pc, #148]	; (20e0 <xTaskGenericCreate+0x19c>)
    204a:	f001 f8c7 	bl	31dc <vListInitialise>
    204e:	4825      	ldr	r0, [pc, #148]	; (20e4 <xTaskGenericCreate+0x1a0>)
    2050:	f001 f8c4 	bl	31dc <vListInitialise>
    2054:	4b24      	ldr	r3, [pc, #144]	; (20e8 <xTaskGenericCreate+0x1a4>)
    2056:	4a1f      	ldr	r2, [pc, #124]	; (20d4 <xTaskGenericCreate+0x190>)
    2058:	601a      	str	r2, [r3, #0]
    205a:	4b24      	ldr	r3, [pc, #144]	; (20ec <xTaskGenericCreate+0x1a8>)
    205c:	601e      	str	r6, [r3, #0]
    205e:	4a24      	ldr	r2, [pc, #144]	; (20f0 <xTaskGenericCreate+0x1ac>)
    2060:	6813      	ldr	r3, [r2, #0]
    2062:	3301      	adds	r3, #1
    2064:	6013      	str	r3, [r2, #0]
    2066:	4a23      	ldr	r2, [pc, #140]	; (20f4 <xTaskGenericCreate+0x1b0>)
    2068:	63fb      	str	r3, [r7, #60]	; 0x3c
    206a:	6811      	ldr	r1, [r2, #0]
    206c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    206e:	428b      	cmp	r3, r1
    2070:	d900      	bls.n	2074 <xTaskGenericCreate+0x130>
    2072:	6013      	str	r3, [r2, #0]
    2074:	2014      	movs	r0, #20
    2076:	4358      	muls	r0, r3
    2078:	9901      	ldr	r1, [sp, #4]
    207a:	1828      	adds	r0, r5, r0
    207c:	f001 f8bc 	bl	31f8 <vListInsertEnd>
    2080:	f001 f93c 	bl	32fc <vPortExitCritical>
    2084:	4b1c      	ldr	r3, [pc, #112]	; (20f8 <xTaskGenericCreate+0x1b4>)
    2086:	2501      	movs	r5, #1
    2088:	681b      	ldr	r3, [r3, #0]
    208a:	2b00      	cmp	r3, #0
    208c:	d006      	beq.n	209c <xTaskGenericCreate+0x158>
    208e:	6823      	ldr	r3, [r4, #0]
    2090:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    2092:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2094:	429a      	cmp	r2, r3
    2096:	d901      	bls.n	209c <xTaskGenericCreate+0x158>
    2098:	f001 f918 	bl	32cc <vPortYield>
    209c:	0028      	movs	r0, r5
    209e:	b005      	add	sp, #20
    20a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    20a2:	0028      	movs	r0, r5
    20a4:	f001 f868 	bl	3178 <vPortFree>
    20a8:	2501      	movs	r5, #1
    20aa:	426d      	negs	r5, r5
    20ac:	e7f6      	b.n	209c <xTaskGenericCreate+0x158>
    20ae:	4b12      	ldr	r3, [pc, #72]	; (20f8 <xTaskGenericCreate+0x1b4>)
    20b0:	681b      	ldr	r3, [r3, #0]
    20b2:	2b00      	cmp	r3, #0
    20b4:	d1d3      	bne.n	205e <xTaskGenericCreate+0x11a>
    20b6:	6823      	ldr	r3, [r4, #0]
    20b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    20ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    20bc:	429a      	cmp	r2, r3
    20be:	d3ce      	bcc.n	205e <xTaskGenericCreate+0x11a>
    20c0:	6027      	str	r7, [r4, #0]
    20c2:	e7cc      	b.n	205e <xTaskGenericCreate+0x11a>
    20c4:	200007b4 	.word	0x200007b4
    20c8:	200006f4 	.word	0x200006f4
    20cc:	20000700 	.word	0x20000700
    20d0:	200007b4 	.word	0x200007b4
    20d4:	200007cc 	.word	0x200007cc
    20d8:	200007e0 	.word	0x200007e0
    20dc:	20000800 	.word	0x20000800
    20e0:	2000082c 	.word	0x2000082c
    20e4:	20000818 	.word	0x20000818
    20e8:	200006f8 	.word	0x200006f8
    20ec:	200006fc 	.word	0x200006fc
    20f0:	200007c0 	.word	0x200007c0
    20f4:	200007c8 	.word	0x200007c8
    20f8:	20000814 	.word	0x20000814

000020fc <vTaskDelete>:
    20fc:	b570      	push	{r4, r5, r6, lr}
    20fe:	0004      	movs	r4, r0
    2100:	f001 f8f0 	bl	32e4 <vPortEnterCritical>
    2104:	2c00      	cmp	r4, #0
    2106:	d101      	bne.n	210c <vTaskDelete+0x10>
    2108:	4b19      	ldr	r3, [pc, #100]	; (2170 <vTaskDelete+0x74>)
    210a:	681c      	ldr	r4, [r3, #0]
    210c:	1d25      	adds	r5, r4, #4
    210e:	0028      	movs	r0, r5
    2110:	f001 f895 	bl	323e <uxListRemove>
    2114:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2116:	2b00      	cmp	r3, #0
    2118:	d003      	beq.n	2122 <vTaskDelete+0x26>
    211a:	0020      	movs	r0, r4
    211c:	3018      	adds	r0, #24
    211e:	f001 f88e 	bl	323e <uxListRemove>
    2122:	0029      	movs	r1, r5
    2124:	4813      	ldr	r0, [pc, #76]	; (2174 <vTaskDelete+0x78>)
    2126:	f001 f867 	bl	31f8 <vListInsertEnd>
    212a:	4a13      	ldr	r2, [pc, #76]	; (2178 <vTaskDelete+0x7c>)
    212c:	6813      	ldr	r3, [r2, #0]
    212e:	3301      	adds	r3, #1
    2130:	6013      	str	r3, [r2, #0]
    2132:	4a12      	ldr	r2, [pc, #72]	; (217c <vTaskDelete+0x80>)
    2134:	6813      	ldr	r3, [r2, #0]
    2136:	3301      	adds	r3, #1
    2138:	6013      	str	r3, [r2, #0]
    213a:	f001 f8df 	bl	32fc <vPortExitCritical>
    213e:	4b10      	ldr	r3, [pc, #64]	; (2180 <vTaskDelete+0x84>)
    2140:	681b      	ldr	r3, [r3, #0]
    2142:	2b00      	cmp	r3, #0
    2144:	d00c      	beq.n	2160 <vTaskDelete+0x64>
    2146:	4b0a      	ldr	r3, [pc, #40]	; (2170 <vTaskDelete+0x74>)
    2148:	681b      	ldr	r3, [r3, #0]
    214a:	429c      	cmp	r4, r3
    214c:	d109      	bne.n	2162 <vTaskDelete+0x66>
    214e:	4b0d      	ldr	r3, [pc, #52]	; (2184 <vTaskDelete+0x88>)
    2150:	681b      	ldr	r3, [r3, #0]
    2152:	2b00      	cmp	r3, #0
    2154:	d002      	beq.n	215c <vTaskDelete+0x60>
    2156:	b672      	cpsid	i
    2158:	f7ff feb0 	bl	1ebc <rtosFatalError>
    215c:	f001 f8b6 	bl	32cc <vPortYield>
    2160:	bd70      	pop	{r4, r5, r6, pc}
    2162:	f001 f8bf 	bl	32e4 <vPortEnterCritical>
    2166:	f7ff feb3 	bl	1ed0 <prvResetNextTaskUnblockTime>
    216a:	f001 f8c7 	bl	32fc <vPortExitCritical>
    216e:	e7f7      	b.n	2160 <vTaskDelete+0x64>
    2170:	200006f4 	.word	0x200006f4
    2174:	2000082c 	.word	0x2000082c
    2178:	200007c4 	.word	0x200007c4
    217c:	200007c0 	.word	0x200007c0
    2180:	20000814 	.word	0x20000814
    2184:	200007bc 	.word	0x200007bc

00002188 <vTaskStartScheduler>:
    2188:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    218a:	2400      	movs	r4, #0
    218c:	4b11      	ldr	r3, [pc, #68]	; (21d4 <vTaskStartScheduler+0x4c>)
    218e:	9403      	str	r4, [sp, #12]
    2190:	9301      	str	r3, [sp, #4]
    2192:	9402      	str	r4, [sp, #8]
    2194:	9400      	str	r4, [sp, #0]
    2196:	0023      	movs	r3, r4
    2198:	2296      	movs	r2, #150	; 0x96
    219a:	490f      	ldr	r1, [pc, #60]	; (21d8 <vTaskStartScheduler+0x50>)
    219c:	480f      	ldr	r0, [pc, #60]	; (21dc <vTaskStartScheduler+0x54>)
    219e:	f7ff fed1 	bl	1f44 <xTaskGenericCreate>
    21a2:	2801      	cmp	r0, #1
    21a4:	d10f      	bne.n	21c6 <vTaskStartScheduler+0x3e>
    21a6:	f000 fb77 	bl	2898 <xTimerCreateTimerTask>
    21aa:	2801      	cmp	r0, #1
    21ac:	d10b      	bne.n	21c6 <vTaskStartScheduler+0x3e>
    21ae:	b672      	cpsid	i
    21b0:	2201      	movs	r2, #1
    21b2:	4b0b      	ldr	r3, [pc, #44]	; (21e0 <vTaskStartScheduler+0x58>)
    21b4:	4252      	negs	r2, r2
    21b6:	601a      	str	r2, [r3, #0]
    21b8:	4b0a      	ldr	r3, [pc, #40]	; (21e4 <vTaskStartScheduler+0x5c>)
    21ba:	6018      	str	r0, [r3, #0]
    21bc:	4b0a      	ldr	r3, [pc, #40]	; (21e8 <vTaskStartScheduler+0x60>)
    21be:	601c      	str	r4, [r3, #0]
    21c0:	f001 f8fc 	bl	33bc <xPortStartScheduler>
    21c4:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    21c6:	2800      	cmp	r0, #0
    21c8:	d1fc      	bne.n	21c4 <vTaskStartScheduler+0x3c>
    21ca:	b672      	cpsid	i
    21cc:	f7ff fe76 	bl	1ebc <rtosFatalError>
    21d0:	e7f8      	b.n	21c4 <vTaskStartScheduler+0x3c>
    21d2:	46c0      	nop			; (mov r8, r8)
    21d4:	200007f4 	.word	0x200007f4
    21d8:	00003e9e 	.word	0x00003e9e
    21dc:	00002435 	.word	0x00002435
    21e0:	200007f8 	.word	0x200007f8
    21e4:	20000814 	.word	0x20000814
    21e8:	20000840 	.word	0x20000840

000021ec <vTaskSuspendAll>:
    21ec:	4a02      	ldr	r2, [pc, #8]	; (21f8 <vTaskSuspendAll+0xc>)
    21ee:	6813      	ldr	r3, [r2, #0]
    21f0:	3301      	adds	r3, #1
    21f2:	6013      	str	r3, [r2, #0]
    21f4:	4770      	bx	lr
    21f6:	46c0      	nop			; (mov r8, r8)
    21f8:	200007bc 	.word	0x200007bc

000021fc <xTaskGetTickCount>:
    21fc:	b510      	push	{r4, lr}
    21fe:	f001 f871 	bl	32e4 <vPortEnterCritical>
    2202:	4b03      	ldr	r3, [pc, #12]	; (2210 <xTaskGetTickCount+0x14>)
    2204:	681c      	ldr	r4, [r3, #0]
    2206:	f001 f879 	bl	32fc <vPortExitCritical>
    220a:	0020      	movs	r0, r4
    220c:	bd10      	pop	{r4, pc}
    220e:	46c0      	nop			; (mov r8, r8)
    2210:	20000840 	.word	0x20000840

00002214 <xTaskIncrementTick>:
    2214:	4b35      	ldr	r3, [pc, #212]	; (22ec <xTaskIncrementTick+0xd8>)
    2216:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2218:	681b      	ldr	r3, [r3, #0]
    221a:	2b00      	cmp	r3, #0
    221c:	d147      	bne.n	22ae <xTaskIncrementTick+0x9a>
    221e:	4b34      	ldr	r3, [pc, #208]	; (22f0 <xTaskIncrementTick+0xdc>)
    2220:	681a      	ldr	r2, [r3, #0]
    2222:	3201      	adds	r2, #1
    2224:	601a      	str	r2, [r3, #0]
    2226:	681f      	ldr	r7, [r3, #0]
    2228:	2f00      	cmp	r7, #0
    222a:	d112      	bne.n	2252 <xTaskIncrementTick+0x3e>
    222c:	4c31      	ldr	r4, [pc, #196]	; (22f4 <xTaskIncrementTick+0xe0>)
    222e:	6823      	ldr	r3, [r4, #0]
    2230:	681b      	ldr	r3, [r3, #0]
    2232:	2b00      	cmp	r3, #0
    2234:	d002      	beq.n	223c <xTaskIncrementTick+0x28>
    2236:	b672      	cpsid	i
    2238:	f7ff fe40 	bl	1ebc <rtosFatalError>
    223c:	4b2e      	ldr	r3, [pc, #184]	; (22f8 <xTaskIncrementTick+0xe4>)
    223e:	6822      	ldr	r2, [r4, #0]
    2240:	6819      	ldr	r1, [r3, #0]
    2242:	6021      	str	r1, [r4, #0]
    2244:	601a      	str	r2, [r3, #0]
    2246:	4a2d      	ldr	r2, [pc, #180]	; (22fc <xTaskIncrementTick+0xe8>)
    2248:	6813      	ldr	r3, [r2, #0]
    224a:	3301      	adds	r3, #1
    224c:	6013      	str	r3, [r2, #0]
    224e:	f7ff fe3f 	bl	1ed0 <prvResetNextTaskUnblockTime>
    2252:	4e2b      	ldr	r6, [pc, #172]	; (2300 <xTaskIncrementTick+0xec>)
    2254:	2500      	movs	r5, #0
    2256:	6833      	ldr	r3, [r6, #0]
    2258:	429f      	cmp	r7, r3
    225a:	d335      	bcc.n	22c8 <xTaskIncrementTick+0xb4>
    225c:	4b25      	ldr	r3, [pc, #148]	; (22f4 <xTaskIncrementTick+0xe0>)
    225e:	681a      	ldr	r2, [r3, #0]
    2260:	6812      	ldr	r2, [r2, #0]
    2262:	2a00      	cmp	r2, #0
    2264:	d129      	bne.n	22ba <xTaskIncrementTick+0xa6>
    2266:	2301      	movs	r3, #1
    2268:	425b      	negs	r3, r3
    226a:	e02c      	b.n	22c6 <xTaskIncrementTick+0xb2>
    226c:	1d23      	adds	r3, r4, #4
    226e:	0018      	movs	r0, r3
    2270:	9301      	str	r3, [sp, #4]
    2272:	f000 ffe4 	bl	323e <uxListRemove>
    2276:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    2278:	2b00      	cmp	r3, #0
    227a:	d003      	beq.n	2284 <xTaskIncrementTick+0x70>
    227c:	0020      	movs	r0, r4
    227e:	3018      	adds	r0, #24
    2280:	f000 ffdd 	bl	323e <uxListRemove>
    2284:	4b1f      	ldr	r3, [pc, #124]	; (2304 <xTaskIncrementTick+0xf0>)
    2286:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    2288:	681a      	ldr	r2, [r3, #0]
    228a:	4290      	cmp	r0, r2
    228c:	d900      	bls.n	2290 <xTaskIncrementTick+0x7c>
    228e:	6018      	str	r0, [r3, #0]
    2290:	2314      	movs	r3, #20
    2292:	4358      	muls	r0, r3
    2294:	4b1c      	ldr	r3, [pc, #112]	; (2308 <xTaskIncrementTick+0xf4>)
    2296:	1d21      	adds	r1, r4, #4
    2298:	1818      	adds	r0, r3, r0
    229a:	f000 ffad 	bl	31f8 <vListInsertEnd>
    229e:	4b1b      	ldr	r3, [pc, #108]	; (230c <xTaskIncrementTick+0xf8>)
    22a0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    22a2:	681b      	ldr	r3, [r3, #0]
    22a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    22a6:	429a      	cmp	r2, r3
    22a8:	d3d8      	bcc.n	225c <xTaskIncrementTick+0x48>
    22aa:	2501      	movs	r5, #1
    22ac:	e7d6      	b.n	225c <xTaskIncrementTick+0x48>
    22ae:	4a18      	ldr	r2, [pc, #96]	; (2310 <xTaskIncrementTick+0xfc>)
    22b0:	2500      	movs	r5, #0
    22b2:	6813      	ldr	r3, [r2, #0]
    22b4:	3301      	adds	r3, #1
    22b6:	6013      	str	r3, [r2, #0]
    22b8:	e010      	b.n	22dc <xTaskIncrementTick+0xc8>
    22ba:	681b      	ldr	r3, [r3, #0]
    22bc:	68db      	ldr	r3, [r3, #12]
    22be:	68dc      	ldr	r4, [r3, #12]
    22c0:	6863      	ldr	r3, [r4, #4]
    22c2:	429f      	cmp	r7, r3
    22c4:	d2d2      	bcs.n	226c <xTaskIncrementTick+0x58>
    22c6:	6033      	str	r3, [r6, #0]
    22c8:	4b10      	ldr	r3, [pc, #64]	; (230c <xTaskIncrementTick+0xf8>)
    22ca:	681b      	ldr	r3, [r3, #0]
    22cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    22ce:	2314      	movs	r3, #20
    22d0:	4353      	muls	r3, r2
    22d2:	4a0d      	ldr	r2, [pc, #52]	; (2308 <xTaskIncrementTick+0xf4>)
    22d4:	58d3      	ldr	r3, [r2, r3]
    22d6:	2b01      	cmp	r3, #1
    22d8:	d900      	bls.n	22dc <xTaskIncrementTick+0xc8>
    22da:	2501      	movs	r5, #1
    22dc:	4b0d      	ldr	r3, [pc, #52]	; (2314 <xTaskIncrementTick+0x100>)
    22de:	681b      	ldr	r3, [r3, #0]
    22e0:	2b00      	cmp	r3, #0
    22e2:	d000      	beq.n	22e6 <xTaskIncrementTick+0xd2>
    22e4:	2501      	movs	r5, #1
    22e6:	0028      	movs	r0, r5
    22e8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    22ea:	46c0      	nop			; (mov r8, r8)
    22ec:	200007bc 	.word	0x200007bc
    22f0:	20000840 	.word	0x20000840
    22f4:	200006f8 	.word	0x200006f8
    22f8:	200006fc 	.word	0x200006fc
    22fc:	200007fc 	.word	0x200007fc
    2300:	200007f8 	.word	0x200007f8
    2304:	200007c8 	.word	0x200007c8
    2308:	20000700 	.word	0x20000700
    230c:	200006f4 	.word	0x200006f4
    2310:	200007b8 	.word	0x200007b8
    2314:	20000844 	.word	0x20000844

00002318 <xTaskResumeAll>:
    2318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    231a:	4c2b      	ldr	r4, [pc, #172]	; (23c8 <xTaskResumeAll+0xb0>)
    231c:	6823      	ldr	r3, [r4, #0]
    231e:	2b00      	cmp	r3, #0
    2320:	d102      	bne.n	2328 <xTaskResumeAll+0x10>
    2322:	b672      	cpsid	i
    2324:	f7ff fdca 	bl	1ebc <rtosFatalError>
    2328:	f000 ffdc 	bl	32e4 <vPortEnterCritical>
    232c:	6823      	ldr	r3, [r4, #0]
    232e:	3b01      	subs	r3, #1
    2330:	6023      	str	r3, [r4, #0]
    2332:	6823      	ldr	r3, [r4, #0]
    2334:	2b00      	cmp	r3, #0
    2336:	d004      	beq.n	2342 <xTaskResumeAll+0x2a>
    2338:	2400      	movs	r4, #0
    233a:	f000 ffdf 	bl	32fc <vPortExitCritical>
    233e:	0020      	movs	r0, r4
    2340:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2342:	4b22      	ldr	r3, [pc, #136]	; (23cc <xTaskResumeAll+0xb4>)
    2344:	681b      	ldr	r3, [r3, #0]
    2346:	2b00      	cmp	r3, #0
    2348:	d0f6      	beq.n	2338 <xTaskResumeAll+0x20>
    234a:	2614      	movs	r6, #20
    234c:	2701      	movs	r7, #1
    234e:	e01d      	b.n	238c <xTaskResumeAll+0x74>
    2350:	68db      	ldr	r3, [r3, #12]
    2352:	68dc      	ldr	r4, [r3, #12]
    2354:	0020      	movs	r0, r4
    2356:	1d25      	adds	r5, r4, #4
    2358:	3018      	adds	r0, #24
    235a:	f000 ff70 	bl	323e <uxListRemove>
    235e:	0028      	movs	r0, r5
    2360:	f000 ff6d 	bl	323e <uxListRemove>
    2364:	4b1a      	ldr	r3, [pc, #104]	; (23d0 <xTaskResumeAll+0xb8>)
    2366:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    2368:	681a      	ldr	r2, [r3, #0]
    236a:	4290      	cmp	r0, r2
    236c:	d900      	bls.n	2370 <xTaskResumeAll+0x58>
    236e:	6018      	str	r0, [r3, #0]
    2370:	4370      	muls	r0, r6
    2372:	4b18      	ldr	r3, [pc, #96]	; (23d4 <xTaskResumeAll+0xbc>)
    2374:	0029      	movs	r1, r5
    2376:	1818      	adds	r0, r3, r0
    2378:	f000 ff3e 	bl	31f8 <vListInsertEnd>
    237c:	4b16      	ldr	r3, [pc, #88]	; (23d8 <xTaskResumeAll+0xc0>)
    237e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2380:	681b      	ldr	r3, [r3, #0]
    2382:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2384:	429a      	cmp	r2, r3
    2386:	d301      	bcc.n	238c <xTaskResumeAll+0x74>
    2388:	4b14      	ldr	r3, [pc, #80]	; (23dc <xTaskResumeAll+0xc4>)
    238a:	601f      	str	r7, [r3, #0]
    238c:	4b14      	ldr	r3, [pc, #80]	; (23e0 <xTaskResumeAll+0xc8>)
    238e:	681a      	ldr	r2, [r3, #0]
    2390:	2a00      	cmp	r2, #0
    2392:	d1dd      	bne.n	2350 <xTaskResumeAll+0x38>
    2394:	4c13      	ldr	r4, [pc, #76]	; (23e4 <xTaskResumeAll+0xcc>)
    2396:	6823      	ldr	r3, [r4, #0]
    2398:	2b00      	cmp	r3, #0
    239a:	d113      	bne.n	23c4 <xTaskResumeAll+0xac>
    239c:	4b0f      	ldr	r3, [pc, #60]	; (23dc <xTaskResumeAll+0xc4>)
    239e:	681c      	ldr	r4, [r3, #0]
    23a0:	2c01      	cmp	r4, #1
    23a2:	d1c9      	bne.n	2338 <xTaskResumeAll+0x20>
    23a4:	f000 ff92 	bl	32cc <vPortYield>
    23a8:	e7c7      	b.n	233a <xTaskResumeAll+0x22>
    23aa:	f7ff ff33 	bl	2214 <xTaskIncrementTick>
    23ae:	2800      	cmp	r0, #0
    23b0:	d001      	beq.n	23b6 <xTaskResumeAll+0x9e>
    23b2:	4b0a      	ldr	r3, [pc, #40]	; (23dc <xTaskResumeAll+0xc4>)
    23b4:	601d      	str	r5, [r3, #0]
    23b6:	6823      	ldr	r3, [r4, #0]
    23b8:	3b01      	subs	r3, #1
    23ba:	6023      	str	r3, [r4, #0]
    23bc:	6823      	ldr	r3, [r4, #0]
    23be:	2b00      	cmp	r3, #0
    23c0:	d1f3      	bne.n	23aa <xTaskResumeAll+0x92>
    23c2:	e7eb      	b.n	239c <xTaskResumeAll+0x84>
    23c4:	2501      	movs	r5, #1
    23c6:	e7f9      	b.n	23bc <xTaskResumeAll+0xa4>
    23c8:	200007bc 	.word	0x200007bc
    23cc:	200007b4 	.word	0x200007b4
    23d0:	200007c8 	.word	0x200007c8
    23d4:	20000700 	.word	0x20000700
    23d8:	200006f4 	.word	0x200006f4
    23dc:	20000844 	.word	0x20000844
    23e0:	20000800 	.word	0x20000800
    23e4:	200007b8 	.word	0x200007b8

000023e8 <vTaskDelay>:
    23e8:	b510      	push	{r4, lr}
    23ea:	1e04      	subs	r4, r0, #0
    23ec:	d102      	bne.n	23f4 <vTaskDelay+0xc>
    23ee:	f000 ff6d 	bl	32cc <vPortYield>
    23f2:	bd10      	pop	{r4, pc}
    23f4:	4b0c      	ldr	r3, [pc, #48]	; (2428 <vTaskDelay+0x40>)
    23f6:	681b      	ldr	r3, [r3, #0]
    23f8:	2b00      	cmp	r3, #0
    23fa:	d002      	beq.n	2402 <vTaskDelay+0x1a>
    23fc:	b672      	cpsid	i
    23fe:	f7ff fd5d 	bl	1ebc <rtosFatalError>
    2402:	f7ff fef3 	bl	21ec <vTaskSuspendAll>
    2406:	4b09      	ldr	r3, [pc, #36]	; (242c <vTaskDelay+0x44>)
    2408:	681b      	ldr	r3, [r3, #0]
    240a:	18e4      	adds	r4, r4, r3
    240c:	4b08      	ldr	r3, [pc, #32]	; (2430 <vTaskDelay+0x48>)
    240e:	6818      	ldr	r0, [r3, #0]
    2410:	3004      	adds	r0, #4
    2412:	f000 ff14 	bl	323e <uxListRemove>
    2416:	0020      	movs	r0, r4
    2418:	f7ff fd6e 	bl	1ef8 <prvAddCurrentTaskToDelayedList>
    241c:	f7ff ff7c 	bl	2318 <xTaskResumeAll>
    2420:	2800      	cmp	r0, #0
    2422:	d1e6      	bne.n	23f2 <vTaskDelay+0xa>
    2424:	e7e3      	b.n	23ee <vTaskDelay+0x6>
    2426:	46c0      	nop			; (mov r8, r8)
    2428:	200007bc 	.word	0x200007bc
    242c:	20000840 	.word	0x20000840
    2430:	200006f4 	.word	0x200006f4

00002434 <prvIdleTask>:
    2434:	b570      	push	{r4, r5, r6, lr}
    2436:	4c16      	ldr	r4, [pc, #88]	; (2490 <prvIdleTask+0x5c>)
    2438:	6823      	ldr	r3, [r4, #0]
    243a:	2b00      	cmp	r3, #0
    243c:	d108      	bne.n	2450 <prvIdleTask+0x1c>
    243e:	4b15      	ldr	r3, [pc, #84]	; (2494 <prvIdleTask+0x60>)
    2440:	681b      	ldr	r3, [r3, #0]
    2442:	2b01      	cmp	r3, #1
    2444:	d901      	bls.n	244a <prvIdleTask+0x16>
    2446:	f000 ff41 	bl	32cc <vPortYield>
    244a:	f000 fec3 	bl	31d4 <vApplicationIdleHook>
    244e:	e7f2      	b.n	2436 <prvIdleTask+0x2>
    2450:	f7ff fecc 	bl	21ec <vTaskSuspendAll>
    2454:	4d10      	ldr	r5, [pc, #64]	; (2498 <prvIdleTask+0x64>)
    2456:	682e      	ldr	r6, [r5, #0]
    2458:	f7ff ff5e 	bl	2318 <xTaskResumeAll>
    245c:	2e00      	cmp	r6, #0
    245e:	d0ea      	beq.n	2436 <prvIdleTask+0x2>
    2460:	f000 ff40 	bl	32e4 <vPortEnterCritical>
    2464:	68eb      	ldr	r3, [r5, #12]
    2466:	68dd      	ldr	r5, [r3, #12]
    2468:	1d28      	adds	r0, r5, #4
    246a:	f000 fee8 	bl	323e <uxListRemove>
    246e:	4a0b      	ldr	r2, [pc, #44]	; (249c <prvIdleTask+0x68>)
    2470:	6813      	ldr	r3, [r2, #0]
    2472:	3b01      	subs	r3, #1
    2474:	6013      	str	r3, [r2, #0]
    2476:	6823      	ldr	r3, [r4, #0]
    2478:	3b01      	subs	r3, #1
    247a:	6023      	str	r3, [r4, #0]
    247c:	f000 ff3e 	bl	32fc <vPortExitCritical>
    2480:	6b28      	ldr	r0, [r5, #48]	; 0x30
    2482:	f000 fe79 	bl	3178 <vPortFree>
    2486:	0028      	movs	r0, r5
    2488:	f000 fe76 	bl	3178 <vPortFree>
    248c:	e7d3      	b.n	2436 <prvIdleTask+0x2>
    248e:	46c0      	nop			; (mov r8, r8)
    2490:	200007c4 	.word	0x200007c4
    2494:	20000700 	.word	0x20000700
    2498:	2000082c 	.word	0x2000082c
    249c:	200007b4 	.word	0x200007b4

000024a0 <vTaskSwitchContext>:
    24a0:	4b17      	ldr	r3, [pc, #92]	; (2500 <vTaskSwitchContext+0x60>)
    24a2:	b570      	push	{r4, r5, r6, lr}
    24a4:	681a      	ldr	r2, [r3, #0]
    24a6:	4b17      	ldr	r3, [pc, #92]	; (2504 <vTaskSwitchContext+0x64>)
    24a8:	2a00      	cmp	r2, #0
    24aa:	d002      	beq.n	24b2 <vTaskSwitchContext+0x12>
    24ac:	2201      	movs	r2, #1
    24ae:	601a      	str	r2, [r3, #0]
    24b0:	bd70      	pop	{r4, r5, r6, pc}
    24b2:	2414      	movs	r4, #20
    24b4:	601a      	str	r2, [r3, #0]
    24b6:	4d14      	ldr	r5, [pc, #80]	; (2508 <vTaskSwitchContext+0x68>)
    24b8:	4b14      	ldr	r3, [pc, #80]	; (250c <vTaskSwitchContext+0x6c>)
    24ba:	682a      	ldr	r2, [r5, #0]
    24bc:	4362      	muls	r2, r4
    24be:	58d2      	ldr	r2, [r2, r3]
    24c0:	2a00      	cmp	r2, #0
    24c2:	d012      	beq.n	24ea <vTaskSwitchContext+0x4a>
    24c4:	682d      	ldr	r5, [r5, #0]
    24c6:	436c      	muls	r4, r5
    24c8:	1919      	adds	r1, r3, r4
    24ca:	684a      	ldr	r2, [r1, #4]
    24cc:	3408      	adds	r4, #8
    24ce:	6850      	ldr	r0, [r2, #4]
    24d0:	191c      	adds	r4, r3, r4
    24d2:	6048      	str	r0, [r1, #4]
    24d4:	42a0      	cmp	r0, r4
    24d6:	d101      	bne.n	24dc <vTaskSwitchContext+0x3c>
    24d8:	6842      	ldr	r2, [r0, #4]
    24da:	604a      	str	r2, [r1, #4]
    24dc:	2214      	movs	r2, #20
    24de:	436a      	muls	r2, r5
    24e0:	189b      	adds	r3, r3, r2
    24e2:	685b      	ldr	r3, [r3, #4]
    24e4:	68da      	ldr	r2, [r3, #12]
    24e6:	4b0a      	ldr	r3, [pc, #40]	; (2510 <vTaskSwitchContext+0x70>)
    24e8:	e7e1      	b.n	24ae <vTaskSwitchContext+0xe>
    24ea:	682b      	ldr	r3, [r5, #0]
    24ec:	2b00      	cmp	r3, #0
    24ee:	d102      	bne.n	24f6 <vTaskSwitchContext+0x56>
    24f0:	b672      	cpsid	i
    24f2:	f7ff fce3 	bl	1ebc <rtosFatalError>
    24f6:	682b      	ldr	r3, [r5, #0]
    24f8:	3b01      	subs	r3, #1
    24fa:	602b      	str	r3, [r5, #0]
    24fc:	e7db      	b.n	24b6 <vTaskSwitchContext+0x16>
    24fe:	46c0      	nop			; (mov r8, r8)
    2500:	200007bc 	.word	0x200007bc
    2504:	20000844 	.word	0x20000844
    2508:	200007c8 	.word	0x200007c8
    250c:	20000700 	.word	0x20000700
    2510:	200006f4 	.word	0x200006f4

00002514 <vTaskPlaceOnEventList>:
    2514:	b570      	push	{r4, r5, r6, lr}
    2516:	0006      	movs	r6, r0
    2518:	000c      	movs	r4, r1
    251a:	2800      	cmp	r0, #0
    251c:	d102      	bne.n	2524 <vTaskPlaceOnEventList+0x10>
    251e:	b672      	cpsid	i
    2520:	f7ff fccc 	bl	1ebc <rtosFatalError>
    2524:	4d0b      	ldr	r5, [pc, #44]	; (2554 <vTaskPlaceOnEventList+0x40>)
    2526:	0030      	movs	r0, r6
    2528:	6829      	ldr	r1, [r5, #0]
    252a:	3118      	adds	r1, #24
    252c:	f000 fe70 	bl	3210 <vListInsert>
    2530:	6828      	ldr	r0, [r5, #0]
    2532:	3004      	adds	r0, #4
    2534:	f000 fe83 	bl	323e <uxListRemove>
    2538:	1c63      	adds	r3, r4, #1
    253a:	d105      	bne.n	2548 <vTaskPlaceOnEventList+0x34>
    253c:	6829      	ldr	r1, [r5, #0]
    253e:	4806      	ldr	r0, [pc, #24]	; (2558 <vTaskPlaceOnEventList+0x44>)
    2540:	3104      	adds	r1, #4
    2542:	f000 fe59 	bl	31f8 <vListInsertEnd>
    2546:	bd70      	pop	{r4, r5, r6, pc}
    2548:	4b04      	ldr	r3, [pc, #16]	; (255c <vTaskPlaceOnEventList+0x48>)
    254a:	6818      	ldr	r0, [r3, #0]
    254c:	1820      	adds	r0, r4, r0
    254e:	f7ff fcd3 	bl	1ef8 <prvAddCurrentTaskToDelayedList>
    2552:	e7f8      	b.n	2546 <vTaskPlaceOnEventList+0x32>
    2554:	200006f4 	.word	0x200006f4
    2558:	20000818 	.word	0x20000818
    255c:	20000840 	.word	0x20000840

00002560 <vTaskPlaceOnEventListRestricted>:
    2560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2562:	0007      	movs	r7, r0
    2564:	000d      	movs	r5, r1
    2566:	0016      	movs	r6, r2
    2568:	2800      	cmp	r0, #0
    256a:	d102      	bne.n	2572 <vTaskPlaceOnEventListRestricted+0x12>
    256c:	b672      	cpsid	i
    256e:	f7ff fca5 	bl	1ebc <rtosFatalError>
    2572:	4c0c      	ldr	r4, [pc, #48]	; (25a4 <vTaskPlaceOnEventListRestricted+0x44>)
    2574:	0038      	movs	r0, r7
    2576:	6821      	ldr	r1, [r4, #0]
    2578:	3118      	adds	r1, #24
    257a:	f000 fe3d 	bl	31f8 <vListInsertEnd>
    257e:	6820      	ldr	r0, [r4, #0]
    2580:	3004      	adds	r0, #4
    2582:	f000 fe5c 	bl	323e <uxListRemove>
    2586:	2e01      	cmp	r6, #1
    2588:	d105      	bne.n	2596 <vTaskPlaceOnEventListRestricted+0x36>
    258a:	6821      	ldr	r1, [r4, #0]
    258c:	4806      	ldr	r0, [pc, #24]	; (25a8 <vTaskPlaceOnEventListRestricted+0x48>)
    258e:	3104      	adds	r1, #4
    2590:	f000 fe32 	bl	31f8 <vListInsertEnd>
    2594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2596:	4b05      	ldr	r3, [pc, #20]	; (25ac <vTaskPlaceOnEventListRestricted+0x4c>)
    2598:	6818      	ldr	r0, [r3, #0]
    259a:	1940      	adds	r0, r0, r5
    259c:	f7ff fcac 	bl	1ef8 <prvAddCurrentTaskToDelayedList>
    25a0:	e7f8      	b.n	2594 <vTaskPlaceOnEventListRestricted+0x34>
    25a2:	46c0      	nop			; (mov r8, r8)
    25a4:	200006f4 	.word	0x200006f4
    25a8:	20000818 	.word	0x20000818
    25ac:	20000840 	.word	0x20000840

000025b0 <xTaskRemoveFromEventList>:
    25b0:	68c3      	ldr	r3, [r0, #12]
    25b2:	b570      	push	{r4, r5, r6, lr}
    25b4:	68dc      	ldr	r4, [r3, #12]
    25b6:	2c00      	cmp	r4, #0
    25b8:	d102      	bne.n	25c0 <xTaskRemoveFromEventList+0x10>
    25ba:	b672      	cpsid	i
    25bc:	f7ff fc7e 	bl	1ebc <rtosFatalError>
    25c0:	0025      	movs	r5, r4
    25c2:	3518      	adds	r5, #24
    25c4:	0028      	movs	r0, r5
    25c6:	f000 fe3a 	bl	323e <uxListRemove>
    25ca:	4b11      	ldr	r3, [pc, #68]	; (2610 <xTaskRemoveFromEventList+0x60>)
    25cc:	681b      	ldr	r3, [r3, #0]
    25ce:	2b00      	cmp	r3, #0
    25d0:	d11b      	bne.n	260a <xTaskRemoveFromEventList+0x5a>
    25d2:	1d25      	adds	r5, r4, #4
    25d4:	0028      	movs	r0, r5
    25d6:	f000 fe32 	bl	323e <uxListRemove>
    25da:	4a0e      	ldr	r2, [pc, #56]	; (2614 <xTaskRemoveFromEventList+0x64>)
    25dc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    25de:	6811      	ldr	r1, [r2, #0]
    25e0:	428b      	cmp	r3, r1
    25e2:	d900      	bls.n	25e6 <xTaskRemoveFromEventList+0x36>
    25e4:	6013      	str	r3, [r2, #0]
    25e6:	2014      	movs	r0, #20
    25e8:	0029      	movs	r1, r5
    25ea:	4343      	muls	r3, r0
    25ec:	480a      	ldr	r0, [pc, #40]	; (2618 <xTaskRemoveFromEventList+0x68>)
    25ee:	18c0      	adds	r0, r0, r3
    25f0:	f000 fe02 	bl	31f8 <vListInsertEnd>
    25f4:	4b09      	ldr	r3, [pc, #36]	; (261c <xTaskRemoveFromEventList+0x6c>)
    25f6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    25f8:	681b      	ldr	r3, [r3, #0]
    25fa:	2000      	movs	r0, #0
    25fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    25fe:	429a      	cmp	r2, r3
    2600:	d902      	bls.n	2608 <xTaskRemoveFromEventList+0x58>
    2602:	4b07      	ldr	r3, [pc, #28]	; (2620 <xTaskRemoveFromEventList+0x70>)
    2604:	3001      	adds	r0, #1
    2606:	6018      	str	r0, [r3, #0]
    2608:	bd70      	pop	{r4, r5, r6, pc}
    260a:	0029      	movs	r1, r5
    260c:	4805      	ldr	r0, [pc, #20]	; (2624 <xTaskRemoveFromEventList+0x74>)
    260e:	e7ef      	b.n	25f0 <xTaskRemoveFromEventList+0x40>
    2610:	200007bc 	.word	0x200007bc
    2614:	200007c8 	.word	0x200007c8
    2618:	20000700 	.word	0x20000700
    261c:	200006f4 	.word	0x200006f4
    2620:	20000844 	.word	0x20000844
    2624:	20000800 	.word	0x20000800

00002628 <vTaskSetTimeOutState>:
    2628:	b510      	push	{r4, lr}
    262a:	1e04      	subs	r4, r0, #0
    262c:	d102      	bne.n	2634 <vTaskSetTimeOutState+0xc>
    262e:	b672      	cpsid	i
    2630:	f7ff fc44 	bl	1ebc <rtosFatalError>
    2634:	4b03      	ldr	r3, [pc, #12]	; (2644 <vTaskSetTimeOutState+0x1c>)
    2636:	681b      	ldr	r3, [r3, #0]
    2638:	6023      	str	r3, [r4, #0]
    263a:	4b03      	ldr	r3, [pc, #12]	; (2648 <vTaskSetTimeOutState+0x20>)
    263c:	681b      	ldr	r3, [r3, #0]
    263e:	6063      	str	r3, [r4, #4]
    2640:	bd10      	pop	{r4, pc}
    2642:	46c0      	nop			; (mov r8, r8)
    2644:	200007fc 	.word	0x200007fc
    2648:	20000840 	.word	0x20000840

0000264c <xTaskCheckForTimeOut>:
    264c:	b570      	push	{r4, r5, r6, lr}
    264e:	0004      	movs	r4, r0
    2650:	000d      	movs	r5, r1
    2652:	2800      	cmp	r0, #0
    2654:	d102      	bne.n	265c <xTaskCheckForTimeOut+0x10>
    2656:	b672      	cpsid	i
    2658:	f7ff fc30 	bl	1ebc <rtosFatalError>
    265c:	2d00      	cmp	r5, #0
    265e:	d102      	bne.n	2666 <xTaskCheckForTimeOut+0x1a>
    2660:	b672      	cpsid	i
    2662:	f7ff fc2b 	bl	1ebc <rtosFatalError>
    2666:	f000 fe3d 	bl	32e4 <vPortEnterCritical>
    266a:	4b0f      	ldr	r3, [pc, #60]	; (26a8 <xTaskCheckForTimeOut+0x5c>)
    266c:	2600      	movs	r6, #0
    266e:	6819      	ldr	r1, [r3, #0]
    2670:	682b      	ldr	r3, [r5, #0]
    2672:	1c5a      	adds	r2, r3, #1
    2674:	d013      	beq.n	269e <xTaskCheckForTimeOut+0x52>
    2676:	4a0d      	ldr	r2, [pc, #52]	; (26ac <xTaskCheckForTimeOut+0x60>)
    2678:	6826      	ldr	r6, [r4, #0]
    267a:	6810      	ldr	r0, [r2, #0]
    267c:	6862      	ldr	r2, [r4, #4]
    267e:	4286      	cmp	r6, r0
    2680:	d002      	beq.n	2688 <xTaskCheckForTimeOut+0x3c>
    2682:	2601      	movs	r6, #1
    2684:	4291      	cmp	r1, r2
    2686:	d20a      	bcs.n	269e <xTaskCheckForTimeOut+0x52>
    2688:	1a88      	subs	r0, r1, r2
    268a:	2601      	movs	r6, #1
    268c:	4283      	cmp	r3, r0
    268e:	d906      	bls.n	269e <xTaskCheckForTimeOut+0x52>
    2690:	1a5b      	subs	r3, r3, r1
    2692:	189b      	adds	r3, r3, r2
    2694:	602b      	str	r3, [r5, #0]
    2696:	0020      	movs	r0, r4
    2698:	f7ff ffc6 	bl	2628 <vTaskSetTimeOutState>
    269c:	2600      	movs	r6, #0
    269e:	f000 fe2d 	bl	32fc <vPortExitCritical>
    26a2:	0030      	movs	r0, r6
    26a4:	bd70      	pop	{r4, r5, r6, pc}
    26a6:	46c0      	nop			; (mov r8, r8)
    26a8:	20000840 	.word	0x20000840
    26ac:	200007fc 	.word	0x200007fc

000026b0 <vTaskMissedYield>:
    26b0:	2201      	movs	r2, #1
    26b2:	4b01      	ldr	r3, [pc, #4]	; (26b8 <vTaskMissedYield+0x8>)
    26b4:	601a      	str	r2, [r3, #0]
    26b6:	4770      	bx	lr
    26b8:	20000844 	.word	0x20000844

000026bc <uxTaskGetStackHighWaterMark>:
    26bc:	2800      	cmp	r0, #0
    26be:	d101      	bne.n	26c4 <uxTaskGetStackHighWaterMark+0x8>
    26c0:	4b06      	ldr	r3, [pc, #24]	; (26dc <uxTaskGetStackHighWaterMark+0x20>)
    26c2:	6818      	ldr	r0, [r3, #0]
    26c4:	6b02      	ldr	r2, [r0, #48]	; 0x30
    26c6:	0013      	movs	r3, r2
    26c8:	7819      	ldrb	r1, [r3, #0]
    26ca:	1a98      	subs	r0, r3, r2
    26cc:	29a5      	cmp	r1, #165	; 0xa5
    26ce:	d002      	beq.n	26d6 <uxTaskGetStackHighWaterMark+0x1a>
    26d0:	0880      	lsrs	r0, r0, #2
    26d2:	b280      	uxth	r0, r0
    26d4:	4770      	bx	lr
    26d6:	3301      	adds	r3, #1
    26d8:	e7f6      	b.n	26c8 <uxTaskGetStackHighWaterMark+0xc>
    26da:	46c0      	nop			; (mov r8, r8)
    26dc:	200006f4 	.word	0x200006f4

000026e0 <xTaskGetSchedulerState>:
    26e0:	4b05      	ldr	r3, [pc, #20]	; (26f8 <xTaskGetSchedulerState+0x18>)
    26e2:	2001      	movs	r0, #1
    26e4:	681b      	ldr	r3, [r3, #0]
    26e6:	2b00      	cmp	r3, #0
    26e8:	d004      	beq.n	26f4 <xTaskGetSchedulerState+0x14>
    26ea:	4b04      	ldr	r3, [pc, #16]	; (26fc <xTaskGetSchedulerState+0x1c>)
    26ec:	6818      	ldr	r0, [r3, #0]
    26ee:	4243      	negs	r3, r0
    26f0:	4158      	adcs	r0, r3
    26f2:	0040      	lsls	r0, r0, #1
    26f4:	4770      	bx	lr
    26f6:	46c0      	nop			; (mov r8, r8)
    26f8:	20000814 	.word	0x20000814
    26fc:	200007bc 	.word	0x200007bc

00002700 <vTaskPriorityInherit>:
    2700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2702:	1e04      	subs	r4, r0, #0
    2704:	d026      	beq.n	2754 <vTaskPriorityInherit+0x54>
    2706:	4f16      	ldr	r7, [pc, #88]	; (2760 <vTaskPriorityInherit+0x60>)
    2708:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    270a:	683b      	ldr	r3, [r7, #0]
    270c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    270e:	4299      	cmp	r1, r3
    2710:	d220      	bcs.n	2754 <vTaskPriorityInherit+0x54>
    2712:	6983      	ldr	r3, [r0, #24]
    2714:	2b00      	cmp	r3, #0
    2716:	db04      	blt.n	2722 <vTaskPriorityInherit+0x22>
    2718:	2209      	movs	r2, #9
    271a:	683b      	ldr	r3, [r7, #0]
    271c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    271e:	1ad2      	subs	r2, r2, r3
    2720:	6182      	str	r2, [r0, #24]
    2722:	2314      	movs	r3, #20
    2724:	434b      	muls	r3, r1
    2726:	4e0f      	ldr	r6, [pc, #60]	; (2764 <vTaskPriorityInherit+0x64>)
    2728:	6962      	ldr	r2, [r4, #20]
    272a:	18f3      	adds	r3, r6, r3
    272c:	429a      	cmp	r2, r3
    272e:	d112      	bne.n	2756 <vTaskPriorityInherit+0x56>
    2730:	1d25      	adds	r5, r4, #4
    2732:	0028      	movs	r0, r5
    2734:	f000 fd83 	bl	323e <uxListRemove>
    2738:	683b      	ldr	r3, [r7, #0]
    273a:	4a0b      	ldr	r2, [pc, #44]	; (2768 <vTaskPriorityInherit+0x68>)
    273c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    273e:	6811      	ldr	r1, [r2, #0]
    2740:	62e3      	str	r3, [r4, #44]	; 0x2c
    2742:	428b      	cmp	r3, r1
    2744:	d900      	bls.n	2748 <vTaskPriorityInherit+0x48>
    2746:	6013      	str	r3, [r2, #0]
    2748:	2014      	movs	r0, #20
    274a:	4358      	muls	r0, r3
    274c:	0029      	movs	r1, r5
    274e:	1830      	adds	r0, r6, r0
    2750:	f000 fd52 	bl	31f8 <vListInsertEnd>
    2754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2756:	683b      	ldr	r3, [r7, #0]
    2758:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    275a:	62e3      	str	r3, [r4, #44]	; 0x2c
    275c:	e7fa      	b.n	2754 <vTaskPriorityInherit+0x54>
    275e:	46c0      	nop			; (mov r8, r8)
    2760:	200006f4 	.word	0x200006f4
    2764:	20000700 	.word	0x20000700
    2768:	200007c8 	.word	0x200007c8

0000276c <xTaskPriorityDisinherit>:
    276c:	b570      	push	{r4, r5, r6, lr}
    276e:	1e04      	subs	r4, r0, #0
    2770:	d101      	bne.n	2776 <xTaskPriorityDisinherit+0xa>
    2772:	2000      	movs	r0, #0
    2774:	bd70      	pop	{r4, r5, r6, pc}
    2776:	4b16      	ldr	r3, [pc, #88]	; (27d0 <xTaskPriorityDisinherit+0x64>)
    2778:	681b      	ldr	r3, [r3, #0]
    277a:	4298      	cmp	r0, r3
    277c:	d002      	beq.n	2784 <xTaskPriorityDisinherit+0x18>
    277e:	b672      	cpsid	i
    2780:	f7ff fb9c 	bl	1ebc <rtosFatalError>
    2784:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2786:	2b00      	cmp	r3, #0
    2788:	d102      	bne.n	2790 <xTaskPriorityDisinherit+0x24>
    278a:	b672      	cpsid	i
    278c:	f7ff fb96 	bl	1ebc <rtosFatalError>
    2790:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    2792:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2794:	6c61      	ldr	r1, [r4, #68]	; 0x44
    2796:	3b01      	subs	r3, #1
    2798:	64a3      	str	r3, [r4, #72]	; 0x48
    279a:	428a      	cmp	r2, r1
    279c:	d0e9      	beq.n	2772 <xTaskPriorityDisinherit+0x6>
    279e:	2b00      	cmp	r3, #0
    27a0:	d1e7      	bne.n	2772 <xTaskPriorityDisinherit+0x6>
    27a2:	1d25      	adds	r5, r4, #4
    27a4:	0028      	movs	r0, r5
    27a6:	f000 fd4a 	bl	323e <uxListRemove>
    27aa:	2309      	movs	r3, #9
    27ac:	6c60      	ldr	r0, [r4, #68]	; 0x44
    27ae:	1a1b      	subs	r3, r3, r0
    27b0:	61a3      	str	r3, [r4, #24]
    27b2:	4b08      	ldr	r3, [pc, #32]	; (27d4 <xTaskPriorityDisinherit+0x68>)
    27b4:	62e0      	str	r0, [r4, #44]	; 0x2c
    27b6:	681a      	ldr	r2, [r3, #0]
    27b8:	4290      	cmp	r0, r2
    27ba:	d900      	bls.n	27be <xTaskPriorityDisinherit+0x52>
    27bc:	6018      	str	r0, [r3, #0]
    27be:	2314      	movs	r3, #20
    27c0:	4343      	muls	r3, r0
    27c2:	4805      	ldr	r0, [pc, #20]	; (27d8 <xTaskPriorityDisinherit+0x6c>)
    27c4:	0029      	movs	r1, r5
    27c6:	18c0      	adds	r0, r0, r3
    27c8:	f000 fd16 	bl	31f8 <vListInsertEnd>
    27cc:	2001      	movs	r0, #1
    27ce:	e7d1      	b.n	2774 <xTaskPriorityDisinherit+0x8>
    27d0:	200006f4 	.word	0x200006f4
    27d4:	200007c8 	.word	0x200007c8
    27d8:	20000700 	.word	0x20000700

000027dc <pvTaskIncrementMutexHeldCount>:
    27dc:	4b04      	ldr	r3, [pc, #16]	; (27f0 <pvTaskIncrementMutexHeldCount+0x14>)
    27de:	681a      	ldr	r2, [r3, #0]
    27e0:	2a00      	cmp	r2, #0
    27e2:	d003      	beq.n	27ec <pvTaskIncrementMutexHeldCount+0x10>
    27e4:	6819      	ldr	r1, [r3, #0]
    27e6:	6c8a      	ldr	r2, [r1, #72]	; 0x48
    27e8:	3201      	adds	r2, #1
    27ea:	648a      	str	r2, [r1, #72]	; 0x48
    27ec:	6818      	ldr	r0, [r3, #0]
    27ee:	4770      	bx	lr
    27f0:	200006f4 	.word	0x200006f4

000027f4 <prvCheckForValidListAndQueue>:
    27f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    27f6:	f000 fd75 	bl	32e4 <vPortEnterCritical>
    27fa:	4c12      	ldr	r4, [pc, #72]	; (2844 <prvCheckForValidListAndQueue+0x50>)
    27fc:	6825      	ldr	r5, [r4, #0]
    27fe:	2d00      	cmp	r5, #0
    2800:	d11c      	bne.n	283c <prvCheckForValidListAndQueue+0x48>
    2802:	4f11      	ldr	r7, [pc, #68]	; (2848 <prvCheckForValidListAndQueue+0x54>)
    2804:	0038      	movs	r0, r7
    2806:	f000 fce9 	bl	31dc <vListInitialise>
    280a:	4e10      	ldr	r6, [pc, #64]	; (284c <prvCheckForValidListAndQueue+0x58>)
    280c:	0030      	movs	r0, r6
    280e:	f000 fce5 	bl	31dc <vListInitialise>
    2812:	4b0f      	ldr	r3, [pc, #60]	; (2850 <prvCheckForValidListAndQueue+0x5c>)
    2814:	002a      	movs	r2, r5
    2816:	601f      	str	r7, [r3, #0]
    2818:	4b0e      	ldr	r3, [pc, #56]	; (2854 <prvCheckForValidListAndQueue+0x60>)
    281a:	210c      	movs	r1, #12
    281c:	2005      	movs	r0, #5
    281e:	601e      	str	r6, [r3, #0]
    2820:	f000 fed8 	bl	35d4 <xQueueGenericCreate>
    2824:	6020      	str	r0, [r4, #0]
    2826:	2800      	cmp	r0, #0
    2828:	d102      	bne.n	2830 <prvCheckForValidListAndQueue+0x3c>
    282a:	b672      	cpsid	i
    282c:	f7ff fb46 	bl	1ebc <rtosFatalError>
    2830:	6820      	ldr	r0, [r4, #0]
    2832:	2800      	cmp	r0, #0
    2834:	d002      	beq.n	283c <prvCheckForValidListAndQueue+0x48>
    2836:	4908      	ldr	r1, [pc, #32]	; (2858 <prvCheckForValidListAndQueue+0x64>)
    2838:	f001 f886 	bl	3948 <vQueueAddToRegistry>
    283c:	f000 fd5e 	bl	32fc <vPortExitCritical>
    2840:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2842:	46c0      	nop			; (mov r8, r8)
    2844:	2000087c 	.word	0x2000087c
    2848:	20000850 	.word	0x20000850
    284c:	20000864 	.word	0x20000864
    2850:	20000848 	.word	0x20000848
    2854:	2000084c 	.word	0x2000084c
    2858:	00003ea3 	.word	0x00003ea3

0000285c <prvInsertTimerInActiveList>:
    285c:	b510      	push	{r4, lr}
    285e:	6041      	str	r1, [r0, #4]
    2860:	6100      	str	r0, [r0, #16]
    2862:	4291      	cmp	r1, r2
    2864:	d80c      	bhi.n	2880 <prvInsertTimerInActiveList+0x24>
    2866:	1ad2      	subs	r2, r2, r3
    2868:	6983      	ldr	r3, [r0, #24]
    286a:	2401      	movs	r4, #1
    286c:	429a      	cmp	r2, r3
    286e:	d205      	bcs.n	287c <prvInsertTimerInActiveList+0x20>
    2870:	4b07      	ldr	r3, [pc, #28]	; (2890 <prvInsertTimerInActiveList+0x34>)
    2872:	1d01      	adds	r1, r0, #4
    2874:	6818      	ldr	r0, [r3, #0]
    2876:	f000 fccb 	bl	3210 <vListInsert>
    287a:	2400      	movs	r4, #0
    287c:	0020      	movs	r0, r4
    287e:	bd10      	pop	{r4, pc}
    2880:	429a      	cmp	r2, r3
    2882:	d202      	bcs.n	288a <prvInsertTimerInActiveList+0x2e>
    2884:	2401      	movs	r4, #1
    2886:	4299      	cmp	r1, r3
    2888:	d2f8      	bcs.n	287c <prvInsertTimerInActiveList+0x20>
    288a:	1d01      	adds	r1, r0, #4
    288c:	4b01      	ldr	r3, [pc, #4]	; (2894 <prvInsertTimerInActiveList+0x38>)
    288e:	e7f1      	b.n	2874 <prvInsertTimerInActiveList+0x18>
    2890:	2000084c 	.word	0x2000084c
    2894:	20000848 	.word	0x20000848

00002898 <xTimerCreateTimerTask>:
    2898:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    289a:	f7ff ffab 	bl	27f4 <prvCheckForValidListAndQueue>
    289e:	4b0c      	ldr	r3, [pc, #48]	; (28d0 <xTimerCreateTimerTask+0x38>)
    28a0:	681b      	ldr	r3, [r3, #0]
    28a2:	2b00      	cmp	r3, #0
    28a4:	d105      	bne.n	28b2 <xTimerCreateTimerTask+0x1a>
    28a6:	b672      	cpsid	i
    28a8:	f7ff fb08 	bl	1ebc <rtosFatalError>
    28ac:	2000      	movs	r0, #0
    28ae:	b005      	add	sp, #20
    28b0:	bd00      	pop	{pc}
    28b2:	2300      	movs	r3, #0
    28b4:	2202      	movs	r2, #2
    28b6:	9303      	str	r3, [sp, #12]
    28b8:	9200      	str	r2, [sp, #0]
    28ba:	9302      	str	r3, [sp, #8]
    28bc:	9301      	str	r3, [sp, #4]
    28be:	324e      	adds	r2, #78	; 0x4e
    28c0:	4904      	ldr	r1, [pc, #16]	; (28d4 <xTimerCreateTimerTask+0x3c>)
    28c2:	4805      	ldr	r0, [pc, #20]	; (28d8 <xTimerCreateTimerTask+0x40>)
    28c4:	f7ff fb3e 	bl	1f44 <xTaskGenericCreate>
    28c8:	2800      	cmp	r0, #0
    28ca:	d1f0      	bne.n	28ae <xTimerCreateTimerTask+0x16>
    28cc:	e7eb      	b.n	28a6 <xTimerCreateTimerTask+0xe>
    28ce:	46c0      	nop			; (mov r8, r8)
    28d0:	2000087c 	.word	0x2000087c
    28d4:	00003ea8 	.word	0x00003ea8
    28d8:	0000299d 	.word	0x0000299d

000028dc <xTimerGenericCommand>:
    28dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    28de:	b087      	sub	sp, #28
    28e0:	0006      	movs	r6, r0
    28e2:	000d      	movs	r5, r1
    28e4:	9201      	str	r2, [sp, #4]
    28e6:	001f      	movs	r7, r3
    28e8:	2800      	cmp	r0, #0
    28ea:	d102      	bne.n	28f2 <xTimerGenericCommand+0x16>
    28ec:	b672      	cpsid	i
    28ee:	f7ff fae5 	bl	1ebc <rtosFatalError>
    28f2:	4c0f      	ldr	r4, [pc, #60]	; (2930 <xTimerGenericCommand+0x54>)
    28f4:	6823      	ldr	r3, [r4, #0]
    28f6:	469c      	mov	ip, r3
    28f8:	1e18      	subs	r0, r3, #0
    28fa:	d010      	beq.n	291e <xTimerGenericCommand+0x42>
    28fc:	9b01      	ldr	r3, [sp, #4]
    28fe:	9503      	str	r5, [sp, #12]
    2900:	9304      	str	r3, [sp, #16]
    2902:	9605      	str	r6, [sp, #20]
    2904:	2d05      	cmp	r5, #5
    2906:	dc0c      	bgt.n	2922 <xTimerGenericCommand+0x46>
    2908:	f7ff feea 	bl	26e0 <xTaskGetSchedulerState>
    290c:	2300      	movs	r3, #0
    290e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    2910:	2802      	cmp	r0, #2
    2912:	d000      	beq.n	2916 <xTimerGenericCommand+0x3a>
    2914:	001a      	movs	r2, r3
    2916:	a903      	add	r1, sp, #12
    2918:	6820      	ldr	r0, [r4, #0]
    291a:	f000 fe87 	bl	362c <xQueueGenericSend>
    291e:	b007      	add	sp, #28
    2920:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2922:	2300      	movs	r3, #0
    2924:	003a      	movs	r2, r7
    2926:	a903      	add	r1, sp, #12
    2928:	4660      	mov	r0, ip
    292a:	f000 ff1a 	bl	3762 <xQueueGenericSendFromISR>
    292e:	e7f6      	b.n	291e <xTimerGenericCommand+0x42>
    2930:	2000087c 	.word	0x2000087c

00002934 <prvSwitchTimerLists>:
    2934:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2936:	4d17      	ldr	r5, [pc, #92]	; (2994 <prvSwitchTimerLists+0x60>)
    2938:	682b      	ldr	r3, [r5, #0]
    293a:	681a      	ldr	r2, [r3, #0]
    293c:	2a00      	cmp	r2, #0
    293e:	d104      	bne.n	294a <prvSwitchTimerLists+0x16>
    2940:	4a15      	ldr	r2, [pc, #84]	; (2998 <prvSwitchTimerLists+0x64>)
    2942:	6811      	ldr	r1, [r2, #0]
    2944:	6013      	str	r3, [r2, #0]
    2946:	6029      	str	r1, [r5, #0]
    2948:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    294a:	68db      	ldr	r3, [r3, #12]
    294c:	68dc      	ldr	r4, [r3, #12]
    294e:	681e      	ldr	r6, [r3, #0]
    2950:	1d27      	adds	r7, r4, #4
    2952:	0038      	movs	r0, r7
    2954:	f000 fc73 	bl	323e <uxListRemove>
    2958:	6a63      	ldr	r3, [r4, #36]	; 0x24
    295a:	0020      	movs	r0, r4
    295c:	4798      	blx	r3
    295e:	69e3      	ldr	r3, [r4, #28]
    2960:	2b01      	cmp	r3, #1
    2962:	d1e8      	bne.n	2936 <prvSwitchTimerLists+0x2>
    2964:	69a3      	ldr	r3, [r4, #24]
    2966:	18f3      	adds	r3, r6, r3
    2968:	429e      	cmp	r6, r3
    296a:	d206      	bcs.n	297a <prvSwitchTimerLists+0x46>
    296c:	6063      	str	r3, [r4, #4]
    296e:	6124      	str	r4, [r4, #16]
    2970:	0039      	movs	r1, r7
    2972:	6828      	ldr	r0, [r5, #0]
    2974:	f000 fc4c 	bl	3210 <vListInsert>
    2978:	e7dd      	b.n	2936 <prvSwitchTimerLists+0x2>
    297a:	2100      	movs	r1, #0
    297c:	0032      	movs	r2, r6
    297e:	9100      	str	r1, [sp, #0]
    2980:	000b      	movs	r3, r1
    2982:	0020      	movs	r0, r4
    2984:	f7ff ffaa 	bl	28dc <xTimerGenericCommand>
    2988:	2800      	cmp	r0, #0
    298a:	d1d4      	bne.n	2936 <prvSwitchTimerLists+0x2>
    298c:	b672      	cpsid	i
    298e:	f7ff fa95 	bl	1ebc <rtosFatalError>
    2992:	e7d0      	b.n	2936 <prvSwitchTimerLists+0x2>
    2994:	20000848 	.word	0x20000848
    2998:	2000084c 	.word	0x2000084c

0000299c <prvTimerTask>:
    299c:	b5f0      	push	{r4, r5, r6, r7, lr}
    299e:	b089      	sub	sp, #36	; 0x24
    29a0:	2500      	movs	r5, #0
    29a2:	4e5b      	ldr	r6, [pc, #364]	; (2b10 <prvTimerTask+0x174>)
    29a4:	6833      	ldr	r3, [r6, #0]
    29a6:	681a      	ldr	r2, [r3, #0]
    29a8:	9203      	str	r2, [sp, #12]
    29aa:	42aa      	cmp	r2, r5
    29ac:	d001      	beq.n	29b2 <prvTimerTask+0x16>
    29ae:	68db      	ldr	r3, [r3, #12]
    29b0:	681d      	ldr	r5, [r3, #0]
    29b2:	f7ff fc1b 	bl	21ec <vTaskSuspendAll>
    29b6:	f7ff fc21 	bl	21fc <xTaskGetTickCount>
    29ba:	4f56      	ldr	r7, [pc, #344]	; (2b14 <prvTimerTask+0x178>)
    29bc:	9002      	str	r0, [sp, #8]
    29be:	683a      	ldr	r2, [r7, #0]
    29c0:	2400      	movs	r4, #0
    29c2:	4290      	cmp	r0, r2
    29c4:	d202      	bcs.n	29cc <prvTimerTask+0x30>
    29c6:	f7ff ffb5 	bl	2934 <prvSwitchTimerLists>
    29ca:	3401      	adds	r4, #1
    29cc:	9b02      	ldr	r3, [sp, #8]
    29ce:	603b      	str	r3, [r7, #0]
    29d0:	2c00      	cmp	r4, #0
    29d2:	d16b      	bne.n	2aac <prvTimerTask+0x110>
    29d4:	9b03      	ldr	r3, [sp, #12]
    29d6:	2b00      	cmp	r3, #0
    29d8:	d055      	beq.n	2a86 <prvTimerTask+0xea>
    29da:	9b02      	ldr	r3, [sp, #8]
    29dc:	0020      	movs	r0, r4
    29de:	429d      	cmp	r5, r3
    29e0:	d856      	bhi.n	2a90 <prvTimerTask+0xf4>
    29e2:	f7ff fc99 	bl	2318 <xTaskResumeAll>
    29e6:	6833      	ldr	r3, [r6, #0]
    29e8:	68db      	ldr	r3, [r3, #12]
    29ea:	68de      	ldr	r6, [r3, #12]
    29ec:	1d30      	adds	r0, r6, #4
    29ee:	f000 fc26 	bl	323e <uxListRemove>
    29f2:	69f3      	ldr	r3, [r6, #28]
    29f4:	2b01      	cmp	r3, #1
    29f6:	d114      	bne.n	2a22 <prvTimerTask+0x86>
    29f8:	69b3      	ldr	r3, [r6, #24]
    29fa:	9a02      	ldr	r2, [sp, #8]
    29fc:	18e9      	adds	r1, r5, r3
    29fe:	0030      	movs	r0, r6
    2a00:	002b      	movs	r3, r5
    2a02:	f7ff ff2b 	bl	285c <prvInsertTimerInActiveList>
    2a06:	2801      	cmp	r0, #1
    2a08:	d10b      	bne.n	2a22 <prvTimerTask+0x86>
    2a0a:	9400      	str	r4, [sp, #0]
    2a0c:	0023      	movs	r3, r4
    2a0e:	002a      	movs	r2, r5
    2a10:	0021      	movs	r1, r4
    2a12:	0030      	movs	r0, r6
    2a14:	f7ff ff62 	bl	28dc <xTimerGenericCommand>
    2a18:	2800      	cmp	r0, #0
    2a1a:	d102      	bne.n	2a22 <prvTimerTask+0x86>
    2a1c:	b672      	cpsid	i
    2a1e:	f7ff fa4d 	bl	1ebc <rtosFatalError>
    2a22:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2a24:	0030      	movs	r0, r6
    2a26:	4798      	blx	r3
    2a28:	2300      	movs	r3, #0
    2a2a:	483b      	ldr	r0, [pc, #236]	; (2b18 <prvTimerTask+0x17c>)
    2a2c:	001a      	movs	r2, r3
    2a2e:	a905      	add	r1, sp, #20
    2a30:	6800      	ldr	r0, [r0, #0]
    2a32:	f000 fee6 	bl	3802 <xQueueGenericReceive>
    2a36:	2800      	cmp	r0, #0
    2a38:	d0b2      	beq.n	29a0 <prvTimerTask+0x4>
    2a3a:	9b05      	ldr	r3, [sp, #20]
    2a3c:	2b00      	cmp	r3, #0
    2a3e:	dbf3      	blt.n	2a28 <prvTimerTask+0x8c>
    2a40:	9c07      	ldr	r4, [sp, #28]
    2a42:	6963      	ldr	r3, [r4, #20]
    2a44:	2b00      	cmp	r3, #0
    2a46:	d002      	beq.n	2a4e <prvTimerTask+0xb2>
    2a48:	1d20      	adds	r0, r4, #4
    2a4a:	f000 fbf8 	bl	323e <uxListRemove>
    2a4e:	f7ff fbd5 	bl	21fc <xTaskGetTickCount>
    2a52:	683b      	ldr	r3, [r7, #0]
    2a54:	0005      	movs	r5, r0
    2a56:	4298      	cmp	r0, r3
    2a58:	d201      	bcs.n	2a5e <prvTimerTask+0xc2>
    2a5a:	f7ff ff6b 	bl	2934 <prvSwitchTimerLists>
    2a5e:	9b05      	ldr	r3, [sp, #20]
    2a60:	603d      	str	r5, [r7, #0]
    2a62:	2b09      	cmp	r3, #9
    2a64:	d8e0      	bhi.n	2a28 <prvTimerTask+0x8c>
    2a66:	2201      	movs	r2, #1
    2a68:	2684      	movs	r6, #132	; 0x84
    2a6a:	409a      	lsls	r2, r3
    2a6c:	00b6      	lsls	r6, r6, #2
    2a6e:	0013      	movs	r3, r2
    2a70:	4016      	ands	r6, r2
    2a72:	d13d      	bne.n	2af0 <prvTimerTask+0x154>
    2a74:	22c7      	movs	r2, #199	; 0xc7
    2a76:	4213      	tst	r3, r2
    2a78:	d11b      	bne.n	2ab2 <prvTimerTask+0x116>
    2a7a:	069b      	lsls	r3, r3, #26
    2a7c:	d5d4      	bpl.n	2a28 <prvTimerTask+0x8c>
    2a7e:	0020      	movs	r0, r4
    2a80:	f000 fb7a 	bl	3178 <vPortFree>
    2a84:	e7d0      	b.n	2a28 <prvTimerTask+0x8c>
    2a86:	4b25      	ldr	r3, [pc, #148]	; (2b1c <prvTimerTask+0x180>)
    2a88:	681b      	ldr	r3, [r3, #0]
    2a8a:	681a      	ldr	r2, [r3, #0]
    2a8c:	4250      	negs	r0, r2
    2a8e:	4150      	adcs	r0, r2
    2a90:	9b02      	ldr	r3, [sp, #8]
    2a92:	0002      	movs	r2, r0
    2a94:	1ae9      	subs	r1, r5, r3
    2a96:	4b20      	ldr	r3, [pc, #128]	; (2b18 <prvTimerTask+0x17c>)
    2a98:	6818      	ldr	r0, [r3, #0]
    2a9a:	f000 ff67 	bl	396c <vQueueWaitForMessageRestricted>
    2a9e:	f7ff fc3b 	bl	2318 <xTaskResumeAll>
    2aa2:	2800      	cmp	r0, #0
    2aa4:	d1c0      	bne.n	2a28 <prvTimerTask+0x8c>
    2aa6:	f000 fc11 	bl	32cc <vPortYield>
    2aaa:	e7bd      	b.n	2a28 <prvTimerTask+0x8c>
    2aac:	f7ff fc34 	bl	2318 <xTaskResumeAll>
    2ab0:	e7ba      	b.n	2a28 <prvTimerTask+0x8c>
    2ab2:	9b06      	ldr	r3, [sp, #24]
    2ab4:	69a2      	ldr	r2, [r4, #24]
    2ab6:	0020      	movs	r0, r4
    2ab8:	1899      	adds	r1, r3, r2
    2aba:	002a      	movs	r2, r5
    2abc:	9302      	str	r3, [sp, #8]
    2abe:	f7ff fecd 	bl	285c <prvInsertTimerInActiveList>
    2ac2:	2801      	cmp	r0, #1
    2ac4:	d1b0      	bne.n	2a28 <prvTimerTask+0x8c>
    2ac6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2ac8:	0020      	movs	r0, r4
    2aca:	4798      	blx	r3
    2acc:	69e3      	ldr	r3, [r4, #28]
    2ace:	2b01      	cmp	r3, #1
    2ad0:	d1aa      	bne.n	2a28 <prvTimerTask+0x8c>
    2ad2:	69a3      	ldr	r3, [r4, #24]
    2ad4:	9a06      	ldr	r2, [sp, #24]
    2ad6:	9600      	str	r6, [sp, #0]
    2ad8:	18d2      	adds	r2, r2, r3
    2ada:	0031      	movs	r1, r6
    2adc:	0033      	movs	r3, r6
    2ade:	0020      	movs	r0, r4
    2ae0:	f7ff fefc 	bl	28dc <xTimerGenericCommand>
    2ae4:	2800      	cmp	r0, #0
    2ae6:	d19f      	bne.n	2a28 <prvTimerTask+0x8c>
    2ae8:	b672      	cpsid	i
    2aea:	f7ff f9e7 	bl	1ebc <rtosFatalError>
    2aee:	e79b      	b.n	2a28 <prvTimerTask+0x8c>
    2af0:	9b06      	ldr	r3, [sp, #24]
    2af2:	61a3      	str	r3, [r4, #24]
    2af4:	2b00      	cmp	r3, #0
    2af6:	d102      	bne.n	2afe <prvTimerTask+0x162>
    2af8:	b672      	cpsid	i
    2afa:	f7ff f9df 	bl	1ebc <rtosFatalError>
    2afe:	69a3      	ldr	r3, [r4, #24]
    2b00:	002a      	movs	r2, r5
    2b02:	18e9      	adds	r1, r5, r3
    2b04:	0020      	movs	r0, r4
    2b06:	002b      	movs	r3, r5
    2b08:	f7ff fea8 	bl	285c <prvInsertTimerInActiveList>
    2b0c:	e78c      	b.n	2a28 <prvTimerTask+0x8c>
    2b0e:	46c0      	nop			; (mov r8, r8)
    2b10:	20000848 	.word	0x20000848
    2b14:	20000878 	.word	0x20000878
    2b18:	2000087c 	.word	0x2000087c
    2b1c:	2000084c 	.word	0x2000084c

00002b20 <SERCOM0_Handler>:
    2b20:	b510      	push	{r4, lr}
    2b22:	4802      	ldr	r0, [pc, #8]	; (2b2c <SERCOM0_Handler+0xc>)
    2b24:	f7fd ff63 	bl	9ee <_ZN4Uart10IrqHandlerEv>
    2b28:	bd10      	pop	{r4, pc}
    2b2a:	46c0      	nop			; (mov r8, r8)
    2b2c:	20000abc 	.word	0x20000abc

00002b30 <SERCOM5_Handler>:
    2b30:	b510      	push	{r4, lr}
    2b32:	4802      	ldr	r0, [pc, #8]	; (2b3c <SERCOM5_Handler+0xc>)
    2b34:	f7fd ff5b 	bl	9ee <_ZN4Uart10IrqHandlerEv>
    2b38:	bd10      	pop	{r4, pc}
    2b3a:	46c0      	nop			; (mov r8, r8)
    2b3c:	20000880 	.word	0x20000880

00002b40 <_GLOBAL__sub_I_g_APinDescription>:
    2b40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    2b42:	2401      	movs	r4, #1
    2b44:	2603      	movs	r6, #3
    2b46:	4f15      	ldr	r7, [pc, #84]	; (2b9c <_GLOBAL__sub_I_g_APinDescription+0x5c>)
    2b48:	4915      	ldr	r1, [pc, #84]	; (2ba0 <_GLOBAL__sub_I_g_APinDescription+0x60>)
    2b4a:	0038      	movs	r0, r7
    2b4c:	f000 f84a 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b50:	4914      	ldr	r1, [pc, #80]	; (2ba4 <_GLOBAL__sub_I_g_APinDescription+0x64>)
    2b52:	4815      	ldr	r0, [pc, #84]	; (2ba8 <_GLOBAL__sub_I_g_APinDescription+0x68>)
    2b54:	f000 f846 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b58:	4914      	ldr	r1, [pc, #80]	; (2bac <_GLOBAL__sub_I_g_APinDescription+0x6c>)
    2b5a:	4815      	ldr	r0, [pc, #84]	; (2bb0 <_GLOBAL__sub_I_g_APinDescription+0x70>)
    2b5c:	f000 f842 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b60:	4914      	ldr	r1, [pc, #80]	; (2bb4 <_GLOBAL__sub_I_g_APinDescription+0x74>)
    2b62:	4815      	ldr	r0, [pc, #84]	; (2bb8 <_GLOBAL__sub_I_g_APinDescription+0x78>)
    2b64:	f000 f83e 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b68:	4914      	ldr	r1, [pc, #80]	; (2bbc <_GLOBAL__sub_I_g_APinDescription+0x7c>)
    2b6a:	4815      	ldr	r0, [pc, #84]	; (2bc0 <_GLOBAL__sub_I_g_APinDescription+0x80>)
    2b6c:	f000 f83a 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b70:	4d14      	ldr	r5, [pc, #80]	; (2bc4 <_GLOBAL__sub_I_g_APinDescription+0x84>)
    2b72:	4915      	ldr	r1, [pc, #84]	; (2bc8 <_GLOBAL__sub_I_g_APinDescription+0x88>)
    2b74:	0028      	movs	r0, r5
    2b76:	f000 f835 	bl	2be4 <_ZN6SERCOMC1EP6Sercom>
    2b7a:	0039      	movs	r1, r7
    2b7c:	9600      	str	r6, [sp, #0]
    2b7e:	0023      	movs	r3, r4
    2b80:	9401      	str	r4, [sp, #4]
    2b82:	2200      	movs	r2, #0
    2b84:	4811      	ldr	r0, [pc, #68]	; (2bcc <_GLOBAL__sub_I_g_APinDescription+0x8c>)
    2b86:	f7fd fec7 	bl	918 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
    2b8a:	9600      	str	r6, [sp, #0]
    2b8c:	0029      	movs	r1, r5
    2b8e:	9401      	str	r4, [sp, #4]
    2b90:	2323      	movs	r3, #35	; 0x23
    2b92:	2224      	movs	r2, #36	; 0x24
    2b94:	480e      	ldr	r0, [pc, #56]	; (2bd0 <_GLOBAL__sub_I_g_APinDescription+0x90>)
    2b96:	f7fd febf 	bl	918 <_ZN4UartC1EP6SERCOMhh11SercomRXPad15SercomUartTXPad>
    2b9a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    2b9c:	20000cf8 	.word	0x20000cf8
    2ba0:	42000800 	.word	0x42000800
    2ba4:	42000c00 	.word	0x42000c00
    2ba8:	20000cfc 	.word	0x20000cfc
    2bac:	42001000 	.word	0x42001000
    2bb0:	20000d00 	.word	0x20000d00
    2bb4:	42001400 	.word	0x42001400
    2bb8:	20000d04 	.word	0x20000d04
    2bbc:	42001800 	.word	0x42001800
    2bc0:	20000d08 	.word	0x20000d08
    2bc4:	20000d0c 	.word	0x20000d0c
    2bc8:	42001c00 	.word	0x42001c00
    2bcc:	20000abc 	.word	0x20000abc
    2bd0:	20000880 	.word	0x20000880

00002bd4 <_Znwj>:
    2bd4:	b510      	push	{r4, lr}
    2bd6:	f000 ffa3 	bl	3b20 <malloc>
    2bda:	bd10      	pop	{r4, pc}

00002bdc <_ZdlPv>:
    2bdc:	b510      	push	{r4, lr}
    2bde:	f000 ffa9 	bl	3b34 <free>
    2be2:	bd10      	pop	{r4, pc}

00002be4 <_ZN6SERCOMC1EP6Sercom>:
#define WIRE_RISE_TIME_NANOSECONDS 125
#endif

SERCOM::SERCOM(Sercom* s)
{
  sercom = s;
    2be4:	6001      	str	r1, [r0, #0]
}
    2be6:	4770      	bx	lr

00002be8 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit>:
    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
  }
}
void SERCOM::initFrame(SercomUartCharSize charSize, SercomDataOrder dataOrder, SercomParityMode parityMode, SercomNumberStopBit nbStopBits)
{
    2be8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2bea:	ac05      	add	r4, sp, #20
    2bec:	7825      	ldrb	r5, [r4, #0]
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    2bee:	6804      	ldr	r4, [r0, #0]
    2bf0:	1e98      	subs	r0, r3, #2
    2bf2:	1e47      	subs	r7, r0, #1
    2bf4:	41b8      	sbcs	r0, r7
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    2bf6:	6826      	ldr	r6, [r4, #0]
    2bf8:	0792      	lsls	r2, r2, #30
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    2bfa:	0600      	lsls	r0, r0, #24
                dataOrder << SERCOM_USART_CTRLA_DORD_Pos;
    2bfc:	4332      	orrs	r2, r6
    2bfe:	4302      	orrs	r2, r0

  //Setting the CTRLB register
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    2c00:	2007      	movs	r0, #7
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_FORM( (parityMode == SERCOM_NO_PARITY ? 0 : 1) ) |
    2c02:	6022      	str	r2, [r4, #0]
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    2c04:	4001      	ands	r1, r0
                nbStopBits << SERCOM_USART_CTRLB_SBMODE_Pos |
    2c06:	01ad      	lsls	r5, r5, #6
                (parityMode == SERCOM_NO_PARITY ? 0 : parityMode) << SERCOM_USART_CTRLB_PMODE_Pos; //If no parity use default value
    2c08:	6862      	ldr	r2, [r4, #4]
    2c0a:	4329      	orrs	r1, r5
    2c0c:	2000      	movs	r0, #0
    2c0e:	2b02      	cmp	r3, #2
    2c10:	d000      	beq.n	2c14 <_ZN6SERCOM9initFrameE18SercomUartCharSize15SercomDataOrder16SercomParityMode19SercomNumberStopBit+0x2c>
    2c12:	0358      	lsls	r0, r3, #13
    2c14:	4311      	orrs	r1, r2
    2c16:	4301      	orrs	r1, r0
  sercom->USART.CTRLB.reg |=	SERCOM_USART_CTRLB_CHSIZE(charSize) |
    2c18:	6061      	str	r1, [r4, #4]
}
    2c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00002c1c <_ZN6SERCOM8initPadsE15SercomUartTXPad11SercomRXPad>:

void SERCOM::initPads(SercomUartTXPad txPad, SercomRXPad rxPad)
{
    2c1c:	b510      	push	{r4, lr}
  //Setting the CTRLA register
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
                SERCOM_USART_CTRLA_RXPO(rxPad);
    2c1e:	24c0      	movs	r4, #192	; 0xc0
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
    2c20:	6803      	ldr	r3, [r0, #0]
                SERCOM_USART_CTRLA_RXPO(rxPad);
    2c22:	03a4      	lsls	r4, r4, #14
    2c24:	6818      	ldr	r0, [r3, #0]
    2c26:	0512      	lsls	r2, r2, #20
    2c28:	4022      	ands	r2, r4
    2c2a:	4302      	orrs	r2, r0
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
    2c2c:	20c0      	movs	r0, #192	; 0xc0
    2c2e:	0409      	lsls	r1, r1, #16
    2c30:	0280      	lsls	r0, r0, #10
    2c32:	4001      	ands	r1, r0
                SERCOM_USART_CTRLA_RXPO(rxPad);
    2c34:	4311      	orrs	r1, r2
  sercom->USART.CTRLA.reg |=	SERCOM_USART_CTRLA_TXPO(txPad) |
    2c36:	6019      	str	r1, [r3, #0]

  // Enable Transceiver and Receiver
  sercom->USART.CTRLB.reg |= SERCOM_USART_CTRLB_TXEN | SERCOM_USART_CTRLB_RXEN ;
    2c38:	685a      	ldr	r2, [r3, #4]
    2c3a:	4310      	orrs	r0, r2
    2c3c:	6058      	str	r0, [r3, #4]
}
    2c3e:	bd10      	pop	{r4, pc}

00002c40 <_ZN6SERCOM9resetUARTEv>:

void SERCOM::resetUART()
{
  // Start the Software Reset
  sercom->USART.CTRLA.bit.SWRST = 1 ;
    2c40:	2201      	movs	r2, #1
    2c42:	6803      	ldr	r3, [r0, #0]
    2c44:	6819      	ldr	r1, [r3, #0]
    2c46:	430a      	orrs	r2, r1
    2c48:	601a      	str	r2, [r3, #0]

  while ( sercom->USART.CTRLA.bit.SWRST || sercom->USART.SYNCBUSY.bit.SWRST )
    2c4a:	681a      	ldr	r2, [r3, #0]
    2c4c:	07d2      	lsls	r2, r2, #31
    2c4e:	d4fc      	bmi.n	2c4a <_ZN6SERCOM9resetUARTEv+0xa>
    2c50:	69da      	ldr	r2, [r3, #28]
    2c52:	07d2      	lsls	r2, r2, #31
    2c54:	d4f9      	bmi.n	2c4a <_ZN6SERCOM9resetUARTEv+0xa>
  {
    // Wait for both bits Software Reset from CTRLA and SYNCBUSY coming back to 0
  }
}
    2c56:	4770      	bx	lr

00002c58 <_ZN6SERCOM10enableUARTEv>:

void SERCOM::enableUART()
{
  //Setting  the enable bit to 1
  sercom->USART.CTRLA.bit.ENABLE = 0x1u;
    2c58:	2202      	movs	r2, #2
    2c5a:	6803      	ldr	r3, [r0, #0]
    2c5c:	6819      	ldr	r1, [r3, #0]
    2c5e:	430a      	orrs	r2, r1
    2c60:	601a      	str	r2, [r3, #0]

  //Wait for then enable bit from SYNCBUSY is equal to 0;
  while(sercom->USART.SYNCBUSY.bit.ENABLE);
    2c62:	69da      	ldr	r2, [r3, #28]
    2c64:	0792      	lsls	r2, r2, #30
    2c66:	d4fc      	bmi.n	2c62 <_ZN6SERCOM10enableUARTEv+0xa>
}
    2c68:	4770      	bx	lr

00002c6a <_ZN6SERCOM9flushUARTEv>:
}

bool SERCOM::isDataRegisterEmptyUART()
{
  //DRE : Data Register Empty
  return sercom->USART.INTFLAG.bit.DRE;
    2c6a:	6803      	ldr	r3, [r0, #0]
    2c6c:	7e1a      	ldrb	r2, [r3, #24]
  if(isDataRegisterEmptyUART())
    2c6e:	07d2      	lsls	r2, r2, #31
    2c70:	d402      	bmi.n	2c78 <_ZN6SERCOM9flushUARTEv+0xe>
  while(!sercom->USART.INTFLAG.bit.TXC);
    2c72:	7e1a      	ldrb	r2, [r3, #24]
    2c74:	0792      	lsls	r2, r2, #30
    2c76:	d5fc      	bpl.n	2c72 <_ZN6SERCOM9flushUARTEv+0x8>
}
    2c78:	4770      	bx	lr

00002c7a <_ZN6SERCOM15clearStatusUARTEv>:
  sercom->USART.STATUS.reg = SERCOM_USART_STATUS_RESETVALUE;
    2c7a:	2200      	movs	r2, #0
    2c7c:	6803      	ldr	r3, [r0, #0]
    2c7e:	835a      	strh	r2, [r3, #26]
}
    2c80:	4770      	bx	lr

00002c82 <_ZN6SERCOM17availableDataUARTEv>:
  return sercom->USART.INTFLAG.bit.RXC;
    2c82:	6803      	ldr	r3, [r0, #0]
    2c84:	7e18      	ldrb	r0, [r3, #24]
    2c86:	0740      	lsls	r0, r0, #29
    2c88:	0fc0      	lsrs	r0, r0, #31
}
    2c8a:	4770      	bx	lr

00002c8c <_ZN6SERCOM11isUARTErrorEv>:
  return sercom->USART.INTFLAG.bit.ERROR;
    2c8c:	6803      	ldr	r3, [r0, #0]
    2c8e:	7e18      	ldrb	r0, [r3, #24]
    2c90:	09c0      	lsrs	r0, r0, #7
}
    2c92:	4770      	bx	lr

00002c94 <_ZN6SERCOM20acknowledgeUARTErrorEv>:
  sercom->USART.INTFLAG.bit.ERROR = 1;
    2c94:	2380      	movs	r3, #128	; 0x80
    2c96:	6802      	ldr	r2, [r0, #0]
    2c98:	425b      	negs	r3, r3
    2c9a:	7e11      	ldrb	r1, [r2, #24]
    2c9c:	430b      	orrs	r3, r1
    2c9e:	7613      	strb	r3, [r2, #24]
}
    2ca0:	4770      	bx	lr

00002ca2 <_ZN6SERCOM16isFrameErrorUARTEv>:
  return sercom->USART.STATUS.bit.FERR;
    2ca2:	6803      	ldr	r3, [r0, #0]
    2ca4:	8b58      	ldrh	r0, [r3, #26]
    2ca6:	0780      	lsls	r0, r0, #30
    2ca8:	0fc0      	lsrs	r0, r0, #31
}
    2caa:	4770      	bx	lr

00002cac <_ZN6SERCOM19clearFrameErrorUARTEv>:
  sercom->USART.STATUS.bit.FERR = 1;
    2cac:	2302      	movs	r3, #2
    2cae:	6802      	ldr	r2, [r0, #0]
    2cb0:	8b51      	ldrh	r1, [r2, #26]
    2cb2:	430b      	orrs	r3, r1
    2cb4:	8353      	strh	r3, [r2, #26]
}
    2cb6:	4770      	bx	lr

00002cb8 <_ZN6SERCOM23isDataRegisterEmptyUARTEv>:
  return sercom->USART.INTFLAG.bit.DRE;
    2cb8:	6803      	ldr	r3, [r0, #0]
    2cba:	7e18      	ldrb	r0, [r3, #24]
    2cbc:	07c0      	lsls	r0, r0, #31
    2cbe:	0fc0      	lsrs	r0, r0, #31
}
    2cc0:	4770      	bx	lr

00002cc2 <_ZN6SERCOM12readDataUARTEv>:

uint8_t SERCOM::readDataUART()
{
  return sercom->USART.DATA.bit.DATA;
    2cc2:	6803      	ldr	r3, [r0, #0]
    2cc4:	8d18      	ldrh	r0, [r3, #40]	; 0x28
    2cc6:	b2c0      	uxtb	r0, r0
}
    2cc8:	4770      	bx	lr

00002cca <_ZN6SERCOM13writeDataUARTEh>:
  return sercom->USART.INTFLAG.bit.DRE;
    2cca:	6803      	ldr	r3, [r0, #0]
    2ccc:	7e1a      	ldrb	r2, [r3, #24]

int SERCOM::writeDataUART(uint8_t data)
{
  // Wait for data register to be empty
  while(!isDataRegisterEmptyUART());
    2cce:	07d2      	lsls	r2, r2, #31
    2cd0:	d5fc      	bpl.n	2ccc <_ZN6SERCOM13writeDataUARTEh+0x2>

  //Put data into DATA register
  sercom->USART.DATA.reg = (uint16_t)data;
    2cd2:	b289      	uxth	r1, r1
  return 1;
}
    2cd4:	2001      	movs	r0, #1
  sercom->USART.DATA.reg = (uint16_t)data;
    2cd6:	8519      	strh	r1, [r3, #40]	; 0x28
}
    2cd8:	4770      	bx	lr

00002cda <_ZN6SERCOM36enableDataRegisterEmptyInterruptUARTEv>:

void SERCOM::enableDataRegisterEmptyInterruptUART()
{
  sercom->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
    2cda:	2201      	movs	r2, #1
    2cdc:	6803      	ldr	r3, [r0, #0]
    2cde:	759a      	strb	r2, [r3, #22]
}
    2ce0:	4770      	bx	lr

00002ce2 <_ZN6SERCOM37disableDataRegisterEmptyInterruptUARTEv>:

void SERCOM::disableDataRegisterEmptyInterruptUART()
{
  sercom->USART.INTENCLR.reg = SERCOM_USART_INTENCLR_DRE;
    2ce2:	2201      	movs	r2, #1
    2ce4:	6803      	ldr	r3, [r0, #0]
    2ce6:	751a      	strb	r2, [r3, #20]
}
    2ce8:	4770      	bx	lr
	...

00002cec <_ZN6SERCOM13initClockNVICEv>:
void SERCOM::initClockNVIC( void )
{
  uint8_t clockId = 0;
  IRQn_Type IdNvic=PendSV_IRQn ; // Dummy init to intercept potential error later

  if(sercom == SERCOM0)
    2cec:	6803      	ldr	r3, [r0, #0]
    2cee:	4a21      	ldr	r2, [pc, #132]	; (2d74 <_ZN6SERCOM13initClockNVICEv+0x88>)
{
    2cf0:	b530      	push	{r4, r5, lr}
  if(sercom == SERCOM0)
    2cf2:	4293      	cmp	r3, r2
    2cf4:	d011      	beq.n	2d1a <_ZN6SERCOM13initClockNVICEv+0x2e>
  {
    clockId = GCM_SERCOM0_CORE;
    IdNvic = SERCOM0_IRQn;
  }
  else if(sercom == SERCOM1)
    2cf6:	4a20      	ldr	r2, [pc, #128]	; (2d78 <_ZN6SERCOM13initClockNVICEv+0x8c>)
    2cf8:	4293      	cmp	r3, r2
    2cfa:	d02f      	beq.n	2d5c <_ZN6SERCOM13initClockNVICEv+0x70>
  {
    clockId = GCM_SERCOM1_CORE;
    IdNvic = SERCOM1_IRQn;
  }
  else if(sercom == SERCOM2)
    2cfc:	4a1f      	ldr	r2, [pc, #124]	; (2d7c <_ZN6SERCOM13initClockNVICEv+0x90>)
    2cfe:	4293      	cmp	r3, r2
    2d00:	d02f      	beq.n	2d62 <_ZN6SERCOM13initClockNVICEv+0x76>
  {
    clockId = GCM_SERCOM2_CORE;
    IdNvic = SERCOM2_IRQn;
  }
  else if(sercom == SERCOM3)
    2d02:	4a1f      	ldr	r2, [pc, #124]	; (2d80 <_ZN6SERCOM13initClockNVICEv+0x94>)
    2d04:	4293      	cmp	r3, r2
    2d06:	d02f      	beq.n	2d68 <_ZN6SERCOM13initClockNVICEv+0x7c>
  {
    clockId = GCM_SERCOM3_CORE;
    IdNvic = SERCOM3_IRQn;
  }
  #if defined(SERCOM4)
  else if(sercom == SERCOM4)
    2d08:	4a1e      	ldr	r2, [pc, #120]	; (2d84 <_ZN6SERCOM13initClockNVICEv+0x98>)
    2d0a:	4293      	cmp	r3, r2
    2d0c:	d02f      	beq.n	2d6e <_ZN6SERCOM13initClockNVICEv+0x82>
    clockId = GCM_SERCOM4_CORE;
    IdNvic = SERCOM4_IRQn;
  }
  #endif // SERCOM4
  #if defined(SERCOM5)
  else if(sercom == SERCOM5)
    2d0e:	4a1e      	ldr	r2, [pc, #120]	; (2d88 <_ZN6SERCOM13initClockNVICEv+0x9c>)
    2d10:	4293      	cmp	r3, r2
    2d12:	d122      	bne.n	2d5a <_ZN6SERCOM13initClockNVICEv+0x6e>
  {
    clockId = GCM_SERCOM5_CORE;
    IdNvic = SERCOM5_IRQn;
    2d14:	230e      	movs	r3, #14
    clockId = GCM_SERCOM5_CORE;
    2d16:	2219      	movs	r2, #25
    2d18:	e001      	b.n	2d1e <_ZN6SERCOM13initClockNVICEv+0x32>
    IdNvic = SERCOM0_IRQn;
    2d1a:	2309      	movs	r3, #9
    clockId = GCM_SERCOM0_CORE;
    2d1c:	2214      	movs	r2, #20
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2d1e:	2101      	movs	r1, #1
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2d20:	2503      	movs	r5, #3
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2d22:	4099      	lsls	r1, r3
    2d24:	4819      	ldr	r0, [pc, #100]	; (2d8c <_ZN6SERCOM13initClockNVICEv+0xa0>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2d26:	24c0      	movs	r4, #192	; 0xc0
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2d28:	6001      	str	r1, [r0, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2d2a:	0899      	lsrs	r1, r3, #2
    2d2c:	402b      	ands	r3, r5
    2d2e:	40ab      	lsls	r3, r5
    2d30:	35fc      	adds	r5, #252	; 0xfc
    2d32:	409d      	lsls	r5, r3
    2d34:	0089      	lsls	r1, r1, #2
    2d36:	1809      	adds	r1, r1, r0
    2d38:	00a4      	lsls	r4, r4, #2
    2d3a:	5908      	ldr	r0, [r1, r4]
    2d3c:	43a8      	bics	r0, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    2d3e:	25c0      	movs	r5, #192	; 0xc0
    2d40:	409d      	lsls	r5, r3
    2d42:	002b      	movs	r3, r5
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    2d44:	4303      	orrs	r3, r0
    2d46:	510b      	str	r3, [r1, r4]
  NVIC_EnableIRQ(IdNvic);
  NVIC_SetPriority (IdNvic, SERCOM_NVIC_PRIORITY);  /* set Priority */

  //Setting clock
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( clockId ) | // Generic Clock 0 (SERCOMx)
                      GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
    2d48:	2380      	movs	r3, #128	; 0x80
    2d4a:	01db      	lsls	r3, r3, #7
    2d4c:	431a      	orrs	r2, r3
  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID( clockId ) | // Generic Clock 0 (SERCOMx)
    2d4e:	4b10      	ldr	r3, [pc, #64]	; (2d90 <_ZN6SERCOM13initClockNVICEv+0xa4>)
    2d50:	805a      	strh	r2, [r3, #2]
                      GCLK_CLKCTRL_CLKEN ;

  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY )
    2d52:	785a      	ldrb	r2, [r3, #1]
    2d54:	b252      	sxtb	r2, r2
    2d56:	2a00      	cmp	r2, #0
    2d58:	dbfb      	blt.n	2d52 <_ZN6SERCOM13initClockNVICEv+0x66>
  {
    /* Wait for synchronization */
  }
}
    2d5a:	bd30      	pop	{r4, r5, pc}
    IdNvic = SERCOM1_IRQn;
    2d5c:	230a      	movs	r3, #10
    clockId = GCM_SERCOM1_CORE;
    2d5e:	2215      	movs	r2, #21
    2d60:	e7dd      	b.n	2d1e <_ZN6SERCOM13initClockNVICEv+0x32>
    IdNvic = SERCOM2_IRQn;
    2d62:	230b      	movs	r3, #11
    clockId = GCM_SERCOM2_CORE;
    2d64:	2216      	movs	r2, #22
    2d66:	e7da      	b.n	2d1e <_ZN6SERCOM13initClockNVICEv+0x32>
    IdNvic = SERCOM3_IRQn;
    2d68:	230c      	movs	r3, #12
    clockId = GCM_SERCOM3_CORE;
    2d6a:	2217      	movs	r2, #23
    2d6c:	e7d7      	b.n	2d1e <_ZN6SERCOM13initClockNVICEv+0x32>
    IdNvic = SERCOM4_IRQn;
    2d6e:	230d      	movs	r3, #13
    clockId = GCM_SERCOM4_CORE;
    2d70:	2218      	movs	r2, #24
    2d72:	e7d4      	b.n	2d1e <_ZN6SERCOM13initClockNVICEv+0x32>
    2d74:	42000800 	.word	0x42000800
    2d78:	42000c00 	.word	0x42000c00
    2d7c:	42001000 	.word	0x42001000
    2d80:	42001400 	.word	0x42001400
    2d84:	42001800 	.word	0x42001800
    2d88:	42001c00 	.word	0x42001c00
    2d8c:	e000e100 	.word	0xe000e100
    2d90:	40000c00 	.word	0x40000c00

00002d94 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem>:
{
    2d94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2d96:	0004      	movs	r4, r0
    2d98:	0016      	movs	r6, r2
    2d9a:	000f      	movs	r7, r1
    2d9c:	001d      	movs	r5, r3
  initClockNVIC();
    2d9e:	f7ff ffa5 	bl	2cec <_ZN6SERCOM13initClockNVICEv>
  resetUART();
    2da2:	0020      	movs	r0, r4
    2da4:	f7ff ff4c 	bl	2c40 <_ZN6SERCOM9resetUARTEv>
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    2da8:	221c      	movs	r2, #28
    2daa:	00bb      	lsls	r3, r7, #2
    2dac:	4013      	ands	r3, r2
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    2dae:	0772      	lsls	r2, r6, #29
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    2db0:	6824      	ldr	r4, [r4, #0]
                SERCOM_USART_CTRLA_SAMPR(sampleRate);
    2db2:	0c12      	lsrs	r2, r2, #16
  sercom->USART.CTRLA.reg =	SERCOM_USART_CTRLA_MODE(mode) |
    2db4:	4313      	orrs	r3, r2
    2db6:	6023      	str	r3, [r4, #0]
  sercom->USART.INTENSET.reg =	SERCOM_USART_INTENSET_RXC |  //Received complete
    2db8:	2384      	movs	r3, #132	; 0x84
    2dba:	75a3      	strb	r3, [r4, #22]
  if ( mode == UART_INT_CLOCK )
    2dbc:	2f01      	cmp	r7, #1
    2dbe:	d118      	bne.n	2df2 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x5e>
      sampleRateValue = 16;
    2dc0:	2110      	movs	r1, #16
    if (sampleRate == SAMPLE_RATE_x16) {
    2dc2:	2e01      	cmp	r6, #1
    2dc4:	d000      	beq.n	2dc8 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x34>
      sampleRateValue = 8;
    2dc6:	3908      	subs	r1, #8
    uint32_t baudTimes8 = (SystemCoreClock * 8) / (sampleRateValue * baudrate);
    2dc8:	4b0a      	ldr	r3, [pc, #40]	; (2df4 <_ZN6SERCOM8initUARTE14SercomUartMode20SercomUartSampleRatem+0x60>)
    2dca:	4369      	muls	r1, r5
    2dcc:	6818      	ldr	r0, [r3, #0]
    2dce:	00c0      	lsls	r0, r0, #3
    2dd0:	f000 fdf6 	bl	39c0 <__udivsi3>
    sercom->USART.BAUD.FRAC.FP   = (baudTimes8 % 8);
    2dd4:	2207      	movs	r2, #7
    2dd6:	89a3      	ldrh	r3, [r4, #12]
    2dd8:	4002      	ands	r2, r0
    2dda:	04db      	lsls	r3, r3, #19
    2ddc:	0352      	lsls	r2, r2, #13
    2dde:	0cdb      	lsrs	r3, r3, #19
    2de0:	4313      	orrs	r3, r2
    2de2:	81a3      	strh	r3, [r4, #12]
    sercom->USART.BAUD.FRAC.BAUD = (baudTimes8 / 8);
    2de4:	0403      	lsls	r3, r0, #16
    2de6:	89a0      	ldrh	r0, [r4, #12]
    2de8:	0cdb      	lsrs	r3, r3, #19
    2dea:	0b40      	lsrs	r0, r0, #13
    2dec:	0340      	lsls	r0, r0, #13
    2dee:	4318      	orrs	r0, r3
    2df0:	81a0      	strh	r0, [r4, #12]
}
    2df2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2df4:	2000002c 	.word	0x2000002c

00002df8 <_ZN7Serial_17availableForWriteEv>:
int Serial_::availableForWrite(void)
{
	// return the number of bytes left in the current bank,
	// always EP size - 1, because bank is flushed on every write
	return (EPX_SIZE - 1);
}
    2df8:	203f      	movs	r0, #63	; 0x3f
    2dfa:	4770      	bx	lr

00002dfc <_ZN7Serial_5writeEh>:
		setWriteError();
		return 0;
	}
}

size_t Serial_::write(uint8_t c) {
    2dfc:	b513      	push	{r0, r1, r4, lr}
    2dfe:	466b      	mov	r3, sp
	return write(&c, 1);
    2e00:	6802      	ldr	r2, [r0, #0]
size_t Serial_::write(uint8_t c) {
    2e02:	71d9      	strb	r1, [r3, #7]
    2e04:	3307      	adds	r3, #7
	return write(&c, 1);
    2e06:	6854      	ldr	r4, [r2, #4]
    2e08:	0019      	movs	r1, r3
    2e0a:	2201      	movs	r2, #1
    2e0c:	47a0      	blx	r4
}
    2e0e:	bd16      	pop	{r1, r2, r4, pc}

00002e10 <_ZN7Serial_9availableEv>:
{
    2e10:	b510      	push	{r4, lr}
	return usb.available(CDC_ENDPOINT_OUT);
    2e12:	2102      	movs	r1, #2
    2e14:	6900      	ldr	r0, [r0, #16]
    2e16:	f7fe fa85 	bl	1324 <_ZN14USBDeviceClass9availableEm>
}
    2e1a:	bd10      	pop	{r4, pc}

00002e1c <_ZN7Serial_5flushEv>:
{
    2e1c:	b510      	push	{r4, lr}
	usb.flush(CDC_ENDPOINT_IN);
    2e1e:	2103      	movs	r1, #3
    2e20:	6900      	ldr	r0, [r0, #16]
    2e22:	f7fe fa95 	bl	1350 <_ZN14USBDeviceClass5flushEm>
}
    2e26:	bd10      	pop	{r4, pc}

00002e28 <_ZN7Serial_5writeEPKhj>:
{
    2e28:	b510      	push	{r4, lr}
    2e2a:	0013      	movs	r3, r2
    2e2c:	0004      	movs	r4, r0
	uint32_t r = usb.send(CDC_ENDPOINT_IN, buffer, size);
    2e2e:	000a      	movs	r2, r1
    2e30:	6900      	ldr	r0, [r0, #16]
    2e32:	2103      	movs	r1, #3
    2e34:	f7fe fb86 	bl	1544 <_ZN14USBDeviceClass4sendEmPKvm>
	if (r > 0) {
    2e38:	2800      	cmp	r0, #0
    2e3a:	d101      	bne.n	2e40 <_ZN7Serial_5writeEPKhj+0x18>
    void setWriteError(int err = 1) { write_error = err; }
    2e3c:	2301      	movs	r3, #1
    2e3e:	6063      	str	r3, [r4, #4]
}
    2e40:	bd10      	pop	{r4, pc}
	...

00002e44 <_ZN7Serial_4peekEv>:
{
    2e44:	b510      	push	{r4, lr}
	if (_serialPeek != -1)
    2e46:	4c05      	ldr	r4, [pc, #20]	; (2e5c <_ZN7Serial_4peekEv+0x18>)
    2e48:	6823      	ldr	r3, [r4, #0]
    2e4a:	1c5a      	adds	r2, r3, #1
    2e4c:	d104      	bne.n	2e58 <_ZN7Serial_4peekEv+0x14>
	_serialPeek = read();
    2e4e:	6803      	ldr	r3, [r0, #0]
    2e50:	695b      	ldr	r3, [r3, #20]
    2e52:	4798      	blx	r3
    2e54:	0003      	movs	r3, r0
    2e56:	6020      	str	r0, [r4, #0]
}
    2e58:	0018      	movs	r0, r3
    2e5a:	bd10      	pop	{r4, pc}
    2e5c:	20000084 	.word	0x20000084

00002e60 <_ZN7Serial_4readEv>:
	if (_serialPeek != -1) {
    2e60:	4b07      	ldr	r3, [pc, #28]	; (2e80 <_ZN7Serial_4readEv+0x20>)
{
    2e62:	0002      	movs	r2, r0
	if (_serialPeek != -1) {
    2e64:	6818      	ldr	r0, [r3, #0]
{
    2e66:	b510      	push	{r4, lr}
	if (_serialPeek != -1) {
    2e68:	1c41      	adds	r1, r0, #1
    2e6a:	d003      	beq.n	2e74 <_ZN7Serial_4readEv+0x14>
		_serialPeek = -1;
    2e6c:	2201      	movs	r2, #1
    2e6e:	4252      	negs	r2, r2
    2e70:	601a      	str	r2, [r3, #0]
}
    2e72:	bd10      	pop	{r4, pc}
	return usb.recv(CDC_ENDPOINT_OUT);
    2e74:	2102      	movs	r1, #2
    2e76:	6910      	ldr	r0, [r2, #16]
    2e78:	f7fe fb56 	bl	1528 <_ZN14USBDeviceClass4recvEm>
    2e7c:	e7f9      	b.n	2e72 <_ZN7Serial_4readEv+0x12>
    2e7e:	46c0      	nop			; (mov r8, r8)
    2e80:	20000084 	.word	0x20000084

00002e84 <_Z16CDC_GetInterfacePh>:
{
    2e84:	b510      	push	{r4, lr}
	interfaceNum[0] += 2;	// uses 2
    2e86:	7803      	ldrb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
    2e88:	2242      	movs	r2, #66	; 0x42
	interfaceNum[0] += 2;	// uses 2
    2e8a:	3302      	adds	r3, #2
    2e8c:	7003      	strb	r3, [r0, #0]
	return USBDevice.sendControl(&_cdcInterface,sizeof(_cdcInterface));
    2e8e:	4902      	ldr	r1, [pc, #8]	; (2e98 <_Z16CDC_GetInterfacePh+0x14>)
    2e90:	4802      	ldr	r0, [pc, #8]	; (2e9c <_Z16CDC_GetInterfacePh+0x18>)
    2e92:	f7fe fc03 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
}
    2e96:	bd10      	pop	{r4, pc}
    2e98:	20000040 	.word	0x20000040
    2e9c:	20000134 	.word	0x20000134

00002ea0 <_Z9CDC_SetupR8USBSetup>:
{
    2ea0:	b510      	push	{r4, lr}
	uint8_t requestType = setup.bmRequestType;
    2ea2:	7801      	ldrb	r1, [r0, #0]
{
    2ea4:	0003      	movs	r3, r0
	uint8_t r = setup.bRequest;
    2ea6:	7842      	ldrb	r2, [r0, #1]
	return false;
    2ea8:	2000      	movs	r0, #0
	if (requestType == REQUEST_DEVICETOHOST_CLASS_INTERFACE)
    2eaa:	29a1      	cmp	r1, #161	; 0xa1
    2eac:	d108      	bne.n	2ec0 <_Z9CDC_SetupR8USBSetup+0x20>
		if (r == CDC_GET_LINE_CODING)
    2eae:	2a21      	cmp	r2, #33	; 0x21
    2eb0:	d105      	bne.n	2ebe <_Z9CDC_SetupR8USBSetup+0x1e>
			USBDevice.sendControl((void*)&_usbLineInfo, 7);
    2eb2:	3a1a      	subs	r2, #26
    2eb4:	4916      	ldr	r1, [pc, #88]	; (2f10 <_Z9CDC_SetupR8USBSetup+0x70>)
    2eb6:	4817      	ldr	r0, [pc, #92]	; (2f14 <_Z9CDC_SetupR8USBSetup+0x74>)
    2eb8:	f7fe fbf0 	bl	169c <_ZN14USBDeviceClass11sendControlEPKvm>
			return true;
    2ebc:	2001      	movs	r0, #1
}
    2ebe:	bd10      	pop	{r4, pc}
	if (requestType == REQUEST_HOSTTODEVICE_CLASS_INTERFACE)
    2ec0:	2921      	cmp	r1, #33	; 0x21
    2ec2:	d1fc      	bne.n	2ebe <_Z9CDC_SetupR8USBSetup+0x1e>
		if (r == CDC_SET_LINE_CODING)
    2ec4:	2a20      	cmp	r2, #32
    2ec6:	d111      	bne.n	2eec <_Z9CDC_SetupR8USBSetup+0x4c>
			USBDevice.recvControl((void*)&_usbLineInfo, 7);
    2ec8:	3a19      	subs	r2, #25
    2eca:	4911      	ldr	r1, [pc, #68]	; (2f10 <_Z9CDC_SetupR8USBSetup+0x70>)
    2ecc:	4811      	ldr	r0, [pc, #68]	; (2f14 <_Z9CDC_SetupR8USBSetup+0x74>)
    2ece:	f7fe fa83 	bl	13d8 <_ZN14USBDeviceClass11recvControlEPvm>
			if (_usbLineInfo.dwDTERate == 1200 && (_usbLineInfo.lineState & 0x01) == 0)
    2ed2:	2296      	movs	r2, #150	; 0x96
    2ed4:	4b0e      	ldr	r3, [pc, #56]	; (2f10 <_Z9CDC_SetupR8USBSetup+0x70>)
    2ed6:	00d2      	lsls	r2, r2, #3
    2ed8:	6819      	ldr	r1, [r3, #0]
    2eda:	4291      	cmp	r1, r2
    2edc:	d103      	bne.n	2ee6 <_Z9CDC_SetupR8USBSetup+0x46>
    2ede:	2401      	movs	r4, #1
    2ee0:	79d8      	ldrb	r0, [r3, #7]
    2ee2:	4004      	ands	r4, r0
    2ee4:	d00e      	beq.n	2f04 <_Z9CDC_SetupR8USBSetup+0x64>
				cancelReset();
    2ee6:	f7fd fb4d 	bl	584 <cancelReset>
    2eea:	e00e      	b.n	2f0a <_Z9CDC_SetupR8USBSetup+0x6a>
		if (r == CDC_SET_CONTROL_LINE_STATE)
    2eec:	2a22      	cmp	r2, #34	; 0x22
    2eee:	d103      	bne.n	2ef8 <_Z9CDC_SetupR8USBSetup+0x58>
			_usbLineInfo.lineState = setup.wValueL;
    2ef0:	789a      	ldrb	r2, [r3, #2]
    2ef2:	4b07      	ldr	r3, [pc, #28]	; (2f10 <_Z9CDC_SetupR8USBSetup+0x70>)
    2ef4:	71da      	strb	r2, [r3, #7]
    2ef6:	e7ec      	b.n	2ed2 <_Z9CDC_SetupR8USBSetup+0x32>
		if (CDC_SEND_BREAK == r)
    2ef8:	2a23      	cmp	r2, #35	; 0x23
    2efa:	d1e0      	bne.n	2ebe <_Z9CDC_SetupR8USBSetup+0x1e>
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
    2efc:	885a      	ldrh	r2, [r3, #2]
    2efe:	4b06      	ldr	r3, [pc, #24]	; (2f18 <_Z9CDC_SetupR8USBSetup+0x78>)
    2f00:	601a      	str	r2, [r3, #0]
			return false;
    2f02:	e7dc      	b.n	2ebe <_Z9CDC_SetupR8USBSetup+0x1e>
				initiateReset(250);
    2f04:	20fa      	movs	r0, #250	; 0xfa
    2f06:	f7fd fb37 	bl	578 <initiateReset>
			return false;
    2f0a:	2000      	movs	r0, #0
    2f0c:	e7d7      	b.n	2ebe <_Z9CDC_SetupR8USBSetup+0x1e>
    2f0e:	46c0      	nop			; (mov r8, r8)
    2f10:	20000038 	.word	0x20000038
    2f14:	20000134 	.word	0x20000134
    2f18:	20000034 	.word	0x20000034

00002f1c <_GLOBAL__sub_I__Z17_CDC_GetInterfacev>:
    2f1c:	22fa      	movs	r2, #250	; 0xfa
    Print() : write_error(0) {}
    2f1e:	2100      	movs	r1, #0
    2f20:	4b05      	ldr	r3, [pc, #20]	; (2f38 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x1c>)
    2f22:	0092      	lsls	r2, r2, #2
    2f24:	609a      	str	r2, [r3, #8]
//	Serial over CDC (Serial1 is the physical port)

class Serial_ : public Stream
{
public:
	Serial_(USBDeviceClass &_usb) : usb(_usb), stalled(false) { }
    2f26:	4a05      	ldr	r2, [pc, #20]	; (2f3c <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x20>)
    2f28:	6059      	str	r1, [r3, #4]
    2f2a:	3208      	adds	r2, #8
    2f2c:	601a      	str	r2, [r3, #0]
    2f2e:	4a04      	ldr	r2, [pc, #16]	; (2f40 <_GLOBAL__sub_I__Z17_CDC_GetInterfacev+0x24>)
    2f30:	7619      	strb	r1, [r3, #24]
    2f32:	611a      	str	r2, [r3, #16]

bool Serial_::rts() {
	return _usbLineInfo.lineState & 0x2;
}

Serial_ SerialUSB(USBDevice);
    2f34:	4770      	bx	lr
    2f36:	46c0      	nop			; (mov r8, r8)
    2f38:	20000d10 	.word	0x20000d10
    2f3c:	00004330 	.word	0x00004330
    2f40:	20000134 	.word	0x20000134

00002f44 <_ZN13PluggableUSB_12getInterfaceEPh>:
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
    2f44:	b570      	push	{r4, r5, r6, lr}
    2f46:	000e      	movs	r6, r1
	int sent = 0;
    2f48:	2500      	movs	r5, #0
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    2f4a:	6844      	ldr	r4, [r0, #4]
    2f4c:	2c00      	cmp	r4, #0
    2f4e:	d00b      	beq.n	2f68 <_ZN13PluggableUSB_12getInterfaceEPh+0x24>
		int res = node->getInterface(interfaceCount);
    2f50:	6823      	ldr	r3, [r4, #0]
    2f52:	0031      	movs	r1, r6
    2f54:	685b      	ldr	r3, [r3, #4]
    2f56:	0020      	movs	r0, r4
    2f58:	4798      	blx	r3
		if (res < 0)
    2f5a:	2800      	cmp	r0, #0
    2f5c:	db02      	blt.n	2f64 <_ZN13PluggableUSB_12getInterfaceEPh+0x20>
			return -1;
		sent += res;
    2f5e:	182d      	adds	r5, r5, r0
	for (node = rootNode; node; node = node->next) {
    2f60:	68e4      	ldr	r4, [r4, #12]
    2f62:	e7f3      	b.n	2f4c <_ZN13PluggableUSB_12getInterfaceEPh+0x8>
			return -1;
    2f64:	2501      	movs	r5, #1
    2f66:	426d      	negs	r5, r5
	}
	return sent;
}
    2f68:	0028      	movs	r0, r5
    2f6a:	bd70      	pop	{r4, r5, r6, pc}

00002f6c <_ZN13PluggableUSB_13getDescriptorER8USBSetup>:

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
    2f6c:	b570      	push	{r4, r5, r6, lr}
    2f6e:	000d      	movs	r5, r1
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    2f70:	6844      	ldr	r4, [r0, #4]
    2f72:	2c00      	cmp	r4, #0
    2f74:	d008      	beq.n	2f88 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1c>
		int ret = node->getDescriptor(setup);
    2f76:	6823      	ldr	r3, [r4, #0]
    2f78:	0029      	movs	r1, r5
    2f7a:	689b      	ldr	r3, [r3, #8]
    2f7c:	0020      	movs	r0, r4
    2f7e:	4798      	blx	r3
		// ret!=0 -> request has been processed
		if (ret)
    2f80:	2800      	cmp	r0, #0
    2f82:	d102      	bne.n	2f8a <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x1e>
	for (node = rootNode; node; node = node->next) {
    2f84:	68e4      	ldr	r4, [r4, #12]
    2f86:	e7f4      	b.n	2f72 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x6>
			return ret;
	}
	return 0;
    2f88:	0020      	movs	r0, r4
}
    2f8a:	bd70      	pop	{r4, r5, r6, pc}

00002f8c <_ZN13PluggableUSB_12getShortNameEPc>:

void PluggableUSB_::getShortName(char *iSerialNum)
{
    2f8c:	b570      	push	{r4, r5, r6, lr}
    2f8e:	000d      	movs	r5, r1
       PluggableUSBModule* node;
       for (node = rootNode; node; node = node->next) {
    2f90:	6844      	ldr	r4, [r0, #4]
    2f92:	2c00      	cmp	r4, #0
    2f94:	d007      	beq.n	2fa6 <_ZN13PluggableUSB_12getShortNameEPc+0x1a>
               iSerialNum += node->getShortName(iSerialNum);
    2f96:	6823      	ldr	r3, [r4, #0]
    2f98:	0029      	movs	r1, r5
    2f9a:	0020      	movs	r0, r4
    2f9c:	68db      	ldr	r3, [r3, #12]
    2f9e:	4798      	blx	r3
       for (node = rootNode; node; node = node->next) {
    2fa0:	68e4      	ldr	r4, [r4, #12]
               iSerialNum += node->getShortName(iSerialNum);
    2fa2:	182d      	adds	r5, r5, r0
       for (node = rootNode; node; node = node->next) {
    2fa4:	e7f5      	b.n	2f92 <_ZN13PluggableUSB_12getShortNameEPc+0x6>
       }
       *iSerialNum = 0;
    2fa6:	702c      	strb	r4, [r5, #0]
}
    2fa8:	bd70      	pop	{r4, r5, r6, pc}

00002faa <_ZN13PluggableUSB_5setupER8USBSetup>:

bool PluggableUSB_::setup(USBSetup& setup)
{
    2faa:	b570      	push	{r4, r5, r6, lr}
    2fac:	000d      	movs	r5, r1
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
    2fae:	6844      	ldr	r4, [r0, #4]
    2fb0:	2c00      	cmp	r4, #0
    2fb2:	d008      	beq.n	2fc6 <_ZN13PluggableUSB_5setupER8USBSetup+0x1c>
		if (node->setup(setup)) {
    2fb4:	6823      	ldr	r3, [r4, #0]
    2fb6:	0029      	movs	r1, r5
    2fb8:	681b      	ldr	r3, [r3, #0]
    2fba:	0020      	movs	r0, r4
    2fbc:	4798      	blx	r3
    2fbe:	2800      	cmp	r0, #0
    2fc0:	d102      	bne.n	2fc8 <_ZN13PluggableUSB_5setupER8USBSetup+0x1e>
	for (node = rootNode; node; node = node->next) {
    2fc2:	68e4      	ldr	r4, [r4, #12]
    2fc4:	e7f4      	b.n	2fb0 <_ZN13PluggableUSB_5setupER8USBSetup+0x6>
			return true;
		}
	}
	return false;
    2fc6:	0020      	movs	r0, r4
}
    2fc8:	bd70      	pop	{r4, r5, r6, pc}
	...

00002fcc <_Z12PluggableUSBv>:
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
	static PluggableUSB_ obj;
    2fcc:	2101      	movs	r1, #1
    2fce:	4a06      	ldr	r2, [pc, #24]	; (2fe8 <_Z12PluggableUSBv+0x1c>)
{
    2fd0:	b510      	push	{r4, lr}
	static PluggableUSB_ obj;
    2fd2:	6813      	ldr	r3, [r2, #0]
    2fd4:	4805      	ldr	r0, [pc, #20]	; (2fec <_Z12PluggableUSBv+0x20>)
    2fd6:	400b      	ands	r3, r1
    2fd8:	d105      	bne.n	2fe6 <_Z12PluggableUSBv+0x1a>
	return obj;
}

PluggableUSB_::PluggableUSB_() : lastIf(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT),
                                 lastEp(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT),
                                 rootNode(NULL)
    2fda:	2402      	movs	r4, #2
    2fdc:	7004      	strb	r4, [r0, #0]
    2fde:	1924      	adds	r4, r4, r4
    2fe0:	7044      	strb	r4, [r0, #1]
    2fe2:	6043      	str	r3, [r0, #4]
	static PluggableUSB_ obj;
    2fe4:	6011      	str	r1, [r2, #0]
}
    2fe6:	bd10      	pop	{r4, pc}
    2fe8:	20000d2c 	.word	0x20000d2c
    2fec:	20000d30 	.word	0x20000d30

00002ff0 <prvHeapInit>:
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    2ff0:	2307      	movs	r3, #7
	uxAddress = ( size_t ) ucHeap;
    2ff2:	4a12      	ldr	r2, [pc, #72]	; (303c <prvHeapInit+0x4c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    2ff4:	421a      	tst	r2, r3
    2ff6:	d01e      	beq.n	3036 <prvHeapInit+0x46>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    2ff8:	18d1      	adds	r1, r2, r3
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    2ffa:	4399      	bics	r1, r3
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
    2ffc:	23c0      	movs	r3, #192	; 0xc0
    2ffe:	019b      	lsls	r3, r3, #6
    3000:	18d2      	adds	r2, r2, r3
    3002:	1a53      	subs	r3, r2, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    3004:	000a      	movs	r2, r1
	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
    3006:	2100      	movs	r1, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    3008:	480d      	ldr	r0, [pc, #52]	; (3040 <prvHeapInit+0x50>)

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
    300a:	18d3      	adds	r3, r2, r3
	xStart.xBlockSize = ( size_t ) 0;
    300c:	6041      	str	r1, [r0, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    300e:	6002      	str	r2, [r0, #0]
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    3010:	2007      	movs	r0, #7
	uxAddress -= xHeapStructSize;
    3012:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    3014:	4383      	bics	r3, r0
	pxEnd = ( void * ) uxAddress;
	pxEnd->xBlockSize = 0;
	pxEnd->pxNextFreeBlock = NULL;
    3016:	6019      	str	r1, [r3, #0]
	pxEnd->xBlockSize = 0;
    3018:	6059      	str	r1, [r3, #4]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    301a:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    301c:	6013      	str	r3, [r2, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    301e:	6051      	str	r1, [r2, #4]
	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    3020:	2280      	movs	r2, #128	; 0x80
	pxEnd = ( void * ) uxAddress;
    3022:	4808      	ldr	r0, [pc, #32]	; (3044 <prvHeapInit+0x54>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    3024:	0612      	lsls	r2, r2, #24
	pxEnd = ( void * ) uxAddress;
    3026:	6003      	str	r3, [r0, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    3028:	4b07      	ldr	r3, [pc, #28]	; (3048 <prvHeapInit+0x58>)
    302a:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    302c:	4b07      	ldr	r3, [pc, #28]	; (304c <prvHeapInit+0x5c>)
    302e:	6019      	str	r1, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    3030:	4b07      	ldr	r3, [pc, #28]	; (3050 <prvHeapInit+0x60>)
    3032:	601a      	str	r2, [r3, #0]
}
    3034:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    3036:	23c0      	movs	r3, #192	; 0xc0
    3038:	019b      	lsls	r3, r3, #6
    303a:	e7e4      	b.n	3006 <prvHeapInit+0x16>
    303c:	20000d3c 	.word	0x20000d3c
    3040:	20003d48 	.word	0x20003d48
    3044:	20000d38 	.word	0x20000d38
    3048:	20003d44 	.word	0x20003d44
    304c:	20003d40 	.word	0x20003d40
    3050:	20003d3c 	.word	0x20003d3c

00003054 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    3054:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    3056:	4b0f      	ldr	r3, [pc, #60]	; (3094 <prvInsertBlockIntoFreeList+0x40>)
    3058:	681a      	ldr	r2, [r3, #0]
    305a:	4282      	cmp	r2, r0
    305c:	d318      	bcc.n	3090 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    305e:	685c      	ldr	r4, [r3, #4]
    3060:	1919      	adds	r1, r3, r4
    3062:	4288      	cmp	r0, r1
    3064:	d103      	bne.n	306e <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    3066:	6841      	ldr	r1, [r0, #4]
    3068:	0018      	movs	r0, r3
    306a:	1909      	adds	r1, r1, r4
    306c:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    306e:	6841      	ldr	r1, [r0, #4]
    3070:	1844      	adds	r4, r0, r1
    3072:	42a2      	cmp	r2, r4
    3074:	d107      	bne.n	3086 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    3076:	4c08      	ldr	r4, [pc, #32]	; (3098 <prvInsertBlockIntoFreeList+0x44>)
    3078:	6824      	ldr	r4, [r4, #0]
    307a:	42a2      	cmp	r2, r4
    307c:	d003      	beq.n	3086 <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    307e:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    3080:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    3082:	1861      	adds	r1, r4, r1
    3084:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    3086:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    3088:	4298      	cmp	r0, r3
    308a:	d000      	beq.n	308e <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    308c:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    308e:	bd10      	pop	{r4, pc}
    3090:	0013      	movs	r3, r2
    3092:	e7e1      	b.n	3058 <prvInsertBlockIntoFreeList+0x4>
    3094:	20003d48 	.word	0x20003d48
    3098:	20000d38 	.word	0x20000d38

0000309c <pvPortMalloc>:
{
    309c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    309e:	0004      	movs	r4, r0
	vTaskSuspendAll();
    30a0:	f7ff f8a4 	bl	21ec <vTaskSuspendAll>
		if( pxEnd == NULL )
    30a4:	4b2f      	ldr	r3, [pc, #188]	; (3164 <pvPortMalloc+0xc8>)
    30a6:	681b      	ldr	r3, [r3, #0]
    30a8:	9301      	str	r3, [sp, #4]
    30aa:	2b00      	cmp	r3, #0
    30ac:	d101      	bne.n	30b2 <pvPortMalloc+0x16>
			prvHeapInit();
    30ae:	f7ff ff9f 	bl	2ff0 <prvHeapInit>
	void *pvReturn = NULL;
    30b2:	2600      	movs	r6, #0
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    30b4:	4b2c      	ldr	r3, [pc, #176]	; (3168 <pvPortMalloc+0xcc>)
    30b6:	681b      	ldr	r3, [r3, #0]
    30b8:	9301      	str	r3, [sp, #4]
    30ba:	4023      	ands	r3, r4
    30bc:	42b3      	cmp	r3, r6
    30be:	d13e      	bne.n	313e <pvPortMalloc+0xa2>
	void *pvReturn = NULL;
    30c0:	001e      	movs	r6, r3
			if( xWantedSize > 0 )
    30c2:	2c00      	cmp	r4, #0
    30c4:	d03b      	beq.n	313e <pvPortMalloc+0xa2>
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    30c6:	2307      	movs	r3, #7
				xWantedSize += xHeapStructSize;
    30c8:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    30ca:	421c      	tst	r4, r3
    30cc:	d001      	beq.n	30d2 <pvPortMalloc+0x36>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    30ce:	439c      	bics	r4, r3
    30d0:	3408      	adds	r4, #8
	void *pvReturn = NULL;
    30d2:	2600      	movs	r6, #0
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    30d4:	42b4      	cmp	r4, r6
    30d6:	d032      	beq.n	313e <pvPortMalloc+0xa2>
    30d8:	4f24      	ldr	r7, [pc, #144]	; (316c <pvPortMalloc+0xd0>)
    30da:	683b      	ldr	r3, [r7, #0]
    30dc:	429c      	cmp	r4, r3
    30de:	d82e      	bhi.n	313e <pvPortMalloc+0xa2>
				pxBlock = xStart.pxNextFreeBlock;
    30e0:	4b23      	ldr	r3, [pc, #140]	; (3170 <pvPortMalloc+0xd4>)
    30e2:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    30e4:	686a      	ldr	r2, [r5, #4]
    30e6:	4294      	cmp	r4, r2
    30e8:	d836      	bhi.n	3158 <pvPortMalloc+0xbc>
				if( pxBlock != pxEnd )
    30ea:	491e      	ldr	r1, [pc, #120]	; (3164 <pvPortMalloc+0xc8>)
	void *pvReturn = NULL;
    30ec:	2600      	movs	r6, #0
				if( pxBlock != pxEnd )
    30ee:	6809      	ldr	r1, [r1, #0]
    30f0:	428d      	cmp	r5, r1
    30f2:	d024      	beq.n	313e <pvPortMalloc+0xa2>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    30f4:	681e      	ldr	r6, [r3, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    30f6:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    30f8:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    30fa:	6019      	str	r1, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    30fc:	1b12      	subs	r2, r2, r4
    30fe:	2a10      	cmp	r2, #16
    3100:	d90e      	bls.n	3120 <pvPortMalloc+0x84>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    3102:	192b      	adds	r3, r5, r4
    3104:	9301      	str	r3, [sp, #4]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    3106:	075b      	lsls	r3, r3, #29
    3108:	d002      	beq.n	3110 <pvPortMalloc+0x74>
    310a:	b672      	cpsid	i
    310c:	f7fe fed6 	bl	1ebc <rtosFatalError>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    3110:	686b      	ldr	r3, [r5, #4]
    3112:	192a      	adds	r2, r5, r4
    3114:	1b1b      	subs	r3, r3, r4
    3116:	6053      	str	r3, [r2, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    3118:	9801      	ldr	r0, [sp, #4]
						pxBlock->xBlockSize = xWantedSize;
    311a:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    311c:	f7ff ff9a 	bl	3054 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    3120:	4914      	ldr	r1, [pc, #80]	; (3174 <pvPortMalloc+0xd8>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    3122:	683b      	ldr	r3, [r7, #0]
    3124:	686a      	ldr	r2, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    3126:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    3128:	1a9b      	subs	r3, r3, r2
    312a:	603b      	str	r3, [r7, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    312c:	4283      	cmp	r3, r0
    312e:	d200      	bcs.n	3132 <pvPortMalloc+0x96>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    3130:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    3132:	4b0d      	ldr	r3, [pc, #52]	; (3168 <pvPortMalloc+0xcc>)
    3134:	681b      	ldr	r3, [r3, #0]
    3136:	4313      	orrs	r3, r2
    3138:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
    313a:	2300      	movs	r3, #0
    313c:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
    313e:	f7ff f8eb 	bl	2318 <xTaskResumeAll>
		if( pvReturn == NULL )
    3142:	2e00      	cmp	r6, #0
    3144:	d101      	bne.n	314a <pvPortMalloc+0xae>
			vApplicationMallocFailedHook();
    3146:	f7fe febe 	bl	1ec6 <vApplicationMallocFailedHook>
	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    314a:	0773      	lsls	r3, r6, #29
    314c:	d002      	beq.n	3154 <pvPortMalloc+0xb8>
    314e:	b672      	cpsid	i
    3150:	f7fe feb4 	bl	1ebc <rtosFatalError>
}
    3154:	0030      	movs	r0, r6
    3156:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    3158:	6829      	ldr	r1, [r5, #0]
    315a:	2900      	cmp	r1, #0
    315c:	d0c5      	beq.n	30ea <pvPortMalloc+0x4e>
    315e:	002b      	movs	r3, r5
    3160:	000d      	movs	r5, r1
    3162:	e7bf      	b.n	30e4 <pvPortMalloc+0x48>
    3164:	20000d38 	.word	0x20000d38
    3168:	20003d3c 	.word	0x20003d3c
    316c:	20003d40 	.word	0x20003d40
    3170:	20003d48 	.word	0x20003d48
    3174:	20003d44 	.word	0x20003d44

00003178 <vPortFree>:
{
    3178:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
    317a:	2800      	cmp	r0, #0
    317c:	d024      	beq.n	31c8 <vPortFree+0x50>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    317e:	4d13      	ldr	r5, [pc, #76]	; (31cc <vPortFree+0x54>)
    3180:	3808      	subs	r0, #8
    3182:	682b      	ldr	r3, [r5, #0]
    3184:	6842      	ldr	r2, [r0, #4]
    3186:	0004      	movs	r4, r0
    3188:	4213      	tst	r3, r2
    318a:	d102      	bne.n	3192 <vPortFree+0x1a>
    318c:	b672      	cpsid	i
    318e:	f7fe fe95 	bl	1ebc <rtosFatalError>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    3192:	6823      	ldr	r3, [r4, #0]
    3194:	2b00      	cmp	r3, #0
    3196:	d002      	beq.n	319e <vPortFree+0x26>
    3198:	b672      	cpsid	i
    319a:	f7fe fe8f 	bl	1ebc <rtosFatalError>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    319e:	6863      	ldr	r3, [r4, #4]
    31a0:	682a      	ldr	r2, [r5, #0]
    31a2:	421a      	tst	r2, r3
    31a4:	d010      	beq.n	31c8 <vPortFree+0x50>
			if( pxLink->pxNextFreeBlock == NULL )
    31a6:	6821      	ldr	r1, [r4, #0]
    31a8:	2900      	cmp	r1, #0
    31aa:	d10d      	bne.n	31c8 <vPortFree+0x50>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    31ac:	4393      	bics	r3, r2
    31ae:	6063      	str	r3, [r4, #4]
				vTaskSuspendAll();
    31b0:	f7ff f81c 	bl	21ec <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
    31b4:	4a06      	ldr	r2, [pc, #24]	; (31d0 <vPortFree+0x58>)
    31b6:	6863      	ldr	r3, [r4, #4]
    31b8:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    31ba:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
    31bc:	185b      	adds	r3, r3, r1
    31be:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    31c0:	f7ff ff48 	bl	3054 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
    31c4:	f7ff f8a8 	bl	2318 <xTaskResumeAll>
}
    31c8:	bd70      	pop	{r4, r5, r6, pc}
    31ca:	46c0      	nop			; (mov r8, r8)
    31cc:	20003d3c 	.word	0x20003d3c
    31d0:	20003d40 	.word	0x20003d40

000031d4 <vApplicationIdleHook>:

// this is referring to the loop function of your arduino project
extern void loop(void); 

void  __attribute__((weak)) vApplicationIdleHook( void ) 
{
    31d4:	b510      	push	{r4, lr}
  loop(); //will use your projects loop function as the rtos idle loop
    31d6:	f7fd f841 	bl	25c <loop>
}
    31da:	bd10      	pop	{r4, pc}

000031dc <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31dc:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    31de:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31e0:	3308      	adds	r3, #8
    31e2:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31e4:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31e6:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    31e8:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    31ea:	4252      	negs	r2, r2
    31ec:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    31ee:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    31f0:	4770      	bx	lr

000031f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    31f2:	2300      	movs	r3, #0
    31f4:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    31f6:	4770      	bx	lr

000031f8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
    31f8:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    31fa:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
    31fc:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    31fe:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    3200:	689a      	ldr	r2, [r3, #8]
    3202:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
    3204:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    3206:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
    3208:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    320a:	3301      	adds	r3, #1
    320c:	6003      	str	r3, [r0, #0]
}
    320e:	4770      	bx	lr

00003210 <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3210:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3212:	680a      	ldr	r2, [r1, #0]
{
    3214:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3216:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
    3218:	1c54      	adds	r4, r2, #1
    321a:	d10b      	bne.n	3234 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
    321c:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    321e:	685a      	ldr	r2, [r3, #4]
    3220:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3222:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
    3224:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
    3226:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
    3228:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
    322a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
    322c:	3301      	adds	r3, #1
    322e:	6003      	str	r3, [r0, #0]
}
    3230:	bd30      	pop	{r4, r5, pc}
    3232:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3234:	685c      	ldr	r4, [r3, #4]
    3236:	6825      	ldr	r5, [r4, #0]
    3238:	42aa      	cmp	r2, r5
    323a:	d2fa      	bcs.n	3232 <vListInsert+0x22>
    323c:	e7ef      	b.n	321e <vListInsert+0xe>

0000323e <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    323e:	6841      	ldr	r1, [r0, #4]
    3240:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    3242:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3244:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3246:	6882      	ldr	r2, [r0, #8]
    3248:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    324a:	6859      	ldr	r1, [r3, #4]
    324c:	4288      	cmp	r0, r1
    324e:	d100      	bne.n	3252 <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3250:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    3252:	2200      	movs	r2, #0
    3254:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
    3256:	681a      	ldr	r2, [r3, #0]
    3258:	1e50      	subs	r0, r2, #1
    325a:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
    325c:	4770      	bx	lr
	...

00003260 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
    3260:	4a06      	ldr	r2, [pc, #24]	; (327c <pxCurrentTCBConst2>)
    3262:	6813      	ldr	r3, [r2, #0]
    3264:	6818      	ldr	r0, [r3, #0]
    3266:	3020      	adds	r0, #32
    3268:	f380 8809 	msr	PSP, r0
    326c:	2002      	movs	r0, #2
    326e:	f380 8814 	msr	CONTROL, r0
    3272:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
    3274:	46ae      	mov	lr, r5
    3276:	b662      	cpsie	i
    3278:	bd00      	pop	{pc}
    327a:	46c0      	nop			; (mov r8, r8)

0000327c <pxCurrentTCBConst2>:
    327c:	200006f4 	.word	0x200006f4

00003280 <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
    3280:	4b04      	ldr	r3, [pc, #16]	; (3294 <prvTaskExitError+0x14>)
{
    3282:	b510      	push	{r4, lr}
	configASSERT( uxCriticalNesting == ~0UL );
    3284:	681b      	ldr	r3, [r3, #0]
    3286:	3301      	adds	r3, #1
    3288:	d002      	beq.n	3290 <prvTaskExitError+0x10>
    328a:	b672      	cpsid	i
    328c:	f7fe fe16 	bl	1ebc <rtosFatalError>
	portDISABLE_INTERRUPTS();
    3290:	b672      	cpsid	i
    3292:	e7fe      	b.n	3292 <prvTaskExitError+0x12>
    3294:	20003d50 	.word	0x20003d50

00003298 <pxPortInitialiseStack>:
{
    3298:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
    329a:	2480      	movs	r4, #128	; 0x80
    329c:	1f03      	subs	r3, r0, #4
    329e:	0464      	lsls	r4, r4, #17
    32a0:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
    32a2:	3b04      	subs	r3, #4
    32a4:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
    32a6:	4903      	ldr	r1, [pc, #12]	; (32b4 <pxPortInitialiseStack+0x1c>)
    32a8:	3b04      	subs	r3, #4
    32aa:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    32ac:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
    32ae:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
    32b0:	601a      	str	r2, [r3, #0]
}
    32b2:	bd10      	pop	{r4, pc}
    32b4:	00003281 	.word	0x00003281

000032b8 <sysTickHook>:
 * See header file for description.
 */
void (*rtosSysTick_Handler)(void);

int sysTickHook(void) {
	if (rtosSysTick_Handler)
    32b8:	4b03      	ldr	r3, [pc, #12]	; (32c8 <sysTickHook+0x10>)
int sysTickHook(void) {
    32ba:	b510      	push	{r4, lr}
	if (rtosSysTick_Handler)
    32bc:	681b      	ldr	r3, [r3, #0]
    32be:	2b00      	cmp	r3, #0
    32c0:	d000      	beq.n	32c4 <sysTickHook+0xc>
		rtosSysTick_Handler();
    32c2:	4798      	blx	r3
	return 0; // return zero to keep running the arduino default handler!
}
    32c4:	2000      	movs	r0, #0
    32c6:	bd10      	pop	{r4, pc}
    32c8:	20003d60 	.word	0x20003d60

000032cc <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
    32cc:	2280      	movs	r2, #128	; 0x80
    32ce:	4b04      	ldr	r3, [pc, #16]	; (32e0 <vPortYield+0x14>)
    32d0:	0552      	lsls	r2, r2, #21
    32d2:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
    32d4:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
    32d8:	f3bf 8f6f 	isb	sy
}
    32dc:	4770      	bx	lr
    32de:	46c0      	nop			; (mov r8, r8)
    32e0:	e000ed04 	.word	0xe000ed04

000032e4 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
    32e4:	b672      	cpsid	i
    uxCriticalNesting++;
    32e6:	4a04      	ldr	r2, [pc, #16]	; (32f8 <vPortEnterCritical+0x14>)
    32e8:	6813      	ldr	r3, [r2, #0]
    32ea:	3301      	adds	r3, #1
    32ec:	6013      	str	r3, [r2, #0]
	__asm volatile(
    32ee:	f3bf 8f4f 	dsb	sy
    32f2:	f3bf 8f6f 	isb	sy
		"dsb	\n"
		"isb	\n"
	);
}
    32f6:	4770      	bx	lr
    32f8:	20003d50 	.word	0x20003d50

000032fc <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    32fc:	b510      	push	{r4, lr}
	configASSERT( uxCriticalNesting );
    32fe:	4c07      	ldr	r4, [pc, #28]	; (331c <vPortExitCritical+0x20>)
    3300:	6823      	ldr	r3, [r4, #0]
    3302:	2b00      	cmp	r3, #0
    3304:	d102      	bne.n	330c <vPortExitCritical+0x10>
    3306:	b672      	cpsid	i
    3308:	f7fe fdd8 	bl	1ebc <rtosFatalError>
    uxCriticalNesting--;
    330c:	6823      	ldr	r3, [r4, #0]
    330e:	3b01      	subs	r3, #1
    3310:	6023      	str	r3, [r4, #0]
    if( uxCriticalNesting == 0 )
    3312:	2b00      	cmp	r3, #0
    3314:	d100      	bne.n	3318 <vPortExitCritical+0x1c>
    {
        portENABLE_INTERRUPTS();
    3316:	b662      	cpsie	i
    }
}
    3318:	bd10      	pop	{r4, pc}
    331a:	46c0      	nop			; (mov r8, r8)
    331c:	20003d50 	.word	0x20003d50

00003320 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
    3320:	f3ef 8010 	mrs	r0, PRIMASK
    3324:	b672      	cpsid	i
    3326:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
    3328:	2000      	movs	r0, #0

0000332a <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
    332a:	f380 8810 	msr	PRIMASK, r0
    332e:	4770      	bx	lr

00003330 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    3330:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    3332:	f7ff fff5 	bl	3320 <ulSetInterruptMaskFromISR>
    3336:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
    3338:	f7fe ff6c 	bl	2214 <xTaskIncrementTick>
    333c:	2800      	cmp	r0, #0
    333e:	d003      	beq.n	3348 <xPortSysTickHandler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    3340:	2280      	movs	r2, #128	; 0x80
    3342:	4b03      	ldr	r3, [pc, #12]	; (3350 <xPortSysTickHandler+0x20>)
    3344:	0552      	lsls	r2, r2, #21
    3346:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
    3348:	0020      	movs	r0, r4
    334a:	f7ff ffee 	bl	332a <vClearInterruptMaskFromISR>
}
    334e:	bd10      	pop	{r4, pc}
    3350:	e000ed04 	.word	0xe000ed04

00003354 <PendSV_Handler>:
	__asm volatile
    3354:	f3ef 8009 	mrs	r0, PSP
    3358:	4b0e      	ldr	r3, [pc, #56]	; (3394 <pxCurrentTCBConst>)
    335a:	681a      	ldr	r2, [r3, #0]
    335c:	3820      	subs	r0, #32
    335e:	6010      	str	r0, [r2, #0]
    3360:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    3362:	4644      	mov	r4, r8
    3364:	464d      	mov	r5, r9
    3366:	4656      	mov	r6, sl
    3368:	465f      	mov	r7, fp
    336a:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    336c:	b508      	push	{r3, lr}
    336e:	b672      	cpsid	i
    3370:	f7ff f896 	bl	24a0 <vTaskSwitchContext>
    3374:	b662      	cpsie	i
    3376:	bc0c      	pop	{r2, r3}
    3378:	6811      	ldr	r1, [r2, #0]
    337a:	6808      	ldr	r0, [r1, #0]
    337c:	3010      	adds	r0, #16
    337e:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    3380:	46a0      	mov	r8, r4
    3382:	46a9      	mov	r9, r5
    3384:	46b2      	mov	sl, r6
    3386:	46bb      	mov	fp, r7
    3388:	f380 8809 	msr	PSP, r0
    338c:	3820      	subs	r0, #32
    338e:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    3390:	4718      	bx	r3
    3392:	46c0      	nop			; (mov r8, r8)

00003394 <pxCurrentTCBConst>:
    3394:	200006f4 	.word	0x200006f4

00003398 <vPortSetupTimerInterrupt>:
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_VAL)  = 0; /* Load the SysTick Counter Value */
    3398:	2200      	movs	r2, #0
    339a:	4b04      	ldr	r3, [pc, #16]	; (33ac <vPortSetupTimerInterrupt+0x14>)
    339c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    339e:	4a04      	ldr	r2, [pc, #16]	; (33b0 <vPortSetupTimerInterrupt+0x18>)
    33a0:	4b04      	ldr	r3, [pc, #16]	; (33b4 <vPortSetupTimerInterrupt+0x1c>)
    33a2:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
    33a4:	2207      	movs	r2, #7
    33a6:	4b04      	ldr	r3, [pc, #16]	; (33b8 <vPortSetupTimerInterrupt+0x20>)
    33a8:	601a      	str	r2, [r3, #0]
}
    33aa:	4770      	bx	lr
    33ac:	e000e018 	.word	0xe000e018
    33b0:	0000bb7f 	.word	0x0000bb7f
    33b4:	e000e014 	.word	0xe000e014
    33b8:	e000e010 	.word	0xe000e010

000033bc <xPortStartScheduler>:
	rtosSysTick_Handler = &xPortSysTickHandler;
    33bc:	4a0b      	ldr	r2, [pc, #44]	; (33ec <xPortStartScheduler+0x30>)
    33be:	4b0c      	ldr	r3, [pc, #48]	; (33f0 <xPortStartScheduler+0x34>)
{
    33c0:	b510      	push	{r4, lr}
	rtosSysTick_Handler = &xPortSysTickHandler;
    33c2:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    33c4:	22ff      	movs	r2, #255	; 0xff
    33c6:	4b0b      	ldr	r3, [pc, #44]	; (33f4 <xPortStartScheduler+0x38>)
    33c8:	0412      	lsls	r2, r2, #16
    33ca:	6819      	ldr	r1, [r3, #0]
	uxCriticalNesting = 0;
    33cc:	2400      	movs	r4, #0
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
    33ce:	430a      	orrs	r2, r1
    33d0:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
    33d2:	22ff      	movs	r2, #255	; 0xff
    33d4:	6819      	ldr	r1, [r3, #0]
    33d6:	0612      	lsls	r2, r2, #24
    33d8:	430a      	orrs	r2, r1
    33da:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    33dc:	f7ff ffdc 	bl	3398 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
    33e0:	4b05      	ldr	r3, [pc, #20]	; (33f8 <xPortStartScheduler+0x3c>)
    33e2:	601c      	str	r4, [r3, #0]
	vPortStartFirstTask();
    33e4:	f7ff ff3c 	bl	3260 <vPortStartFirstTask>
}
    33e8:	0020      	movs	r0, r4
    33ea:	bd10      	pop	{r4, pc}
    33ec:	00003331 	.word	0x00003331
    33f0:	20003d60 	.word	0x20003d60
    33f4:	e000ed20 	.word	0xe000ed20
    33f8:	20003d50 	.word	0x20003d50

000033fc <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    33fc:	b570      	push	{r4, r5, r6, lr}
    33fe:	0015      	movs	r5, r2
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3400:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
    3402:	0004      	movs	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    3404:	2a00      	cmp	r2, #0
    3406:	d10c      	bne.n	3422 <prvCopyDataToQueue+0x26>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3408:	6805      	ldr	r5, [r0, #0]
    340a:	2d00      	cmp	r5, #0
    340c:	d001      	beq.n	3412 <prvCopyDataToQueue+0x16>
BaseType_t xReturn = pdFALSE;
    340e:	2000      	movs	r0, #0
    3410:	e003      	b.n	341a <prvCopyDataToQueue+0x1e>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    3412:	6840      	ldr	r0, [r0, #4]
    3414:	f7ff f9aa 	bl	276c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    3418:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    341a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    341c:	3301      	adds	r3, #1
    341e:	63a3      	str	r3, [r4, #56]	; 0x38

	return xReturn;
}
    3420:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
    3422:	2d00      	cmp	r5, #0
    3424:	d10c      	bne.n	3440 <prvCopyDataToQueue+0x44>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    3426:	6880      	ldr	r0, [r0, #8]
    3428:	f000 fb8e 	bl	3b48 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    342c:	68a3      	ldr	r3, [r4, #8]
    342e:	6c22      	ldr	r2, [r4, #64]	; 0x40
    3430:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3432:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3434:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3436:	4293      	cmp	r3, r2
    3438:	d3e9      	bcc.n	340e <prvCopyDataToQueue+0x12>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    343a:	6823      	ldr	r3, [r4, #0]
    343c:	60a3      	str	r3, [r4, #8]
    343e:	e7e6      	b.n	340e <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3440:	68c0      	ldr	r0, [r0, #12]
    3442:	f000 fb81 	bl	3b48 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    3446:	6c23      	ldr	r3, [r4, #64]	; 0x40
    3448:	68e2      	ldr	r2, [r4, #12]
    344a:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    344c:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    344e:	18d2      	adds	r2, r2, r3
    3450:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3452:	428a      	cmp	r2, r1
    3454:	d202      	bcs.n	345c <prvCopyDataToQueue+0x60>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3456:	6862      	ldr	r2, [r4, #4]
    3458:	18d3      	adds	r3, r2, r3
    345a:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
    345c:	2d02      	cmp	r5, #2
    345e:	d1d6      	bne.n	340e <prvCopyDataToQueue+0x12>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3460:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3462:	2b00      	cmp	r3, #0
    3464:	d0d3      	beq.n	340e <prvCopyDataToQueue+0x12>
				--( pxQueue->uxMessagesWaiting );
    3466:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3468:	3b01      	subs	r3, #1
    346a:	63a3      	str	r3, [r4, #56]	; 0x38
    346c:	e7cf      	b.n	340e <prvCopyDataToQueue+0x12>

0000346e <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
    346e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    3470:	6d44      	ldr	r4, [r0, #84]	; 0x54
	{
    3472:	9001      	str	r0, [sp, #4]
    3474:	000e      	movs	r6, r1
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
    3476:	2c00      	cmp	r4, #0
    3478:	d102      	bne.n	3480 <prvNotifyQueueSetContainer+0x12>
    347a:	b672      	cpsid	i
    347c:	f7fe fd1e 	bl	1ebc <rtosFatalError>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
    3480:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3482:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    3484:	4293      	cmp	r3, r2
    3486:	d302      	bcc.n	348e <prvNotifyQueueSetContainer+0x20>
    3488:	b672      	cpsid	i
    348a:	f7fe fd17 	bl	1ebc <rtosFatalError>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    348e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3490:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	BaseType_t xReturn = pdFALSE;
    3492:	2500      	movs	r5, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
    3494:	4293      	cmp	r3, r2
    3496:	d212      	bcs.n	34be <prvNotifyQueueSetContainer+0x50>
		{
			traceQUEUE_SEND( pxQueueSetContainer );

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    3498:	0032      	movs	r2, r6
    349a:	a901      	add	r1, sp, #4
    349c:	0020      	movs	r0, r4
    349e:	f7ff ffad 	bl	33fc <prvCopyDataToQueue>

			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
    34a2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
    34a4:	0005      	movs	r5, r0
			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
    34a6:	3301      	adds	r3, #1
    34a8:	d10b      	bne.n	34c2 <prvNotifyQueueSetContainer+0x54>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
    34aa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    34ac:	2b00      	cmp	r3, #0
    34ae:	d006      	beq.n	34be <prvNotifyQueueSetContainer+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
    34b0:	0020      	movs	r0, r4
    34b2:	3024      	adds	r0, #36	; 0x24
    34b4:	f7ff f87c 	bl	25b0 <xTaskRemoveFromEventList>
    34b8:	2800      	cmp	r0, #0
    34ba:	d000      	beq.n	34be <prvNotifyQueueSetContainer+0x50>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
    34bc:	2501      	movs	r5, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    34be:	0028      	movs	r0, r5
    34c0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
				( pxQueueSetContainer->xTxLock )++;
    34c2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    34c4:	3301      	adds	r3, #1
    34c6:	64a3      	str	r3, [r4, #72]	; 0x48
    34c8:	e7f9      	b.n	34be <prvNotifyQueueSetContainer+0x50>

000034ca <prvCopyDataFromQueue>:
{
    34ca:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    34cc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    34ce:	b510      	push	{r4, lr}
    34d0:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    34d2:	2a00      	cmp	r2, #0
    34d4:	d00a      	beq.n	34ec <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    34d6:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    34d8:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    34da:	1889      	adds	r1, r1, r2
    34dc:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    34de:	42a1      	cmp	r1, r4
    34e0:	d301      	bcc.n	34e6 <prvCopyDataFromQueue+0x1c>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    34e2:	6819      	ldr	r1, [r3, #0]
    34e4:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    34e6:	68d9      	ldr	r1, [r3, #12]
    34e8:	f000 fb2e 	bl	3b48 <memcpy>
}
    34ec:	bd10      	pop	{r4, pc}

000034ee <prvUnlockQueue>:
{
    34ee:	b510      	push	{r4, lr}
    34f0:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    34f2:	f7ff fef7 	bl	32e4 <vPortEnterCritical>
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    34f6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    34f8:	2b00      	cmp	r3, #0
    34fa:	dc0f      	bgt.n	351c <prvUnlockQueue+0x2e>
		pxQueue->xTxLock = queueUNLOCKED;
    34fc:	2301      	movs	r3, #1
    34fe:	425b      	negs	r3, r3
    3500:	64a3      	str	r3, [r4, #72]	; 0x48
	taskEXIT_CRITICAL();
    3502:	f7ff fefb 	bl	32fc <vPortExitCritical>
	taskENTER_CRITICAL();
    3506:	f7ff feed 	bl	32e4 <vPortEnterCritical>
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    350a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    350c:	2b00      	cmp	r3, #0
    350e:	dc1e      	bgt.n	354e <prvUnlockQueue+0x60>
		pxQueue->xRxLock = queueUNLOCKED;
    3510:	2301      	movs	r3, #1
    3512:	425b      	negs	r3, r3
    3514:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    3516:	f7ff fef1 	bl	32fc <vPortExitCritical>
}
    351a:	bd10      	pop	{r4, pc}
				if( pxQueue->pxQueueSetContainer != NULL )
    351c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    351e:	2b00      	cmp	r3, #0
    3520:	d00b      	beq.n	353a <prvUnlockQueue+0x4c>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
    3522:	2100      	movs	r1, #0
    3524:	0020      	movs	r0, r4
    3526:	f7ff ffa2 	bl	346e <prvNotifyQueueSetContainer>
    352a:	2801      	cmp	r0, #1
    352c:	d101      	bne.n	3532 <prvUnlockQueue+0x44>
						vTaskMissedYield();
    352e:	f7ff f8bf 	bl	26b0 <vTaskMissedYield>
			--( pxQueue->xTxLock );
    3532:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3534:	3b01      	subs	r3, #1
    3536:	64a3      	str	r3, [r4, #72]	; 0x48
    3538:	e7dd      	b.n	34f6 <prvUnlockQueue+0x8>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    353a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    353c:	2b00      	cmp	r3, #0
    353e:	d0dd      	beq.n	34fc <prvUnlockQueue+0xe>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3540:	0020      	movs	r0, r4
    3542:	3024      	adds	r0, #36	; 0x24
    3544:	f7ff f834 	bl	25b0 <xTaskRemoveFromEventList>
    3548:	2800      	cmp	r0, #0
    354a:	d0f2      	beq.n	3532 <prvUnlockQueue+0x44>
    354c:	e7ef      	b.n	352e <prvUnlockQueue+0x40>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    354e:	6923      	ldr	r3, [r4, #16]
    3550:	2b00      	cmp	r3, #0
    3552:	d0dd      	beq.n	3510 <prvUnlockQueue+0x22>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3554:	0020      	movs	r0, r4
    3556:	3010      	adds	r0, #16
    3558:	f7ff f82a 	bl	25b0 <xTaskRemoveFromEventList>
    355c:	2800      	cmp	r0, #0
    355e:	d001      	beq.n	3564 <prvUnlockQueue+0x76>
					vTaskMissedYield();
    3560:	f7ff f8a6 	bl	26b0 <vTaskMissedYield>
				--( pxQueue->xRxLock );
    3564:	6c63      	ldr	r3, [r4, #68]	; 0x44
    3566:	3b01      	subs	r3, #1
    3568:	6463      	str	r3, [r4, #68]	; 0x44
    356a:	e7ce      	b.n	350a <prvUnlockQueue+0x1c>

0000356c <xQueueGenericReset>:
{
    356c:	b570      	push	{r4, r5, r6, lr}
    356e:	0004      	movs	r4, r0
    3570:	000d      	movs	r5, r1
	configASSERT( pxQueue );
    3572:	2800      	cmp	r0, #0
    3574:	d102      	bne.n	357c <xQueueGenericReset+0x10>
    3576:	b672      	cpsid	i
    3578:	f7fe fca0 	bl	1ebc <rtosFatalError>
	taskENTER_CRITICAL();
    357c:	f7ff feb2 	bl	32e4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3580:	6c21      	ldr	r1, [r4, #64]	; 0x40
    3582:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3584:	6822      	ldr	r2, [r4, #0]
    3586:	434b      	muls	r3, r1
    3588:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    358a:	1a5b      	subs	r3, r3, r1
    358c:	18d3      	adds	r3, r2, r3
    358e:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
    3590:	2301      	movs	r3, #1
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3592:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3594:	2000      	movs	r0, #0
		pxQueue->xRxLock = queueUNLOCKED;
    3596:	425b      	negs	r3, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3598:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    359a:	60a2      	str	r2, [r4, #8]
		pxQueue->xRxLock = queueUNLOCKED;
    359c:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
    359e:	64a3      	str	r3, [r4, #72]	; 0x48
		if( xNewQueue == pdFALSE )
    35a0:	4285      	cmp	r5, r0
    35a2:	d10e      	bne.n	35c2 <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35a4:	6923      	ldr	r3, [r4, #16]
    35a6:	4283      	cmp	r3, r0
    35a8:	d007      	beq.n	35ba <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    35aa:	0020      	movs	r0, r4
    35ac:	3010      	adds	r0, #16
    35ae:	f7fe ffff 	bl	25b0 <xTaskRemoveFromEventList>
    35b2:	2801      	cmp	r0, #1
    35b4:	d101      	bne.n	35ba <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
    35b6:	f7ff fe89 	bl	32cc <vPortYield>
	taskEXIT_CRITICAL();
    35ba:	f7ff fe9f 	bl	32fc <vPortExitCritical>
}
    35be:	2001      	movs	r0, #1
    35c0:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    35c2:	0020      	movs	r0, r4
    35c4:	3010      	adds	r0, #16
    35c6:	f7ff fe09 	bl	31dc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    35ca:	0020      	movs	r0, r4
    35cc:	3024      	adds	r0, #36	; 0x24
    35ce:	f7ff fe05 	bl	31dc <vListInitialise>
    35d2:	e7f2      	b.n	35ba <xQueueGenericReset+0x4e>

000035d4 <xQueueGenericCreate>:
{
    35d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    35d6:	0006      	movs	r6, r0
    35d8:	000d      	movs	r5, r1
    35da:	0017      	movs	r7, r2
	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    35dc:	2800      	cmp	r0, #0
    35de:	d102      	bne.n	35e6 <xQueueGenericCreate+0x12>
    35e0:	b672      	cpsid	i
    35e2:	f7fe fc6b 	bl	1ebc <rtosFatalError>
		xQueueSizeInBytes = ( size_t ) 0;
    35e6:	2000      	movs	r0, #0
	if( uxItemSize == ( UBaseType_t ) 0 )
    35e8:	4285      	cmp	r5, r0
    35ea:	d002      	beq.n	35f2 <xQueueGenericCreate+0x1e>
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    35ec:	0028      	movs	r0, r5
    35ee:	4370      	muls	r0, r6
    35f0:	3001      	adds	r0, #1
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    35f2:	3058      	adds	r0, #88	; 0x58
    35f4:	f7ff fd52 	bl	309c <pvPortMalloc>
    35f8:	1e04      	subs	r4, r0, #0
	if( pxNewQueue != NULL )
    35fa:	d013      	beq.n	3624 <xQueueGenericCreate+0x50>
		if( uxItemSize == ( UBaseType_t ) 0 )
    35fc:	2d00      	cmp	r5, #0
    35fe:	d10d      	bne.n	361c <xQueueGenericCreate+0x48>
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3600:	6020      	str	r0, [r4, #0]
		pxNewQueue->uxLength = uxQueueLength;
    3602:	63e6      	str	r6, [r4, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
    3604:	6425      	str	r5, [r4, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3606:	2101      	movs	r1, #1
    3608:	0020      	movs	r0, r4
    360a:	f7ff ffaf 	bl	356c <xQueueGenericReset>
			pxNewQueue->ucQueueType = ucQueueType;
    360e:	0023      	movs	r3, r4
    3610:	3350      	adds	r3, #80	; 0x50
    3612:	701f      	strb	r7, [r3, #0]
			pxNewQueue->pxQueueSetContainer = NULL;
    3614:	2300      	movs	r3, #0
    3616:	6563      	str	r3, [r4, #84]	; 0x54
}
    3618:	0020      	movs	r0, r4
    361a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    361c:	0003      	movs	r3, r0
    361e:	3358      	adds	r3, #88	; 0x58
    3620:	6003      	str	r3, [r0, #0]
    3622:	e7ee      	b.n	3602 <xQueueGenericCreate+0x2e>
	configASSERT( xReturn );
    3624:	b672      	cpsid	i
    3626:	f7fe fc49 	bl	1ebc <rtosFatalError>
    362a:	e7f5      	b.n	3618 <xQueueGenericCreate+0x44>

0000362c <xQueueGenericSend>:
{
    362c:	b5f0      	push	{r4, r5, r6, r7, lr}
    362e:	b085      	sub	sp, #20
    3630:	0004      	movs	r4, r0
    3632:	9100      	str	r1, [sp, #0]
    3634:	9201      	str	r2, [sp, #4]
    3636:	001d      	movs	r5, r3
	configASSERT( pxQueue );
    3638:	2800      	cmp	r0, #0
    363a:	d102      	bne.n	3642 <xQueueGenericSend+0x16>
    363c:	b672      	cpsid	i
    363e:	f7fe fc3d 	bl	1ebc <rtosFatalError>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3642:	9b00      	ldr	r3, [sp, #0]
    3644:	2b00      	cmp	r3, #0
    3646:	d103      	bne.n	3650 <xQueueGenericSend+0x24>
    3648:	6c23      	ldr	r3, [r4, #64]	; 0x40
    364a:	2b00      	cmp	r3, #0
    364c:	d000      	beq.n	3650 <xQueueGenericSend+0x24>
    364e:	e080      	b.n	3752 <xQueueGenericSend+0x126>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    3650:	2d02      	cmp	r5, #2
    3652:	d103      	bne.n	365c <xQueueGenericSend+0x30>
    3654:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3656:	2b01      	cmp	r3, #1
    3658:	d000      	beq.n	365c <xQueueGenericSend+0x30>
    365a:	e07e      	b.n	375a <xQueueGenericSend+0x12e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    365c:	f7ff f840 	bl	26e0 <xTaskGetSchedulerState>
    3660:	2800      	cmp	r0, #0
    3662:	d105      	bne.n	3670 <xQueueGenericSend+0x44>
    3664:	9b01      	ldr	r3, [sp, #4]
    3666:	2b00      	cmp	r3, #0
    3668:	d002      	beq.n	3670 <xQueueGenericSend+0x44>
    366a:	b672      	cpsid	i
    366c:	f7fe fc26 	bl	1ebc <rtosFatalError>
{
    3670:	2700      	movs	r7, #0
    3672:	e045      	b.n	3700 <xQueueGenericSend+0xd4>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3674:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3676:	2b00      	cmp	r3, #0
    3678:	d004      	beq.n	3684 <xQueueGenericSend+0x58>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    367a:	0020      	movs	r0, r4
    367c:	3024      	adds	r0, #36	; 0x24
    367e:	f7fe ff97 	bl	25b0 <xTaskRemoveFromEventList>
    3682:	e051      	b.n	3728 <xQueueGenericSend+0xfc>
						else if( xYieldRequired != pdFALSE )
    3684:	2800      	cmp	r0, #0
    3686:	d053      	beq.n	3730 <xQueueGenericSend+0x104>
    3688:	e050      	b.n	372c <xQueueGenericSend+0x100>
				if( xTicksToWait == ( TickType_t ) 0 )
    368a:	9e01      	ldr	r6, [sp, #4]
    368c:	2e00      	cmp	r6, #0
    368e:	d103      	bne.n	3698 <xQueueGenericSend+0x6c>
					taskEXIT_CRITICAL();
    3690:	f7ff fe34 	bl	32fc <vPortExitCritical>
			return errQUEUE_FULL;
    3694:	2000      	movs	r0, #0
    3696:	e04e      	b.n	3736 <xQueueGenericSend+0x10a>
				else if( xEntryTimeSet == pdFALSE )
    3698:	2f00      	cmp	r7, #0
    369a:	d102      	bne.n	36a2 <xQueueGenericSend+0x76>
					vTaskSetTimeOutState( &xTimeOut );
    369c:	a802      	add	r0, sp, #8
    369e:	f7fe ffc3 	bl	2628 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
    36a2:	f7ff fe2b 	bl	32fc <vPortExitCritical>
		vTaskSuspendAll();
    36a6:	f7fe fda1 	bl	21ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    36aa:	f7ff fe1b 	bl	32e4 <vPortEnterCritical>
    36ae:	6c63      	ldr	r3, [r4, #68]	; 0x44
    36b0:	3301      	adds	r3, #1
    36b2:	d101      	bne.n	36b8 <xQueueGenericSend+0x8c>
    36b4:	2300      	movs	r3, #0
    36b6:	6463      	str	r3, [r4, #68]	; 0x44
    36b8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    36ba:	3301      	adds	r3, #1
    36bc:	d101      	bne.n	36c2 <xQueueGenericSend+0x96>
    36be:	2300      	movs	r3, #0
    36c0:	64a3      	str	r3, [r4, #72]	; 0x48
    36c2:	f7ff fe1b 	bl	32fc <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    36c6:	a901      	add	r1, sp, #4
    36c8:	a802      	add	r0, sp, #8
    36ca:	f7fe ffbf 	bl	264c <xTaskCheckForTimeOut>
    36ce:	2800      	cmp	r0, #0
    36d0:	d139      	bne.n	3746 <xQueueGenericSend+0x11a>
	taskENTER_CRITICAL();
    36d2:	f7ff fe07 	bl	32e4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    36d6:	6ba7      	ldr	r7, [r4, #56]	; 0x38
    36d8:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    36da:	f7ff fe0f 	bl	32fc <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    36de:	42b7      	cmp	r7, r6
    36e0:	d12b      	bne.n	373a <xQueueGenericSend+0x10e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    36e2:	0020      	movs	r0, r4
    36e4:	9901      	ldr	r1, [sp, #4]
    36e6:	3010      	adds	r0, #16
    36e8:	f7fe ff14 	bl	2514 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    36ec:	0020      	movs	r0, r4
    36ee:	f7ff fefe 	bl	34ee <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    36f2:	f7fe fe11 	bl	2318 <xTaskResumeAll>
    36f6:	2800      	cmp	r0, #0
    36f8:	d101      	bne.n	36fe <xQueueGenericSend+0xd2>
					portYIELD_WITHIN_API();
    36fa:	f7ff fde7 	bl	32cc <vPortYield>
    36fe:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
    3700:	f7ff fdf0 	bl	32e4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3704:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3706:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    3708:	4293      	cmp	r3, r2
    370a:	d301      	bcc.n	3710 <xQueueGenericSend+0xe4>
    370c:	2d02      	cmp	r5, #2
    370e:	d1bc      	bne.n	368a <xQueueGenericSend+0x5e>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3710:	002a      	movs	r2, r5
    3712:	9900      	ldr	r1, [sp, #0]
    3714:	0020      	movs	r0, r4
    3716:	f7ff fe71 	bl	33fc <prvCopyDataToQueue>
					if( pxQueue->pxQueueSetContainer != NULL )
    371a:	6d63      	ldr	r3, [r4, #84]	; 0x54
    371c:	2b00      	cmp	r3, #0
    371e:	d0a9      	beq.n	3674 <xQueueGenericSend+0x48>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    3720:	0029      	movs	r1, r5
    3722:	0020      	movs	r0, r4
    3724:	f7ff fea3 	bl	346e <prvNotifyQueueSetContainer>
    3728:	2801      	cmp	r0, #1
    372a:	d101      	bne.n	3730 <xQueueGenericSend+0x104>
							queueYIELD_IF_USING_PREEMPTION();
    372c:	f7ff fdce 	bl	32cc <vPortYield>
				taskEXIT_CRITICAL();
    3730:	f7ff fde4 	bl	32fc <vPortExitCritical>
				return pdPASS;
    3734:	2001      	movs	r0, #1
}
    3736:	b005      	add	sp, #20
    3738:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
    373a:	0020      	movs	r0, r4
    373c:	f7ff fed7 	bl	34ee <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3740:	f7fe fdea 	bl	2318 <xTaskResumeAll>
    3744:	e7db      	b.n	36fe <xQueueGenericSend+0xd2>
			prvUnlockQueue( pxQueue );
    3746:	0020      	movs	r0, r4
    3748:	f7ff fed1 	bl	34ee <prvUnlockQueue>
			( void ) xTaskResumeAll();
    374c:	f7fe fde4 	bl	2318 <xTaskResumeAll>
    3750:	e7a0      	b.n	3694 <xQueueGenericSend+0x68>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3752:	b672      	cpsid	i
    3754:	f7fe fbb2 	bl	1ebc <rtosFatalError>
    3758:	e77a      	b.n	3650 <xQueueGenericSend+0x24>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    375a:	b672      	cpsid	i
    375c:	f7fe fbae 	bl	1ebc <rtosFatalError>
    3760:	e77c      	b.n	365c <xQueueGenericSend+0x30>

00003762 <xQueueGenericSendFromISR>:
{
    3762:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3764:	0004      	movs	r4, r0
    3766:	9100      	str	r1, [sp, #0]
    3768:	0017      	movs	r7, r2
    376a:	001e      	movs	r6, r3
	configASSERT( pxQueue );
    376c:	2800      	cmp	r0, #0
    376e:	d102      	bne.n	3776 <xQueueGenericSendFromISR+0x14>
    3770:	b672      	cpsid	i
    3772:	f7fe fba3 	bl	1ebc <rtosFatalError>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3776:	9b00      	ldr	r3, [sp, #0]
    3778:	2b00      	cmp	r3, #0
    377a:	d102      	bne.n	3782 <xQueueGenericSendFromISR+0x20>
    377c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    377e:	2b00      	cmp	r3, #0
    3780:	d137      	bne.n	37f2 <xQueueGenericSendFromISR+0x90>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    3782:	2e02      	cmp	r6, #2
    3784:	d102      	bne.n	378c <xQueueGenericSendFromISR+0x2a>
    3786:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    3788:	2b01      	cmp	r3, #1
    378a:	d136      	bne.n	37fa <xQueueGenericSendFromISR+0x98>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    378c:	f7ff fdc8 	bl	3320 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3790:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3792:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3794:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3796:	4293      	cmp	r3, r2
    3798:	d302      	bcc.n	37a0 <xQueueGenericSendFromISR+0x3e>
			xReturn = errQUEUE_FULL;
    379a:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    379c:	2e02      	cmp	r6, #2
    379e:	d11f      	bne.n	37e0 <xQueueGenericSendFromISR+0x7e>
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    37a0:	0032      	movs	r2, r6
    37a2:	9900      	ldr	r1, [sp, #0]
    37a4:	0020      	movs	r0, r4
    37a6:	f7ff fe29 	bl	33fc <prvCopyDataToQueue>
			if( pxQueue->xTxLock == queueUNLOCKED )
    37aa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    37ac:	3301      	adds	r3, #1
    37ae:	d11c      	bne.n	37ea <xQueueGenericSendFromISR+0x88>
					if( pxQueue->pxQueueSetContainer != NULL )
    37b0:	6d63      	ldr	r3, [r4, #84]	; 0x54
    37b2:	2b00      	cmp	r3, #0
    37b4:	d007      	beq.n	37c6 <xQueueGenericSendFromISR+0x64>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    37b6:	0031      	movs	r1, r6
    37b8:	0020      	movs	r0, r4
    37ba:	f7ff fe58 	bl	346e <prvNotifyQueueSetContainer>
    37be:	2801      	cmp	r0, #1
    37c0:	d00a      	beq.n	37d8 <xQueueGenericSendFromISR+0x76>
			xReturn = pdPASS;
    37c2:	2501      	movs	r5, #1
    37c4:	e00c      	b.n	37e0 <xQueueGenericSendFromISR+0x7e>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    37c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    37c8:	2b00      	cmp	r3, #0
    37ca:	d0fa      	beq.n	37c2 <xQueueGenericSendFromISR+0x60>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    37cc:	0020      	movs	r0, r4
    37ce:	3024      	adds	r0, #36	; 0x24
    37d0:	f7fe feee 	bl	25b0 <xTaskRemoveFromEventList>
    37d4:	2800      	cmp	r0, #0
    37d6:	d0f4      	beq.n	37c2 <xQueueGenericSendFromISR+0x60>
							if( pxHigherPriorityTaskWoken != NULL )
    37d8:	2f00      	cmp	r7, #0
    37da:	d0f2      	beq.n	37c2 <xQueueGenericSendFromISR+0x60>
								*pxHigherPriorityTaskWoken = pdTRUE;
    37dc:	2501      	movs	r5, #1
    37de:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    37e0:	9801      	ldr	r0, [sp, #4]
    37e2:	f7ff fda2 	bl	332a <vClearInterruptMaskFromISR>
}
    37e6:	0028      	movs	r0, r5
    37e8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
				++( pxQueue->xTxLock );
    37ea:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    37ec:	3301      	adds	r3, #1
    37ee:	64a3      	str	r3, [r4, #72]	; 0x48
    37f0:	e7e7      	b.n	37c2 <xQueueGenericSendFromISR+0x60>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    37f2:	b672      	cpsid	i
    37f4:	f7fe fb62 	bl	1ebc <rtosFatalError>
    37f8:	e7c3      	b.n	3782 <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    37fa:	b672      	cpsid	i
    37fc:	f7fe fb5e 	bl	1ebc <rtosFatalError>
    3800:	e7c4      	b.n	378c <xQueueGenericSendFromISR+0x2a>

00003802 <xQueueGenericReceive>:
{
    3802:	b5f0      	push	{r4, r5, r6, r7, lr}
    3804:	b085      	sub	sp, #20
    3806:	0004      	movs	r4, r0
    3808:	000f      	movs	r7, r1
    380a:	9201      	str	r2, [sp, #4]
    380c:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
    380e:	2800      	cmp	r0, #0
    3810:	d102      	bne.n	3818 <xQueueGenericReceive+0x16>
    3812:	b672      	cpsid	i
    3814:	f7fe fb52 	bl	1ebc <rtosFatalError>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3818:	2f00      	cmp	r7, #0
    381a:	d103      	bne.n	3824 <xQueueGenericReceive+0x22>
    381c:	6c23      	ldr	r3, [r4, #64]	; 0x40
    381e:	2b00      	cmp	r3, #0
    3820:	d000      	beq.n	3824 <xQueueGenericReceive+0x22>
    3822:	e08c      	b.n	393e <xQueueGenericReceive+0x13c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3824:	f7fe ff5c 	bl	26e0 <xTaskGetSchedulerState>
    3828:	2800      	cmp	r0, #0
    382a:	d105      	bne.n	3838 <xQueueGenericReceive+0x36>
    382c:	9b01      	ldr	r3, [sp, #4]
    382e:	2b00      	cmp	r3, #0
    3830:	d002      	beq.n	3838 <xQueueGenericReceive+0x36>
    3832:	b672      	cpsid	i
    3834:	f7fe fb42 	bl	1ebc <rtosFatalError>
{
    3838:	2600      	movs	r6, #0
    383a:	e04e      	b.n	38da <xQueueGenericReceive+0xd8>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    383c:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    383e:	60e5      	str	r5, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3840:	2b00      	cmp	r3, #0
    3842:	d06b      	beq.n	391c <xQueueGenericReceive+0x11a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3844:	0020      	movs	r0, r4
    3846:	3024      	adds	r0, #36	; 0x24
    3848:	f7fe feb2 	bl	25b0 <xTaskRemoveFromEventList>
    384c:	2800      	cmp	r0, #0
    384e:	d065      	beq.n	391c <xQueueGenericReceive+0x11a>
    3850:	e062      	b.n	3918 <xQueueGenericReceive+0x116>
				if( xTicksToWait == ( TickType_t ) 0 )
    3852:	9d01      	ldr	r5, [sp, #4]
    3854:	2d00      	cmp	r5, #0
    3856:	d103      	bne.n	3860 <xQueueGenericReceive+0x5e>
					taskEXIT_CRITICAL();
    3858:	f7ff fd50 	bl	32fc <vPortExitCritical>
			return errQUEUE_EMPTY;
    385c:	2000      	movs	r0, #0
    385e:	e060      	b.n	3922 <xQueueGenericReceive+0x120>
				else if( xEntryTimeSet == pdFALSE )
    3860:	2e00      	cmp	r6, #0
    3862:	d102      	bne.n	386a <xQueueGenericReceive+0x68>
					vTaskSetTimeOutState( &xTimeOut );
    3864:	a802      	add	r0, sp, #8
    3866:	f7fe fedf 	bl	2628 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
    386a:	f7ff fd47 	bl	32fc <vPortExitCritical>
		vTaskSuspendAll();
    386e:	f7fe fcbd 	bl	21ec <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3872:	f7ff fd37 	bl	32e4 <vPortEnterCritical>
    3876:	6c63      	ldr	r3, [r4, #68]	; 0x44
    3878:	3301      	adds	r3, #1
    387a:	d101      	bne.n	3880 <xQueueGenericReceive+0x7e>
    387c:	2300      	movs	r3, #0
    387e:	6463      	str	r3, [r4, #68]	; 0x44
    3880:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3882:	3301      	adds	r3, #1
    3884:	d101      	bne.n	388a <xQueueGenericReceive+0x88>
    3886:	2300      	movs	r3, #0
    3888:	64a3      	str	r3, [r4, #72]	; 0x48
    388a:	f7ff fd37 	bl	32fc <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    388e:	a901      	add	r1, sp, #4
    3890:	a802      	add	r0, sp, #8
    3892:	f7fe fedb 	bl	264c <xTaskCheckForTimeOut>
    3896:	2800      	cmp	r0, #0
    3898:	d14b      	bne.n	3932 <xQueueGenericReceive+0x130>
	taskENTER_CRITICAL();
    389a:	f7ff fd23 	bl	32e4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    389e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
    38a0:	f7ff fd2c 	bl	32fc <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    38a4:	2d00      	cmp	r5, #0
    38a6:	d13e      	bne.n	3926 <xQueueGenericReceive+0x124>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    38a8:	6823      	ldr	r3, [r4, #0]
    38aa:	2b00      	cmp	r3, #0
    38ac:	d106      	bne.n	38bc <xQueueGenericReceive+0xba>
						taskENTER_CRITICAL();
    38ae:	f7ff fd19 	bl	32e4 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    38b2:	6860      	ldr	r0, [r4, #4]
    38b4:	f7fe ff24 	bl	2700 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
    38b8:	f7ff fd20 	bl	32fc <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    38bc:	0020      	movs	r0, r4
    38be:	9901      	ldr	r1, [sp, #4]
    38c0:	3024      	adds	r0, #36	; 0x24
    38c2:	f7fe fe27 	bl	2514 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    38c6:	0020      	movs	r0, r4
    38c8:	f7ff fe11 	bl	34ee <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    38cc:	f7fe fd24 	bl	2318 <xTaskResumeAll>
    38d0:	2800      	cmp	r0, #0
    38d2:	d101      	bne.n	38d8 <xQueueGenericReceive+0xd6>
					portYIELD_WITHIN_API();
    38d4:	f7ff fcfa 	bl	32cc <vPortYield>
    38d8:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    38da:	f7ff fd03 	bl	32e4 <vPortEnterCritical>
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    38de:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    38e0:	2b00      	cmp	r3, #0
    38e2:	d0b6      	beq.n	3852 <xQueueGenericReceive+0x50>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    38e4:	0039      	movs	r1, r7
    38e6:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    38e8:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    38ea:	f7ff fdee 	bl	34ca <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
    38ee:	9b00      	ldr	r3, [sp, #0]
    38f0:	2b00      	cmp	r3, #0
    38f2:	d1a3      	bne.n	383c <xQueueGenericReceive+0x3a>
					--( pxQueue->uxMessagesWaiting );
    38f4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    38f6:	3b01      	subs	r3, #1
    38f8:	63a3      	str	r3, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    38fa:	6823      	ldr	r3, [r4, #0]
    38fc:	2b00      	cmp	r3, #0
    38fe:	d102      	bne.n	3906 <xQueueGenericReceive+0x104>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3900:	f7fe ff6c 	bl	27dc <pvTaskIncrementMutexHeldCount>
    3904:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3906:	6923      	ldr	r3, [r4, #16]
    3908:	2b00      	cmp	r3, #0
    390a:	d007      	beq.n	391c <xQueueGenericReceive+0x11a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    390c:	0020      	movs	r0, r4
    390e:	3010      	adds	r0, #16
    3910:	f7fe fe4e 	bl	25b0 <xTaskRemoveFromEventList>
    3914:	2801      	cmp	r0, #1
    3916:	d101      	bne.n	391c <xQueueGenericReceive+0x11a>
							queueYIELD_IF_USING_PREEMPTION();
    3918:	f7ff fcd8 	bl	32cc <vPortYield>
				taskEXIT_CRITICAL();
    391c:	f7ff fcee 	bl	32fc <vPortExitCritical>
				return pdPASS;
    3920:	2001      	movs	r0, #1
}
    3922:	b005      	add	sp, #20
    3924:	bdf0      	pop	{r4, r5, r6, r7, pc}
				prvUnlockQueue( pxQueue );
    3926:	0020      	movs	r0, r4
    3928:	f7ff fde1 	bl	34ee <prvUnlockQueue>
				( void ) xTaskResumeAll();
    392c:	f7fe fcf4 	bl	2318 <xTaskResumeAll>
    3930:	e7d2      	b.n	38d8 <xQueueGenericReceive+0xd6>
			prvUnlockQueue( pxQueue );
    3932:	0020      	movs	r0, r4
    3934:	f7ff fddb 	bl	34ee <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3938:	f7fe fcee 	bl	2318 <xTaskResumeAll>
    393c:	e78e      	b.n	385c <xQueueGenericReceive+0x5a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    393e:	b672      	cpsid	i
    3940:	f7fe fabc 	bl	1ebc <rtosFatalError>
    3944:	e76e      	b.n	3824 <xQueueGenericReceive+0x22>
	...

00003948 <vQueueAddToRegistry>:
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    3948:	2300      	movs	r3, #0
	{
    394a:	b570      	push	{r4, r5, r6, lr}
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    394c:	4a06      	ldr	r2, [pc, #24]	; (3968 <vQueueAddToRegistry+0x20>)
    394e:	00dd      	lsls	r5, r3, #3
    3950:	18ac      	adds	r4, r5, r2
    3952:	6826      	ldr	r6, [r4, #0]
    3954:	2e00      	cmp	r6, #0
    3956:	d102      	bne.n	395e <vQueueAddToRegistry+0x16>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    3958:	50a9      	str	r1, [r5, r2]
				xQueueRegistry[ ux ].xHandle = xQueue;
    395a:	6060      	str	r0, [r4, #4]
	}
    395c:	bd70      	pop	{r4, r5, r6, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    395e:	3301      	adds	r3, #1
    3960:	2b08      	cmp	r3, #8
    3962:	d1f4      	bne.n	394e <vQueueAddToRegistry+0x6>
    3964:	e7fa      	b.n	395c <vQueueAddToRegistry+0x14>
    3966:	46c0      	nop			; (mov r8, r8)
    3968:	20003d64 	.word	0x20003d64

0000396c <vQueueWaitForMessageRestricted>:
	{
    396c:	b570      	push	{r4, r5, r6, lr}
    396e:	0004      	movs	r4, r0
    3970:	000d      	movs	r5, r1
    3972:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
    3974:	f7ff fcb6 	bl	32e4 <vPortEnterCritical>
    3978:	6c63      	ldr	r3, [r4, #68]	; 0x44
    397a:	3301      	adds	r3, #1
    397c:	d101      	bne.n	3982 <vQueueWaitForMessageRestricted+0x16>
    397e:	2300      	movs	r3, #0
    3980:	6463      	str	r3, [r4, #68]	; 0x44
    3982:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    3984:	3301      	adds	r3, #1
    3986:	d101      	bne.n	398c <vQueueWaitForMessageRestricted+0x20>
    3988:	2300      	movs	r3, #0
    398a:	64a3      	str	r3, [r4, #72]	; 0x48
    398c:	f7ff fcb6 	bl	32fc <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    3990:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    3992:	2b00      	cmp	r3, #0
    3994:	d105      	bne.n	39a2 <vQueueWaitForMessageRestricted+0x36>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3996:	0020      	movs	r0, r4
    3998:	0032      	movs	r2, r6
    399a:	0029      	movs	r1, r5
    399c:	3024      	adds	r0, #36	; 0x24
    399e:	f7fe fddf 	bl	2560 <vTaskPlaceOnEventListRestricted>
		prvUnlockQueue( pxQueue );
    39a2:	0020      	movs	r0, r4
    39a4:	f7ff fda3 	bl	34ee <prvUnlockQueue>
	}
    39a8:	bd70      	pop	{r4, r5, r6, pc}
	...

000039ac <__gnu_thumb1_case_uqi>:
    39ac:	b402      	push	{r1}
    39ae:	4671      	mov	r1, lr
    39b0:	0849      	lsrs	r1, r1, #1
    39b2:	0049      	lsls	r1, r1, #1
    39b4:	5c09      	ldrb	r1, [r1, r0]
    39b6:	0049      	lsls	r1, r1, #1
    39b8:	448e      	add	lr, r1
    39ba:	bc02      	pop	{r1}
    39bc:	4770      	bx	lr
    39be:	46c0      	nop			; (mov r8, r8)

000039c0 <__udivsi3>:
    39c0:	2200      	movs	r2, #0
    39c2:	0843      	lsrs	r3, r0, #1
    39c4:	428b      	cmp	r3, r1
    39c6:	d374      	bcc.n	3ab2 <__udivsi3+0xf2>
    39c8:	0903      	lsrs	r3, r0, #4
    39ca:	428b      	cmp	r3, r1
    39cc:	d35f      	bcc.n	3a8e <__udivsi3+0xce>
    39ce:	0a03      	lsrs	r3, r0, #8
    39d0:	428b      	cmp	r3, r1
    39d2:	d344      	bcc.n	3a5e <__udivsi3+0x9e>
    39d4:	0b03      	lsrs	r3, r0, #12
    39d6:	428b      	cmp	r3, r1
    39d8:	d328      	bcc.n	3a2c <__udivsi3+0x6c>
    39da:	0c03      	lsrs	r3, r0, #16
    39dc:	428b      	cmp	r3, r1
    39de:	d30d      	bcc.n	39fc <__udivsi3+0x3c>
    39e0:	22ff      	movs	r2, #255	; 0xff
    39e2:	0209      	lsls	r1, r1, #8
    39e4:	ba12      	rev	r2, r2
    39e6:	0c03      	lsrs	r3, r0, #16
    39e8:	428b      	cmp	r3, r1
    39ea:	d302      	bcc.n	39f2 <__udivsi3+0x32>
    39ec:	1212      	asrs	r2, r2, #8
    39ee:	0209      	lsls	r1, r1, #8
    39f0:	d065      	beq.n	3abe <__udivsi3+0xfe>
    39f2:	0b03      	lsrs	r3, r0, #12
    39f4:	428b      	cmp	r3, r1
    39f6:	d319      	bcc.n	3a2c <__udivsi3+0x6c>
    39f8:	e000      	b.n	39fc <__udivsi3+0x3c>
    39fa:	0a09      	lsrs	r1, r1, #8
    39fc:	0bc3      	lsrs	r3, r0, #15
    39fe:	428b      	cmp	r3, r1
    3a00:	d301      	bcc.n	3a06 <__udivsi3+0x46>
    3a02:	03cb      	lsls	r3, r1, #15
    3a04:	1ac0      	subs	r0, r0, r3
    3a06:	4152      	adcs	r2, r2
    3a08:	0b83      	lsrs	r3, r0, #14
    3a0a:	428b      	cmp	r3, r1
    3a0c:	d301      	bcc.n	3a12 <__udivsi3+0x52>
    3a0e:	038b      	lsls	r3, r1, #14
    3a10:	1ac0      	subs	r0, r0, r3
    3a12:	4152      	adcs	r2, r2
    3a14:	0b43      	lsrs	r3, r0, #13
    3a16:	428b      	cmp	r3, r1
    3a18:	d301      	bcc.n	3a1e <__udivsi3+0x5e>
    3a1a:	034b      	lsls	r3, r1, #13
    3a1c:	1ac0      	subs	r0, r0, r3
    3a1e:	4152      	adcs	r2, r2
    3a20:	0b03      	lsrs	r3, r0, #12
    3a22:	428b      	cmp	r3, r1
    3a24:	d301      	bcc.n	3a2a <__udivsi3+0x6a>
    3a26:	030b      	lsls	r3, r1, #12
    3a28:	1ac0      	subs	r0, r0, r3
    3a2a:	4152      	adcs	r2, r2
    3a2c:	0ac3      	lsrs	r3, r0, #11
    3a2e:	428b      	cmp	r3, r1
    3a30:	d301      	bcc.n	3a36 <__udivsi3+0x76>
    3a32:	02cb      	lsls	r3, r1, #11
    3a34:	1ac0      	subs	r0, r0, r3
    3a36:	4152      	adcs	r2, r2
    3a38:	0a83      	lsrs	r3, r0, #10
    3a3a:	428b      	cmp	r3, r1
    3a3c:	d301      	bcc.n	3a42 <__udivsi3+0x82>
    3a3e:	028b      	lsls	r3, r1, #10
    3a40:	1ac0      	subs	r0, r0, r3
    3a42:	4152      	adcs	r2, r2
    3a44:	0a43      	lsrs	r3, r0, #9
    3a46:	428b      	cmp	r3, r1
    3a48:	d301      	bcc.n	3a4e <__udivsi3+0x8e>
    3a4a:	024b      	lsls	r3, r1, #9
    3a4c:	1ac0      	subs	r0, r0, r3
    3a4e:	4152      	adcs	r2, r2
    3a50:	0a03      	lsrs	r3, r0, #8
    3a52:	428b      	cmp	r3, r1
    3a54:	d301      	bcc.n	3a5a <__udivsi3+0x9a>
    3a56:	020b      	lsls	r3, r1, #8
    3a58:	1ac0      	subs	r0, r0, r3
    3a5a:	4152      	adcs	r2, r2
    3a5c:	d2cd      	bcs.n	39fa <__udivsi3+0x3a>
    3a5e:	09c3      	lsrs	r3, r0, #7
    3a60:	428b      	cmp	r3, r1
    3a62:	d301      	bcc.n	3a68 <__udivsi3+0xa8>
    3a64:	01cb      	lsls	r3, r1, #7
    3a66:	1ac0      	subs	r0, r0, r3
    3a68:	4152      	adcs	r2, r2
    3a6a:	0983      	lsrs	r3, r0, #6
    3a6c:	428b      	cmp	r3, r1
    3a6e:	d301      	bcc.n	3a74 <__udivsi3+0xb4>
    3a70:	018b      	lsls	r3, r1, #6
    3a72:	1ac0      	subs	r0, r0, r3
    3a74:	4152      	adcs	r2, r2
    3a76:	0943      	lsrs	r3, r0, #5
    3a78:	428b      	cmp	r3, r1
    3a7a:	d301      	bcc.n	3a80 <__udivsi3+0xc0>
    3a7c:	014b      	lsls	r3, r1, #5
    3a7e:	1ac0      	subs	r0, r0, r3
    3a80:	4152      	adcs	r2, r2
    3a82:	0903      	lsrs	r3, r0, #4
    3a84:	428b      	cmp	r3, r1
    3a86:	d301      	bcc.n	3a8c <__udivsi3+0xcc>
    3a88:	010b      	lsls	r3, r1, #4
    3a8a:	1ac0      	subs	r0, r0, r3
    3a8c:	4152      	adcs	r2, r2
    3a8e:	08c3      	lsrs	r3, r0, #3
    3a90:	428b      	cmp	r3, r1
    3a92:	d301      	bcc.n	3a98 <__udivsi3+0xd8>
    3a94:	00cb      	lsls	r3, r1, #3
    3a96:	1ac0      	subs	r0, r0, r3
    3a98:	4152      	adcs	r2, r2
    3a9a:	0883      	lsrs	r3, r0, #2
    3a9c:	428b      	cmp	r3, r1
    3a9e:	d301      	bcc.n	3aa4 <__udivsi3+0xe4>
    3aa0:	008b      	lsls	r3, r1, #2
    3aa2:	1ac0      	subs	r0, r0, r3
    3aa4:	4152      	adcs	r2, r2
    3aa6:	0843      	lsrs	r3, r0, #1
    3aa8:	428b      	cmp	r3, r1
    3aaa:	d301      	bcc.n	3ab0 <__udivsi3+0xf0>
    3aac:	004b      	lsls	r3, r1, #1
    3aae:	1ac0      	subs	r0, r0, r3
    3ab0:	4152      	adcs	r2, r2
    3ab2:	1a41      	subs	r1, r0, r1
    3ab4:	d200      	bcs.n	3ab8 <__udivsi3+0xf8>
    3ab6:	4601      	mov	r1, r0
    3ab8:	4152      	adcs	r2, r2
    3aba:	4610      	mov	r0, r2
    3abc:	4770      	bx	lr
    3abe:	e7ff      	b.n	3ac0 <__udivsi3+0x100>
    3ac0:	b501      	push	{r0, lr}
    3ac2:	2000      	movs	r0, #0
    3ac4:	f000 f806 	bl	3ad4 <__aeabi_idiv0>
    3ac8:	bd02      	pop	{r1, pc}
    3aca:	46c0      	nop			; (mov r8, r8)

00003acc <__aeabi_uidivmod>:
    3acc:	2900      	cmp	r1, #0
    3ace:	d0f7      	beq.n	3ac0 <__udivsi3+0x100>
    3ad0:	e776      	b.n	39c0 <__udivsi3>
    3ad2:	4770      	bx	lr

00003ad4 <__aeabi_idiv0>:
    3ad4:	4770      	bx	lr
    3ad6:	46c0      	nop			; (mov r8, r8)

00003ad8 <__libc_init_array>:
    3ad8:	b570      	push	{r4, r5, r6, lr}
    3ada:	2600      	movs	r6, #0
    3adc:	4d0c      	ldr	r5, [pc, #48]	; (3b10 <__libc_init_array+0x38>)
    3ade:	4c0d      	ldr	r4, [pc, #52]	; (3b14 <__libc_init_array+0x3c>)
    3ae0:	1b64      	subs	r4, r4, r5
    3ae2:	10a4      	asrs	r4, r4, #2
    3ae4:	42a6      	cmp	r6, r4
    3ae6:	d109      	bne.n	3afc <__libc_init_array+0x24>
    3ae8:	2600      	movs	r6, #0
    3aea:	f000 f911 	bl	3d10 <_init>
    3aee:	4d0a      	ldr	r5, [pc, #40]	; (3b18 <__libc_init_array+0x40>)
    3af0:	4c0a      	ldr	r4, [pc, #40]	; (3b1c <__libc_init_array+0x44>)
    3af2:	1b64      	subs	r4, r4, r5
    3af4:	10a4      	asrs	r4, r4, #2
    3af6:	42a6      	cmp	r6, r4
    3af8:	d105      	bne.n	3b06 <__libc_init_array+0x2e>
    3afa:	bd70      	pop	{r4, r5, r6, pc}
    3afc:	00b3      	lsls	r3, r6, #2
    3afe:	58eb      	ldr	r3, [r5, r3]
    3b00:	4798      	blx	r3
    3b02:	3601      	adds	r6, #1
    3b04:	e7ee      	b.n	3ae4 <__libc_init_array+0xc>
    3b06:	00b3      	lsls	r3, r6, #2
    3b08:	58eb      	ldr	r3, [r5, r3]
    3b0a:	4798      	blx	r3
    3b0c:	3601      	adds	r6, #1
    3b0e:	e7f2      	b.n	3af6 <__libc_init_array+0x1e>
    3b10:	200000ec 	.word	0x200000ec
    3b14:	200000ec 	.word	0x200000ec
    3b18:	200000ec 	.word	0x200000ec
    3b1c:	200000fc 	.word	0x200000fc

00003b20 <malloc>:
    3b20:	b510      	push	{r4, lr}
    3b22:	4b03      	ldr	r3, [pc, #12]	; (3b30 <malloc+0x10>)
    3b24:	0001      	movs	r1, r0
    3b26:	6818      	ldr	r0, [r3, #0]
    3b28:	f000 f86a 	bl	3c00 <_malloc_r>
    3b2c:	bd10      	pop	{r4, pc}
    3b2e:	46c0      	nop			; (mov r8, r8)
    3b30:	20000088 	.word	0x20000088

00003b34 <free>:
    3b34:	b510      	push	{r4, lr}
    3b36:	4b03      	ldr	r3, [pc, #12]	; (3b44 <free+0x10>)
    3b38:	0001      	movs	r1, r0
    3b3a:	6818      	ldr	r0, [r3, #0]
    3b3c:	f000 f816 	bl	3b6c <_free_r>
    3b40:	bd10      	pop	{r4, pc}
    3b42:	46c0      	nop			; (mov r8, r8)
    3b44:	20000088 	.word	0x20000088

00003b48 <memcpy>:
    3b48:	2300      	movs	r3, #0
    3b4a:	b510      	push	{r4, lr}
    3b4c:	429a      	cmp	r2, r3
    3b4e:	d100      	bne.n	3b52 <memcpy+0xa>
    3b50:	bd10      	pop	{r4, pc}
    3b52:	5ccc      	ldrb	r4, [r1, r3]
    3b54:	54c4      	strb	r4, [r0, r3]
    3b56:	3301      	adds	r3, #1
    3b58:	e7f8      	b.n	3b4c <memcpy+0x4>

00003b5a <memset>:
    3b5a:	0003      	movs	r3, r0
    3b5c:	1882      	adds	r2, r0, r2
    3b5e:	4293      	cmp	r3, r2
    3b60:	d100      	bne.n	3b64 <memset+0xa>
    3b62:	4770      	bx	lr
    3b64:	7019      	strb	r1, [r3, #0]
    3b66:	3301      	adds	r3, #1
    3b68:	e7f9      	b.n	3b5e <memset+0x4>
	...

00003b6c <_free_r>:
    3b6c:	b570      	push	{r4, r5, r6, lr}
    3b6e:	0005      	movs	r5, r0
    3b70:	2900      	cmp	r1, #0
    3b72:	d010      	beq.n	3b96 <_free_r+0x2a>
    3b74:	1f0c      	subs	r4, r1, #4
    3b76:	6823      	ldr	r3, [r4, #0]
    3b78:	2b00      	cmp	r3, #0
    3b7a:	da00      	bge.n	3b7e <_free_r+0x12>
    3b7c:	18e4      	adds	r4, r4, r3
    3b7e:	0028      	movs	r0, r5
    3b80:	f000 f8b5 	bl	3cee <__malloc_lock>
    3b84:	4a1d      	ldr	r2, [pc, #116]	; (3bfc <_free_r+0x90>)
    3b86:	6813      	ldr	r3, [r2, #0]
    3b88:	2b00      	cmp	r3, #0
    3b8a:	d105      	bne.n	3b98 <_free_r+0x2c>
    3b8c:	6063      	str	r3, [r4, #4]
    3b8e:	6014      	str	r4, [r2, #0]
    3b90:	0028      	movs	r0, r5
    3b92:	f000 f8ad 	bl	3cf0 <__malloc_unlock>
    3b96:	bd70      	pop	{r4, r5, r6, pc}
    3b98:	42a3      	cmp	r3, r4
    3b9a:	d909      	bls.n	3bb0 <_free_r+0x44>
    3b9c:	6821      	ldr	r1, [r4, #0]
    3b9e:	1860      	adds	r0, r4, r1
    3ba0:	4283      	cmp	r3, r0
    3ba2:	d1f3      	bne.n	3b8c <_free_r+0x20>
    3ba4:	6818      	ldr	r0, [r3, #0]
    3ba6:	685b      	ldr	r3, [r3, #4]
    3ba8:	1841      	adds	r1, r0, r1
    3baa:	6021      	str	r1, [r4, #0]
    3bac:	e7ee      	b.n	3b8c <_free_r+0x20>
    3bae:	0013      	movs	r3, r2
    3bb0:	685a      	ldr	r2, [r3, #4]
    3bb2:	2a00      	cmp	r2, #0
    3bb4:	d001      	beq.n	3bba <_free_r+0x4e>
    3bb6:	42a2      	cmp	r2, r4
    3bb8:	d9f9      	bls.n	3bae <_free_r+0x42>
    3bba:	6819      	ldr	r1, [r3, #0]
    3bbc:	1858      	adds	r0, r3, r1
    3bbe:	42a0      	cmp	r0, r4
    3bc0:	d10b      	bne.n	3bda <_free_r+0x6e>
    3bc2:	6820      	ldr	r0, [r4, #0]
    3bc4:	1809      	adds	r1, r1, r0
    3bc6:	1858      	adds	r0, r3, r1
    3bc8:	6019      	str	r1, [r3, #0]
    3bca:	4282      	cmp	r2, r0
    3bcc:	d1e0      	bne.n	3b90 <_free_r+0x24>
    3bce:	6810      	ldr	r0, [r2, #0]
    3bd0:	6852      	ldr	r2, [r2, #4]
    3bd2:	1841      	adds	r1, r0, r1
    3bd4:	6019      	str	r1, [r3, #0]
    3bd6:	605a      	str	r2, [r3, #4]
    3bd8:	e7da      	b.n	3b90 <_free_r+0x24>
    3bda:	42a0      	cmp	r0, r4
    3bdc:	d902      	bls.n	3be4 <_free_r+0x78>
    3bde:	230c      	movs	r3, #12
    3be0:	602b      	str	r3, [r5, #0]
    3be2:	e7d5      	b.n	3b90 <_free_r+0x24>
    3be4:	6821      	ldr	r1, [r4, #0]
    3be6:	1860      	adds	r0, r4, r1
    3be8:	4282      	cmp	r2, r0
    3bea:	d103      	bne.n	3bf4 <_free_r+0x88>
    3bec:	6810      	ldr	r0, [r2, #0]
    3bee:	6852      	ldr	r2, [r2, #4]
    3bf0:	1841      	adds	r1, r0, r1
    3bf2:	6021      	str	r1, [r4, #0]
    3bf4:	6062      	str	r2, [r4, #4]
    3bf6:	605c      	str	r4, [r3, #4]
    3bf8:	e7ca      	b.n	3b90 <_free_r+0x24>
    3bfa:	46c0      	nop			; (mov r8, r8)
    3bfc:	20003d54 	.word	0x20003d54

00003c00 <_malloc_r>:
    3c00:	2303      	movs	r3, #3
    3c02:	b570      	push	{r4, r5, r6, lr}
    3c04:	1ccd      	adds	r5, r1, #3
    3c06:	439d      	bics	r5, r3
    3c08:	3508      	adds	r5, #8
    3c0a:	0006      	movs	r6, r0
    3c0c:	2d0c      	cmp	r5, #12
    3c0e:	d21e      	bcs.n	3c4e <_malloc_r+0x4e>
    3c10:	250c      	movs	r5, #12
    3c12:	42a9      	cmp	r1, r5
    3c14:	d81d      	bhi.n	3c52 <_malloc_r+0x52>
    3c16:	0030      	movs	r0, r6
    3c18:	f000 f869 	bl	3cee <__malloc_lock>
    3c1c:	4a25      	ldr	r2, [pc, #148]	; (3cb4 <_malloc_r+0xb4>)
    3c1e:	6814      	ldr	r4, [r2, #0]
    3c20:	0021      	movs	r1, r4
    3c22:	2900      	cmp	r1, #0
    3c24:	d119      	bne.n	3c5a <_malloc_r+0x5a>
    3c26:	4c24      	ldr	r4, [pc, #144]	; (3cb8 <_malloc_r+0xb8>)
    3c28:	6823      	ldr	r3, [r4, #0]
    3c2a:	2b00      	cmp	r3, #0
    3c2c:	d103      	bne.n	3c36 <_malloc_r+0x36>
    3c2e:	0030      	movs	r0, r6
    3c30:	f000 f844 	bl	3cbc <_sbrk_r>
    3c34:	6020      	str	r0, [r4, #0]
    3c36:	0029      	movs	r1, r5
    3c38:	0030      	movs	r0, r6
    3c3a:	f000 f83f 	bl	3cbc <_sbrk_r>
    3c3e:	1c43      	adds	r3, r0, #1
    3c40:	d12c      	bne.n	3c9c <_malloc_r+0x9c>
    3c42:	230c      	movs	r3, #12
    3c44:	0030      	movs	r0, r6
    3c46:	6033      	str	r3, [r6, #0]
    3c48:	f000 f852 	bl	3cf0 <__malloc_unlock>
    3c4c:	e003      	b.n	3c56 <_malloc_r+0x56>
    3c4e:	2d00      	cmp	r5, #0
    3c50:	dadf      	bge.n	3c12 <_malloc_r+0x12>
    3c52:	230c      	movs	r3, #12
    3c54:	6033      	str	r3, [r6, #0]
    3c56:	2000      	movs	r0, #0
    3c58:	bd70      	pop	{r4, r5, r6, pc}
    3c5a:	680b      	ldr	r3, [r1, #0]
    3c5c:	1b5b      	subs	r3, r3, r5
    3c5e:	d41a      	bmi.n	3c96 <_malloc_r+0x96>
    3c60:	2b0b      	cmp	r3, #11
    3c62:	d903      	bls.n	3c6c <_malloc_r+0x6c>
    3c64:	600b      	str	r3, [r1, #0]
    3c66:	18cc      	adds	r4, r1, r3
    3c68:	6025      	str	r5, [r4, #0]
    3c6a:	e003      	b.n	3c74 <_malloc_r+0x74>
    3c6c:	428c      	cmp	r4, r1
    3c6e:	d10e      	bne.n	3c8e <_malloc_r+0x8e>
    3c70:	6863      	ldr	r3, [r4, #4]
    3c72:	6013      	str	r3, [r2, #0]
    3c74:	0030      	movs	r0, r6
    3c76:	f000 f83b 	bl	3cf0 <__malloc_unlock>
    3c7a:	0020      	movs	r0, r4
    3c7c:	2207      	movs	r2, #7
    3c7e:	300b      	adds	r0, #11
    3c80:	1d23      	adds	r3, r4, #4
    3c82:	4390      	bics	r0, r2
    3c84:	1ac3      	subs	r3, r0, r3
    3c86:	d0e7      	beq.n	3c58 <_malloc_r+0x58>
    3c88:	425a      	negs	r2, r3
    3c8a:	50e2      	str	r2, [r4, r3]
    3c8c:	e7e4      	b.n	3c58 <_malloc_r+0x58>
    3c8e:	684b      	ldr	r3, [r1, #4]
    3c90:	6063      	str	r3, [r4, #4]
    3c92:	000c      	movs	r4, r1
    3c94:	e7ee      	b.n	3c74 <_malloc_r+0x74>
    3c96:	000c      	movs	r4, r1
    3c98:	6849      	ldr	r1, [r1, #4]
    3c9a:	e7c2      	b.n	3c22 <_malloc_r+0x22>
    3c9c:	2303      	movs	r3, #3
    3c9e:	1cc4      	adds	r4, r0, #3
    3ca0:	439c      	bics	r4, r3
    3ca2:	42a0      	cmp	r0, r4
    3ca4:	d0e0      	beq.n	3c68 <_malloc_r+0x68>
    3ca6:	1a21      	subs	r1, r4, r0
    3ca8:	0030      	movs	r0, r6
    3caa:	f000 f807 	bl	3cbc <_sbrk_r>
    3cae:	1c43      	adds	r3, r0, #1
    3cb0:	d1da      	bne.n	3c68 <_malloc_r+0x68>
    3cb2:	e7c6      	b.n	3c42 <_malloc_r+0x42>
    3cb4:	20003d54 	.word	0x20003d54
    3cb8:	20003d58 	.word	0x20003d58

00003cbc <_sbrk_r>:
    3cbc:	2300      	movs	r3, #0
    3cbe:	b570      	push	{r4, r5, r6, lr}
    3cc0:	4c06      	ldr	r4, [pc, #24]	; (3cdc <_sbrk_r+0x20>)
    3cc2:	0005      	movs	r5, r0
    3cc4:	0008      	movs	r0, r1
    3cc6:	6023      	str	r3, [r4, #0]
    3cc8:	f000 f814 	bl	3cf4 <_sbrk>
    3ccc:	1c43      	adds	r3, r0, #1
    3cce:	d103      	bne.n	3cd8 <_sbrk_r+0x1c>
    3cd0:	6823      	ldr	r3, [r4, #0]
    3cd2:	2b00      	cmp	r3, #0
    3cd4:	d000      	beq.n	3cd8 <_sbrk_r+0x1c>
    3cd6:	602b      	str	r3, [r5, #0]
    3cd8:	bd70      	pop	{r4, r5, r6, pc}
    3cda:	46c0      	nop			; (mov r8, r8)
    3cdc:	20003da4 	.word	0x20003da4

00003ce0 <strlen>:
    3ce0:	2300      	movs	r3, #0
    3ce2:	5cc2      	ldrb	r2, [r0, r3]
    3ce4:	3301      	adds	r3, #1
    3ce6:	2a00      	cmp	r2, #0
    3ce8:	d1fb      	bne.n	3ce2 <strlen+0x2>
    3cea:	1e58      	subs	r0, r3, #1
    3cec:	4770      	bx	lr

00003cee <__malloc_lock>:
    3cee:	4770      	bx	lr

00003cf0 <__malloc_unlock>:
    3cf0:	4770      	bx	lr
	...

00003cf4 <_sbrk>:
    3cf4:	4a04      	ldr	r2, [pc, #16]	; (3d08 <_sbrk+0x14>)
    3cf6:	6813      	ldr	r3, [r2, #0]
    3cf8:	2b00      	cmp	r3, #0
    3cfa:	d003      	beq.n	3d04 <_sbrk+0x10>
    3cfc:	1818      	adds	r0, r3, r0
    3cfe:	6010      	str	r0, [r2, #0]
    3d00:	0018      	movs	r0, r3
    3d02:	4770      	bx	lr
    3d04:	4b01      	ldr	r3, [pc, #4]	; (3d0c <_sbrk+0x18>)
    3d06:	e7f9      	b.n	3cfc <_sbrk+0x8>
    3d08:	20003d5c 	.word	0x20003d5c
    3d0c:	20003da8 	.word	0x20003da8

00003d10 <_init>:
    3d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d12:	46c0      	nop			; (mov r8, r8)
    3d14:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3d16:	bc08      	pop	{r3}
    3d18:	469e      	mov	lr, r3
    3d1a:	4770      	bx	lr

00003d1c <_fini>:
    3d1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d1e:	46c0      	nop			; (mov r8, r8)
    3d20:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3d22:	bc08      	pop	{r3}
    3d24:	469e      	mov	lr, r3
    3d26:	4770      	bx	lr
    3d28:	6b736154 	.word	0x6b736154
    3d2c:	6e6f4d20 	.word	0x6e6f4d20
    3d30:	726f7469 	.word	0x726f7469
    3d34:	7453203a 	.word	0x7453203a
    3d38:	65747261 	.word	0x65747261
    3d3c:	2a2a0064 	.word	0x2a2a0064
    3d40:	2a2a2a2a 	.word	0x2a2a2a2a
    3d44:	2a2a2a2a 	.word	0x2a2a2a2a
    3d48:	2a2a2a2a 	.word	0x2a2a2a2a
    3d4c:	2a2a2a2a 	.word	0x2a2a2a2a
    3d50:	2a2a2a2a 	.word	0x2a2a2a2a
    3d54:	2a2a2a2a 	.word	0x2a2a2a2a
    3d58:	2a2a2a2a 	.word	0x2a2a2a2a
    3d5c:	74535b00 	.word	0x74535b00
    3d60:	736b6361 	.word	0x736b6361
    3d64:	65724620 	.word	0x65724620
    3d68:	79422065 	.word	0x79422065
    3d6c:	20736574 	.word	0x20736574
    3d70:	616d6552 	.word	0x616d6552
    3d74:	6e696e69 	.word	0x6e696e69
    3d78:	00205d67 	.word	0x00205d67
    3d7c:	65726854 	.word	0x65726854
    3d80:	41206461 	.word	0x41206461
    3d84:	5400203a 	.word	0x5400203a
    3d88:	61657268 	.word	0x61657268
    3d8c:	3a422064 	.word	0x3a422064
    3d90:	6f4d0020 	.word	0x6f4d0020
    3d94:	6f74696e 	.word	0x6f74696e
    3d98:	74532072 	.word	0x74532072
    3d9c:	3a6b6361 	.word	0x3a6b6361
    3da0:	61540020 	.word	0x61540020
    3da4:	4d206b73 	.word	0x4d206b73
    3da8:	74696e6f 	.word	0x74696e6f
    3dac:	203a726f 	.word	0x203a726f
    3db0:	656c6544 	.word	0x656c6544
    3db4:	676e6974 	.word	0x676e6974
    3db8:	00          	.byte	0x00
    3db9:	54          	.byte	0x54
    3dba:	7268      	.short	0x7268
    3dbc:	20646165 	.word	0x20646165
    3dc0:	53203a41 	.word	0x53203a41
    3dc4:	74726174 	.word	0x74726174
    3dc8:	6465      	.short	0x6465
    3dca:	00          	.byte	0x00
    3dcb:	54          	.byte	0x54
    3dcc:	61657268 	.word	0x61657268
    3dd0:	3a422064 	.word	0x3a422064
    3dd4:	61745320 	.word	0x61745320
    3dd8:	64657472 	.word	0x64657472
    3ddc:	00          	.byte	0x00
    3ddd:	20          	.byte	0x20
    3dde:	2020      	.short	0x2020
    3de0:	20202020 	.word	0x20202020
    3de4:	6f725020 	.word	0x6f725020
    3de8:	6d617267 	.word	0x6d617267
    3dec:	61747320 	.word	0x61747320
    3df0:	20207472 	.word	0x20207472
    3df4:	20202020 	.word	0x20202020
    3df8:	00202020 	.word	0x00202020
    3dfc:	6b736154 	.word	0x6b736154
    3e00:	54004120 	.word	0x54004120
    3e04:	206b7361 	.word	0x206b7361
    3e08:	61540042 	.word	0x61540042
    3e0c:	4d206b73 	.word	0x4d206b73
    3e10:	74696e6f 	.word	0x74696e6f
    3e14:	726f      	.short	0x726f
    3e16:	00          	.byte	0x00
    3e17:	0d          	.byte	0x0d
    3e18:	0000000a 	.word	0x0000000a

00003e1c <_ZTV4Uart>:
	...
    3e24:	00000abd 00000451 000009e3 0000099f     ....Q...........
    3e34:	000009b9 00000b71 00000781 00000771     ....q.......q...
    3e44:	00000805 0000079b 0000076d              ........m...

00003e50 <_ZTV26DoubleBufferedEPOutHandler>:
	...
    3e58:	00000f3b 00000e1d 00000d79 00000be1     ;.......y.......
    3e68:	00000bf5                                ....

00003e6c <_ZL14STRING_PRODUCT>:
    3e6c:	75647241 206f6e69 5020304d 00006f72     Arduino M0 Pro..

00003e7c <_ZL15STRING_LANGUAGE>:
    3e7c:	04090304                                ....

00003e80 <_ZL19STRING_MANUFACTURER>:
    3e80:	75647241 206f6e69 00434c4c              Arduino LLC.

00003e8c <_ZL21USB_DeviceDescriptorB>:
    3e8c:	02000112 400102ef 804f2a03 02010100     .......@.*O.....
    3e9c:	44490103 5400454c 0051726d 20726d54     ..IDLE.TmrQ.Tmr 
    3eac:	00637653                                Svc.

00003eb0 <g_APinDescription>:
    3eb0:	00000000 0000000b 00000002 00000004     ................
    3ec0:	ffff00ff 000bffff 00000000 0000000a     ................
    3ed0:	00000002 00000004 ffff00ff 000affff     ................
    3ee0:	00000000 00000008 00000004 0000001c     ................
    3ef0:	000000ff 00ff0000 00000000 00000009     ................
    3f00:	00000004 0000001c 000100ff 00090001     ................
    3f10:	00000000 0000000e 00000004 0000001c     ................
    3f20:	030000ff 000e0300 00000000 0000000f     ................
    3f30:	00000004 0000001c 030100ff 000f0301     ................
    3f40:	00000000 00000014 00000005 0000002c     ............,...
    3f50:	000200ff 00040002 00000000 00000015     ................
    3f60:	00000005 0000002c 000300ff 00050003     ....,...........
    3f70:	00000000 00000006 00000004 0000001c     ................
    3f80:	010000ff 00060100 00000000 00000007     ................
    3f90:	00000004 0000001c 010100ff 00070101     ................
    3fa0:	00000000 00000012 00000004 0000001c     ................
    3fb0:	030000ff 00020300 00000000 00000010     ................
    3fc0:	00000004 0000001c 020000ff 00000200     ................
    3fd0:	00000000 00000013 00000004 0000001c     ................
    3fe0:	030100ff 00030301 00000000 00000011     ................
    3ff0:	00000004 0000001c 020100ff 00010201     ................
    4000:	000000ff 00000000 000000ff 00000000     ................
    4010:	ffff00ff 00ffffff 00000000 00000003     ................
    4020:	00000001 00000002 ffff00ff 00ffffff     ................
    4030:	00000000 00000016 00000002 00000004     ................
    4040:	ffff00ff 0006ffff 00000000 00000017     ................
    4050:	00000002 00000004 ffff00ff 0007ffff     ................
    4060:	00000000 0000000c 00000003 00000004     ................
    4070:	ffff00ff 000cffff 000000ff 00000000     ................
    4080:	000000ff 00000000 ffff00ff 00ffffff     ................
    4090:	00000001 0000000b 00000003 00000004     ................
    40a0:	ffff00ff 000bffff 00000001 0000000a     ................
    40b0:	00000003 00000004 ffff00ff 000affff     ................
    40c0:	000000ff 00000000 000000ff 00000000     ................
    40d0:	ffff00ff 00ffffff 000000ff 00000000     ................
    40e0:	000000ff 00000000 ffff00ff 00ffffff     ................
    40f0:	00000000 00000002 00000001 00000002     ................
    4100:	ffff0000 0002ffff 00000001 00000008     ................
    4110:	00000001 00000002 ffff0002 0008ffff     ................
    4120:	00000001 00000009 00000001 00000002     ................
    4130:	ffff0003 0009ffff 00000000 00000004     ................
    4140:	00000001 00000002 ffff0004 0004ffff     ................
    4150:	00000000 00000005 00000001 00000002     ................
    4160:	ffff0005 0005ffff 00000001 00000002     ................
    4170:	00000001 00000002 ffff000a 0002ffff     ................
    4180:	00000001 00000003 0000000b 00000004     ................
    4190:	ffff00ff 00ffffff 00000000 0000001b     ................
    41a0:	0000000b 00000004 ffff00ff 00ffffff     ................
    41b0:	00000000 0000001c 00000006 00000000     ................
    41c0:	ffff00ff 00ffffff 00000000 00000018     ................
    41d0:	00000006 00000000 ffff00ff 00ffffff     ................
    41e0:	00000000 00000019 00000006 00000000     ................
    41f0:	ffff00ff 00ffffff 00000001 00000016     ................
    4200:	00000003 00000000 ffff00ff 00ffffff     ................
    4210:	00000001 00000017 00000003 00000000     ................
    4220:	ffff00ff 00ffffff 00000000 00000016     ................
    4230:	00000002 00000000 ffff00ff 00ffffff     ................
    4240:	00000000 00000017 00000002 00000000     ................
    4250:	ffff00ff 00ffffff 00000000 00000013     ................
    4260:	00000002 00000000 ffff00ff 00ffffff     ................
    4270:	00000000 00000010 00000002 00000000     ................
    4280:	ffff00ff 00ffffff 00000000 00000012     ................
    4290:	00000002 00000000 ffff00ff 00ffffff     ................
    42a0:	00000000 00000011 00000002 00000000     ................
    42b0:	ffff00ff 00ffffff 00000000 0000000d     ................
    42c0:	00000004 0000000c 000100ff 000dffff     ................
    42d0:	00000000 00000015 00000005 0000000c     ................
    42e0:	000300ff 00ffffff 00000000 00000006     ................
    42f0:	00000004 0000000c 010000ff 00ffffff     ................
    4300:	00000000 00000007 00000004 0000000c     ................
    4310:	010100ff 00ffffff 00000000 00000002     ................
    4320:	00000001 00000002 ffff0014 0002ffff     ................

00004330 <_ZTV7Serial_>:
	...
    4338:	00002dfd 00002e29 00002df9 00002e1d     .-..)....-......
    4348:	00002e11 00002e61 00002e45              ....a...E...

00004354 <__EH_FRAME_BEGIN__>:
    4354:	00000000                                ....
